diff -Naurdw sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl.c workspace/src/event/ngx_event_openssl.c
--- sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl.c	2014-03-28 21:15:34.000000000 -0700
+++ workspace/src/event/ngx_event_openssl.c	2014-03-28 21:14:16.000000000 -0700
@@ -89,7 +89,6 @@
 int  ngx_ssl_server_conf_index;
 int  ngx_ssl_session_cache_index;
 int  ngx_ssl_session_ticket_keys_index;
-int  ngx_ssl_certificate_index;
 int  ngx_ssl_stapling_index;


@@ -154,14 +153,6 @@
         return NGX_ERROR;
     }

-    ngx_ssl_certificate_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL,
-                                                         NULL);
-    if (ngx_ssl_certificate_index == -1) {
-        ngx_ssl_error(NGX_LOG_ALERT, log, 0,
-                      "SSL_CTX_get_ex_new_index() failed");
-        return NGX_ERROR;
-    }
-
     ngx_ssl_stapling_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL,
                                                       NULL);
     if (ngx_ssl_stapling_index == -1) {
@@ -207,6 +198,10 @@
     SSL_CTX_set_options(ssl->ctx, SSL_OP_MSIE_SSLV2_RSA_PADDING);
 #endif

+#ifdef SSL_OP_SAFARI_ECDHE_ECDSA_BUG
+    SSL_CTX_set_options(ssl->ctx, SSL_OP_SAFARI_ECDHE_ECDSA_BUG);
+#endif
+
     SSL_CTX_set_options(ssl->ctx, SSL_OP_SSLEAY_080_CLIENT_DH_BUG);
     SSL_CTX_set_options(ssl->ctx, SSL_OP_TLS_D5_BUG);
     SSL_CTX_set_options(ssl->ctx, SSL_OP_TLS_BLOCK_PADDING_BUG);
@@ -252,66 +247,148 @@


 ngx_int_t
-ngx_ssl_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
-    ngx_str_t *key)
+ngx_ssl_certificates(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *certs,
+    ngx_array_t *keys, ngx_flag_t stapling, ngx_array_t *stapling_files,
+    ngx_str_t *stapling_responder, ngx_flag_t stapling_verify)
 {
-    BIO     *bio;
-    X509    *x509;
+    ngx_str_t       *cert;
+    ngx_str_t       *key;
+    ngx_str_t       *stapling_file = NULL;
+    ngx_uint_t       i;
+    ngx_int_t        j;
     u_long   n;
+    BIO             *bio = NULL;
+    EVP_PKEY        *pkey = NULL;
+    X509            *x509 = NULL;
+    X509            *x509_ca = NULL;
+#ifndef SSL_CTX_add0_chain_cert
+    STACK_OF(X509)  *extra_certs;
+#endif

-    if (ngx_conf_full_name(cf->cycle, cert, 1) != NGX_OK) {
+    cert = certs->elts;
+
+    if ((keys == NGX_CONF_UNSET_PTR) || (keys->nelts < certs->nelts)) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "no \"ssl_certificate_key\" is defined for "
+                      "ssl_certificate \"%V\"",
+                      &cert[(keys == NGX_CONF_UNSET_PTR) ? 0 : keys->nelts]);
+        return NGX_ERROR;
+    }
+
+    /* setup OCSP stapling for this SSL_CTX */
+
+    if (stapling) {
+
+        if (stapling_files != NGX_CONF_UNSET_PTR) {
+
+            if (stapling_files->nelts < certs->nelts) {
+                ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                              "no \"ssl_stapling_file\" is defined for "
+                              "ssl_certificate \"%V\"",
+                              &cert[stapling_files->nelts]);
         return NGX_ERROR;
     }

+            stapling_file = stapling_files->elts;
+
+        }
+
+        if (ngx_ssl_stapling(cf, ssl, stapling_verify) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+    }
+
+    key = keys->elts;
+
+    for (i = 0; i < certs->nelts; i++) {
+
+        /* load private key */
+
+        if (ngx_conf_full_name(cf->cycle, &key[i], 1) != NGX_OK) {
+            goto failed;
+        }
+
+        bio = BIO_new_file((char *) (&key[i])->data, "r");
+        if (bio == NULL) {
+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                          "BIO_new_file(\"%V\") failed", &key[i]);
+            goto failed;
+        }
+
+        pkey = PEM_read_bio_PrivateKey(bio, NULL, NULL, NULL);
+        if (pkey == NULL) {
+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                          "PEM_read_bio_PrivateKey(\"%V\") failed", &key[i]);
+            goto failed;
+        }
+
+        BIO_free(bio);
+        bio = NULL;
+
+        /* load server certificate */
+
+        if (ngx_conf_full_name(cf->cycle, &cert[i], 1) != NGX_OK) {
+            goto failed;
+        }
+
     /*
      * we can't use SSL_CTX_use_certificate_chain_file() as it doesn't
      * allow to access certificate later from SSL_CTX, so we reimplement
      * it here
      */

-    bio = BIO_new_file((char *) cert->data, "r");
+        bio = BIO_new_file((char *) (&cert[i])->data, "r");
     if (bio == NULL) {
         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
-                      "BIO_new_file(\"%s\") failed", cert->data);
-        return NGX_ERROR;
+                          "BIO_new_file(\"%V\") failed", &cert[i]);
+            goto failed;
     }

     x509 = PEM_read_bio_X509_AUX(bio, NULL, NULL, NULL);
     if (x509 == NULL) {
         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
-                      "PEM_read_bio_X509_AUX(\"%s\") failed", cert->data);
-        BIO_free(bio);
-        return NGX_ERROR;
+                          "PEM_read_bio_X509_AUX(\"%V\") failed", &cert[i]);
+            goto failed;
     }

-    if (SSL_CTX_use_certificate(ssl->ctx, x509) == 0) {
+        if (X509_check_private_key(x509, pkey) != 1) {
         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
-                      "SSL_CTX_use_certificate(\"%s\") failed", cert->data);
-        X509_free(x509);
-        BIO_free(bio);
-        return NGX_ERROR;
+                          "X509_check_private_key(\"%V\") for \"%V\" failed",
+                          &key[i], &cert[i]);
+            goto failed;
     }

-    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_certificate_index, x509)
-        == 0)
-    {
+        if (SSL_CTX_use_certificate(ssl->ctx, x509) == 0) {
         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
-                      "SSL_CTX_set_ex_data() failed");
-        X509_free(x509);
-        BIO_free(bio);
-        return NGX_ERROR;
+                          "SSL_CTX_use_certificate(\"%V\") failed", &cert[i]);
+            goto failed;
     }

-    X509_free(x509);
+        if (SSL_CTX_use_PrivateKey(ssl->ctx, pkey) != 1) {
+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                          "SSL_CTX_use_PrivateKey(\"%V\") failed", &key[i]);
+            goto failed;
+        }

     /* read rest of the chain */

-    for ( ;; ) {
+        for (j = 0; ; j++) {

-        x509 = PEM_read_bio_X509(bio, NULL, NULL, NULL);
-        if (x509 == NULL) {
+            x509_ca = PEM_read_bio_X509(bio, NULL, NULL, NULL);
             n = ERR_peek_last_error();

+            /* setup OCSP stapling for this server certificate */
+            if (stapling && (j == 0)) {
+                if (ngx_ssl_stapling_cert(cf, ssl, x509_ca, x509, &cert[i],
+                                          stapling_file ? &stapling_file[i]
+                                                        : NULL,
+                                          stapling_responder) != NGX_OK)
+                    goto failed;
+            }
+
+            if (x509_ca == NULL) {
+
             if (ERR_GET_LIB(n) == ERR_LIB_PEM
                 && ERR_GET_REASON(n) == PEM_R_NO_START_LINE)
             {
@@ -323,37 +400,93 @@
             /* some real error */

             ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
-                          "PEM_read_bio_X509(\"%s\") failed", cert->data);
-            BIO_free(bio);
-            return NGX_ERROR;
+                              "PEM_read_bio_X509(\"%V\") failed", &cert[i]);
+                goto failed;
         }

-        if (SSL_CTX_add_extra_chain_cert(ssl->ctx, x509) == 0) {
+#ifdef SSL_CTX_add0_chain_cert
+            /* OpenSSL >=1.0.2 allows multiple server certificates in a single
+             * SSL_CTX to each have a different chain
+             */
+            if (SSL_CTX_add0_chain_cert(ssl->ctx, x509_ca) == 0) {
             ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
-                          "SSL_CTX_add_extra_chain_cert(\"%s\") failed",
-                          cert->data);
-            X509_free(x509);
-            BIO_free(bio);
-            return NGX_ERROR;
+                              "SSL_CTX_add0_chain_cert(\"%V\") failed",
+                              &cert[i]);
+                goto failed;
         }
+#else
+            /* OpenSSL <1.0.2 restricts multiple server certificates in a single
+             * SSL_CTX to sharing the same "extra_certs" chain.
+             * If different chains are required, "extra_certs" must be left
+             * empty and all of the intermediates must be added to the
+             * ssl_trusted_certificate file.  (Note that this has the
+             * side-effect of enabling these intermediates for verification of
+             * client certificates and OCSP Responses)
+             */
+            if (i == 0) {
+
+                if (SSL_CTX_add_extra_chain_cert(ssl->ctx, x509_ca) == 0) {
+                    ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                                  "SSL_CTX_add_extra_chain_cert() failed");
+                    goto failed;
     }

-    BIO_free(bio);
+            } else {

-    if (ngx_conf_full_name(cf->cycle, key, 1) != NGX_OK) {
-        return NGX_ERROR;
-    }
+#ifdef SSL_CTX_get_extra_chain_certs
+                SSL_CTX_get_extra_chain_certs(ssl->ctx, &extra_certs);
+#else
+                extra_certs = ssl->ctx->extra_certs;
+#endif

-    if (SSL_CTX_use_PrivateKey_file(ssl->ctx, (char *) key->data,
-                                    SSL_FILETYPE_PEM)
-        == 0)
+                if ((extra_certs == NULL) || (j >= sk_X509_num(extra_certs))
+                    || (X509_cmp(x509_ca, sk_X509_value(extra_certs, j)) != 0))
     {
         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
-                      "SSL_CTX_use_PrivateKey_file(\"%s\") failed", key->data);
-        return NGX_ERROR;
+                                  "the intermediate CA certificate(s) in "
+                                  "\"%V\" do not match those in \"%V\".  Due "
+                                  "to a limitation in the OpenSSL library that "
+                                  "nginx is using, you need to move all of the "
+                                  "CA certificates into the "
+                                  "\"ssl_trusted_certificate\" file, but be "
+                                  "aware that this will have the side-effect "
+                                  "of enabling them for verification of client "
+                                  "certificates and OCSP Responses",
+                                  &cert[i], &cert[0]);
+                    goto failed;
+                }
+
+                X509_free(x509_ca);
+
+            }
+#endif
+
+        }
+
+        BIO_free(bio);
+        bio = NULL;
+
+        EVP_PKEY_free(pkey);
+        pkey = NULL;
+
+        X509_free(x509);
+        x509 = NULL;
+
     }

     return NGX_OK;
+
+failed:
+    if (bio)
+        BIO_free(bio);
+    if (pkey)
+        EVP_PKEY_free(pkey);
+    if (x509)
+        X509_free(x509);
+    if (x509_ca)
+        X509_free(x509_ca);
+
+    return NGX_ERROR;
 }


diff -Naurdw sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl.c.orig workspace/src/event/ngx_event_openssl.c.orig
--- sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/event/ngx_event_openssl.c.orig	2014-03-28 20:55:34.000000000 -0700
@@ -0,0 +1,2852 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+
+
+typedef struct {
+    ngx_uint_t  engine;   /* unsigned  engine:1; */
+} ngx_openssl_conf_t;
+
+
+static int ngx_ssl_verify_callback(int ok, X509_STORE_CTX *x509_store);
+static void ngx_ssl_info_callback(const ngx_ssl_conn_t *ssl_conn, int where,
+    int ret);
+static void ngx_ssl_handshake_handler(ngx_event_t *ev);
+static ngx_int_t ngx_ssl_handle_recv(ngx_connection_t *c, int n);
+static void ngx_ssl_write_handler(ngx_event_t *wev);
+static void ngx_ssl_read_handler(ngx_event_t *rev);
+static void ngx_ssl_shutdown_handler(ngx_event_t *ev);
+static void ngx_ssl_connection_error(ngx_connection_t *c, int sslerr,
+    ngx_err_t err, char *text);
+static void ngx_ssl_clear_error(ngx_log_t *log);
+
+ngx_int_t ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data);
+static int ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn,
+    ngx_ssl_session_t *sess);
+static ngx_ssl_session_t *ngx_ssl_get_cached_session(ngx_ssl_conn_t *ssl_conn,
+    u_char *id, int len, int *copy);
+static void ngx_ssl_remove_session(SSL_CTX *ssl, ngx_ssl_session_t *sess);
+static void ngx_ssl_expire_sessions(ngx_ssl_session_cache_t *cache,
+    ngx_slab_pool_t *shpool, ngx_uint_t n);
+static void ngx_ssl_session_rbtree_insert_value(ngx_rbtree_node_t *temp,
+    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel);
+
+#ifdef SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB
+static int ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,
+    unsigned char *name, unsigned char *iv, EVP_CIPHER_CTX *ectx,
+    HMAC_CTX *hctx, int enc);
+#endif
+
+static void *ngx_openssl_create_conf(ngx_cycle_t *cycle);
+static char *ngx_openssl_engine(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static void ngx_openssl_exit(ngx_cycle_t *cycle);
+
+
+static ngx_command_t  ngx_openssl_commands[] = {
+
+    { ngx_string("ssl_engine"),
+      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
+      ngx_openssl_engine,
+      0,
+      0,
+      NULL },
+
+      ngx_null_command
+};
+
+
+static ngx_core_module_t  ngx_openssl_module_ctx = {
+    ngx_string("openssl"),
+    ngx_openssl_create_conf,
+    NULL
+};
+
+
+ngx_module_t  ngx_openssl_module = {
+    NGX_MODULE_V1,
+    &ngx_openssl_module_ctx,               /* module context */
+    ngx_openssl_commands,                  /* module directives */
+    NGX_CORE_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    ngx_openssl_exit,                      /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+int  ngx_ssl_connection_index;
+int  ngx_ssl_server_conf_index;
+int  ngx_ssl_session_cache_index;
+int  ngx_ssl_session_ticket_keys_index;
+int  ngx_ssl_certificate_index;
+int  ngx_ssl_stapling_index;
+
+
+ngx_int_t
+ngx_ssl_init(ngx_log_t *log)
+{
+    OPENSSL_config(NULL);
+
+    SSL_library_init();
+    SSL_load_error_strings();
+
+    OpenSSL_add_all_algorithms();
+
+#if OPENSSL_VERSION_NUMBER >= 0x0090800fL
+#ifndef SSL_OP_NO_COMPRESSION
+    {
+    /*
+     * Disable gzip compression in OpenSSL prior to 1.0.0 version,
+     * this saves about 522K per connection.
+     */
+    int                  n;
+    STACK_OF(SSL_COMP)  *ssl_comp_methods;
+
+    ssl_comp_methods = SSL_COMP_get_compression_methods();
+    n = sk_SSL_COMP_num(ssl_comp_methods);
+
+    while (n--) {
+        (void) sk_SSL_COMP_pop(ssl_comp_methods);
+    }
+    }
+#endif
+#endif
+
+    ngx_ssl_connection_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);
+
+    if (ngx_ssl_connection_index == -1) {
+        ngx_ssl_error(NGX_LOG_ALERT, log, 0, "SSL_get_ex_new_index() failed");
+        return NGX_ERROR;
+    }
+
+    ngx_ssl_server_conf_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL,
+                                                         NULL);
+    if (ngx_ssl_server_conf_index == -1) {
+        ngx_ssl_error(NGX_LOG_ALERT, log, 0,
+                      "SSL_CTX_get_ex_new_index() failed");
+        return NGX_ERROR;
+    }
+
+    ngx_ssl_session_cache_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL,
+                                                           NULL);
+    if (ngx_ssl_session_cache_index == -1) {
+        ngx_ssl_error(NGX_LOG_ALERT, log, 0,
+                      "SSL_CTX_get_ex_new_index() failed");
+        return NGX_ERROR;
+    }
+
+    ngx_ssl_session_ticket_keys_index = SSL_CTX_get_ex_new_index(0, NULL, NULL,
+                                                                 NULL, NULL);
+    if (ngx_ssl_session_ticket_keys_index == -1) {
+        ngx_ssl_error(NGX_LOG_ALERT, log, 0,
+                      "SSL_CTX_get_ex_new_index() failed");
+        return NGX_ERROR;
+    }
+
+    ngx_ssl_certificate_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL,
+                                                         NULL);
+    if (ngx_ssl_certificate_index == -1) {
+        ngx_ssl_error(NGX_LOG_ALERT, log, 0,
+                      "SSL_CTX_get_ex_new_index() failed");
+        return NGX_ERROR;
+    }
+
+    ngx_ssl_stapling_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL,
+                                                      NULL);
+    if (ngx_ssl_stapling_index == -1) {
+        ngx_ssl_error(NGX_LOG_ALERT, log, 0,
+                      "SSL_CTX_get_ex_new_index() failed");
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data)
+{
+    ssl->ctx = SSL_CTX_new(SSLv23_method());
+
+    if (ssl->ctx == NULL) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0, "SSL_CTX_new() failed");
+        return NGX_ERROR;
+    }
+
+    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_server_conf_index, data) == 0) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "SSL_CTX_set_ex_data() failed");
+        return NGX_ERROR;
+    }
+
+    ssl->buffer_size = NGX_SSL_BUFSIZE;
+
+    /* client side options */
+
+    SSL_CTX_set_options(ssl->ctx, SSL_OP_MICROSOFT_SESS_ID_BUG);
+    SSL_CTX_set_options(ssl->ctx, SSL_OP_NETSCAPE_CHALLENGE_BUG);
+
+    /* server side options */
+
+    SSL_CTX_set_options(ssl->ctx, SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG);
+    SSL_CTX_set_options(ssl->ctx, SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER);
+
+#ifdef SSL_OP_MSIE_SSLV2_RSA_PADDING
+    /* this option allow a potential SSL 2.0 rollback (CAN-2005-2969) */
+    SSL_CTX_set_options(ssl->ctx, SSL_OP_MSIE_SSLV2_RSA_PADDING);
+#endif
+
+    SSL_CTX_set_options(ssl->ctx, SSL_OP_SSLEAY_080_CLIENT_DH_BUG);
+    SSL_CTX_set_options(ssl->ctx, SSL_OP_TLS_D5_BUG);
+    SSL_CTX_set_options(ssl->ctx, SSL_OP_TLS_BLOCK_PADDING_BUG);
+
+    SSL_CTX_set_options(ssl->ctx, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
+
+    SSL_CTX_set_options(ssl->ctx, SSL_OP_SINGLE_DH_USE);
+
+    if (!(protocols & NGX_SSL_SSLv2)) {
+        SSL_CTX_set_options(ssl->ctx, SSL_OP_NO_SSLv2);
+    }
+    if (!(protocols & NGX_SSL_SSLv3)) {
+        SSL_CTX_set_options(ssl->ctx, SSL_OP_NO_SSLv3);
+    }
+    if (!(protocols & NGX_SSL_TLSv1)) {
+        SSL_CTX_set_options(ssl->ctx, SSL_OP_NO_TLSv1);
+    }
+#ifdef SSL_OP_NO_TLSv1_1
+    if (!(protocols & NGX_SSL_TLSv1_1)) {
+        SSL_CTX_set_options(ssl->ctx, SSL_OP_NO_TLSv1_1);
+    }
+#endif
+#ifdef SSL_OP_NO_TLSv1_2
+    if (!(protocols & NGX_SSL_TLSv1_2)) {
+        SSL_CTX_set_options(ssl->ctx, SSL_OP_NO_TLSv1_2);
+    }
+#endif
+
+#ifdef SSL_OP_NO_COMPRESSION
+    SSL_CTX_set_options(ssl->ctx, SSL_OP_NO_COMPRESSION);
+#endif
+
+#ifdef SSL_MODE_RELEASE_BUFFERS
+    SSL_CTX_set_mode(ssl->ctx, SSL_MODE_RELEASE_BUFFERS);
+#endif
+
+    SSL_CTX_set_read_ahead(ssl->ctx, 1);
+
+    SSL_CTX_set_info_callback(ssl->ctx, ngx_ssl_info_callback);
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
+    ngx_str_t *key)
+{
+    BIO     *bio;
+    X509    *x509;
+    u_long   n;
+
+    if (ngx_conf_full_name(cf->cycle, cert, 1) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    /*
+     * we can't use SSL_CTX_use_certificate_chain_file() as it doesn't
+     * allow to access certificate later from SSL_CTX, so we reimplement
+     * it here
+     */
+
+    bio = BIO_new_file((char *) cert->data, "r");
+    if (bio == NULL) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "BIO_new_file(\"%s\") failed", cert->data);
+        return NGX_ERROR;
+    }
+
+    x509 = PEM_read_bio_X509_AUX(bio, NULL, NULL, NULL);
+    if (x509 == NULL) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "PEM_read_bio_X509_AUX(\"%s\") failed", cert->data);
+        BIO_free(bio);
+        return NGX_ERROR;
+    }
+
+    if (SSL_CTX_use_certificate(ssl->ctx, x509) == 0) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "SSL_CTX_use_certificate(\"%s\") failed", cert->data);
+        X509_free(x509);
+        BIO_free(bio);
+        return NGX_ERROR;
+    }
+
+    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_certificate_index, x509)
+        == 0)
+    {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "SSL_CTX_set_ex_data() failed");
+        X509_free(x509);
+        BIO_free(bio);
+        return NGX_ERROR;
+    }
+
+    X509_free(x509);
+
+    /* read rest of the chain */
+
+    for ( ;; ) {
+
+        x509 = PEM_read_bio_X509(bio, NULL, NULL, NULL);
+        if (x509 == NULL) {
+            n = ERR_peek_last_error();
+
+            if (ERR_GET_LIB(n) == ERR_LIB_PEM
+                && ERR_GET_REASON(n) == PEM_R_NO_START_LINE)
+            {
+                /* end of file */
+                ERR_clear_error();
+                break;
+            }
+
+            /* some real error */
+
+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                          "PEM_read_bio_X509(\"%s\") failed", cert->data);
+            BIO_free(bio);
+            return NGX_ERROR;
+        }
+
+        if (SSL_CTX_add_extra_chain_cert(ssl->ctx, x509) == 0) {
+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                          "SSL_CTX_add_extra_chain_cert(\"%s\") failed",
+                          cert->data);
+            X509_free(x509);
+            BIO_free(bio);
+            return NGX_ERROR;
+        }
+    }
+
+    BIO_free(bio);
+
+    if (ngx_conf_full_name(cf->cycle, key, 1) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    if (SSL_CTX_use_PrivateKey_file(ssl->ctx, (char *) key->data,
+                                    SSL_FILETYPE_PEM)
+        == 0)
+    {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "SSL_CTX_use_PrivateKey_file(\"%s\") failed", key->data);
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_client_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
+    ngx_int_t depth)
+{
+    STACK_OF(X509_NAME)  *list;
+
+    SSL_CTX_set_verify(ssl->ctx, SSL_VERIFY_PEER, ngx_ssl_verify_callback);
+
+    SSL_CTX_set_verify_depth(ssl->ctx, depth);
+
+    if (cert->len == 0) {
+        return NGX_OK;
+    }
+
+    if (ngx_conf_full_name(cf->cycle, cert, 1) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    if (SSL_CTX_load_verify_locations(ssl->ctx, (char *) cert->data, NULL)
+        == 0)
+    {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "SSL_CTX_load_verify_locations(\"%s\") failed",
+                      cert->data);
+        return NGX_ERROR;
+    }
+
+    /*
+     * SSL_CTX_load_verify_locations() may leave errors in the error queue
+     * while returning success
+     */
+
+    ERR_clear_error();
+
+    list = SSL_load_client_CA_file((char *) cert->data);
+
+    if (list == NULL) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "SSL_load_client_CA_file(\"%s\") failed", cert->data);
+        return NGX_ERROR;
+    }
+
+    /*
+     * before 0.9.7h and 0.9.8 SSL_load_client_CA_file()
+     * always leaved an error in the error queue
+     */
+
+    ERR_clear_error();
+
+    SSL_CTX_set_client_CA_list(ssl->ctx, list);
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
+    ngx_int_t depth)
+{
+    SSL_CTX_set_verify_depth(ssl->ctx, depth);
+
+    if (cert->len == 0) {
+        return NGX_OK;
+    }
+
+    if (ngx_conf_full_name(cf->cycle, cert, 1) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    if (SSL_CTX_load_verify_locations(ssl->ctx, (char *) cert->data, NULL)
+        == 0)
+    {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "SSL_CTX_load_verify_locations(\"%s\") failed",
+                      cert->data);
+        return NGX_ERROR;
+    }
+
+    /*
+     * SSL_CTX_load_verify_locations() may leave errors in the error queue
+     * while returning success
+     */
+
+    ERR_clear_error();
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_crl(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *crl)
+{
+    X509_STORE   *store;
+    X509_LOOKUP  *lookup;
+
+    if (crl->len == 0) {
+        return NGX_OK;
+    }
+
+    if (ngx_conf_full_name(cf->cycle, crl, 1) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    store = SSL_CTX_get_cert_store(ssl->ctx);
+
+    if (store == NULL) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "SSL_CTX_get_cert_store() failed");
+        return NGX_ERROR;
+    }
+
+    lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());
+
+    if (lookup == NULL) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "X509_STORE_add_lookup() failed");
+        return NGX_ERROR;
+    }
+
+    if (X509_LOOKUP_load_file(lookup, (char *) crl->data, X509_FILETYPE_PEM)
+        == 0)
+    {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "X509_LOOKUP_load_file(\"%s\") failed", crl->data);
+        return NGX_ERROR;
+    }
+
+    X509_STORE_set_flags(store,
+                         X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);
+
+    return NGX_OK;
+}
+
+
+static int
+ngx_ssl_verify_callback(int ok, X509_STORE_CTX *x509_store)
+{
+#if (NGX_DEBUG)
+    char              *subject, *issuer;
+    int                err, depth;
+    X509              *cert;
+    X509_NAME         *sname, *iname;
+    ngx_connection_t  *c;
+    ngx_ssl_conn_t    *ssl_conn;
+
+    ssl_conn = X509_STORE_CTX_get_ex_data(x509_store,
+                                          SSL_get_ex_data_X509_STORE_CTX_idx());
+
+    c = ngx_ssl_get_connection(ssl_conn);
+
+    cert = X509_STORE_CTX_get_current_cert(x509_store);
+    err = X509_STORE_CTX_get_error(x509_store);
+    depth = X509_STORE_CTX_get_error_depth(x509_store);
+
+    sname = X509_get_subject_name(cert);
+    subject = sname ? X509_NAME_oneline(sname, NULL, 0) : "(none)";
+
+    iname = X509_get_issuer_name(cert);
+    issuer = iname ? X509_NAME_oneline(iname, NULL, 0) : "(none)";
+
+    ngx_log_debug5(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "verify:%d, error:%d, depth:%d, "
+                   "subject:\"%s\",issuer: \"%s\"",
+                   ok, err, depth, subject, issuer);
+
+    if (sname) {
+        OPENSSL_free(subject);
+    }
+
+    if (iname) {
+        OPENSSL_free(issuer);
+    }
+#endif
+
+    return 1;
+}
+
+
+static void
+ngx_ssl_info_callback(const ngx_ssl_conn_t *ssl_conn, int where, int ret)
+{
+    BIO               *rbio, *wbio;
+    ngx_connection_t  *c;
+
+    if (where & SSL_CB_HANDSHAKE_START) {
+        c = ngx_ssl_get_connection((ngx_ssl_conn_t *) ssl_conn);
+
+        if (c->ssl->handshaked) {
+            c->ssl->renegotiation = 1;
+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL renegotiation");
+        }
+    }
+
+    if ((where & SSL_CB_ACCEPT_LOOP) == SSL_CB_ACCEPT_LOOP) {
+        c = ngx_ssl_get_connection((ngx_ssl_conn_t *) ssl_conn);
+
+        if (!c->ssl->handshake_buffer_set) {
+            /*
+             * By default OpenSSL uses 4k buffer during a handshake,
+             * which is too low for long certificate chains and might
+             * result in extra round-trips.
+             *
+             * To adjust a buffer size we detect that buffering was added
+             * to write side of the connection by comparing rbio and wbio.
+             * If they are different, we assume that it's due to buffering
+             * added to wbio, and set buffer size.
+             */
+
+            rbio = SSL_get_rbio((ngx_ssl_conn_t *) ssl_conn);
+            wbio = SSL_get_wbio((ngx_ssl_conn_t *) ssl_conn);
+
+            if (rbio != wbio) {
+                (void) BIO_set_write_buffer_size(wbio, NGX_SSL_BUFSIZE);
+                c->ssl->handshake_buffer_set = 1;
+            }
+        }
+    }
+}
+
+
+RSA *
+ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,
+    int key_length)
+{
+    static RSA  *key;
+
+    if (key_length == 512) {
+        if (key == NULL) {
+            key = RSA_generate_key(512, RSA_F4, NULL, NULL);
+        }
+    }
+
+    return key;
+}
+
+
+ngx_int_t
+ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)
+{
+    DH   *dh;
+    BIO  *bio;
+
+    /*
+     * -----BEGIN DH PARAMETERS-----
+     * MIGHAoGBALu8LcrYRnSQfEP89YDpz9vZWKP1aLQtSwju1OsPs1BMbAMCducQgAxc
+     * y7qokiYUxb7spWWl/fHSh6K8BJvmd4Bg6RqSp1fjBI9osHb302zI8pul34HcLKcl
+     * 7OZicMyaUDXYzs7vnqAnSmOrHlj6/UmI0PZdFGdX2gcd8EXP4WubAgEC
+     * -----END DH PARAMETERS-----
+     */
+
+    static unsigned char dh1024_p[] = {
+        0xBB, 0xBC, 0x2D, 0xCA, 0xD8, 0x46, 0x74, 0x90, 0x7C, 0x43, 0xFC, 0xF5,
+        0x80, 0xE9, 0xCF, 0xDB, 0xD9, 0x58, 0xA3, 0xF5, 0x68, 0xB4, 0x2D, 0x4B,
+        0x08, 0xEE, 0xD4, 0xEB, 0x0F, 0xB3, 0x50, 0x4C, 0x6C, 0x03, 0x02, 0x76,
+        0xE7, 0x10, 0x80, 0x0C, 0x5C, 0xCB, 0xBA, 0xA8, 0x92, 0x26, 0x14, 0xC5,
+        0xBE, 0xEC, 0xA5, 0x65, 0xA5, 0xFD, 0xF1, 0xD2, 0x87, 0xA2, 0xBC, 0x04,
+        0x9B, 0xE6, 0x77, 0x80, 0x60, 0xE9, 0x1A, 0x92, 0xA7, 0x57, 0xE3, 0x04,
+        0x8F, 0x68, 0xB0, 0x76, 0xF7, 0xD3, 0x6C, 0xC8, 0xF2, 0x9B, 0xA5, 0xDF,
+        0x81, 0xDC, 0x2C, 0xA7, 0x25, 0xEC, 0xE6, 0x62, 0x70, 0xCC, 0x9A, 0x50,
+        0x35, 0xD8, 0xCE, 0xCE, 0xEF, 0x9E, 0xA0, 0x27, 0x4A, 0x63, 0xAB, 0x1E,
+        0x58, 0xFA, 0xFD, 0x49, 0x88, 0xD0, 0xF6, 0x5D, 0x14, 0x67, 0x57, 0xDA,
+        0x07, 0x1D, 0xF0, 0x45, 0xCF, 0xE1, 0x6B, 0x9B
+    };
+
+    static unsigned char dh1024_g[] = { 0x02 };
+
+
+    if (file->len == 0) {
+
+        dh = DH_new();
+        if (dh == NULL) {
+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0, "DH_new() failed");
+            return NGX_ERROR;
+        }
+
+        dh->p = BN_bin2bn(dh1024_p, sizeof(dh1024_p), NULL);
+        dh->g = BN_bin2bn(dh1024_g, sizeof(dh1024_g), NULL);
+
+        if (dh->p == NULL || dh->g == NULL) {
+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0, "BN_bin2bn() failed");
+            DH_free(dh);
+            return NGX_ERROR;
+        }
+
+        SSL_CTX_set_tmp_dh(ssl->ctx, dh);
+
+        DH_free(dh);
+
+        return NGX_OK;
+    }
+
+    if (ngx_conf_full_name(cf->cycle, file, 1) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    bio = BIO_new_file((char *) file->data, "r");
+    if (bio == NULL) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "BIO_new_file(\"%s\") failed", file->data);
+        return NGX_ERROR;
+    }
+
+    dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);
+    if (dh == NULL) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "PEM_read_bio_DHparams(\"%s\") failed", file->data);
+        BIO_free(bio);
+        return NGX_ERROR;
+    }
+
+    SSL_CTX_set_tmp_dh(ssl->ctx, dh);
+
+    DH_free(dh);
+    BIO_free(bio);
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name)
+{
+#if OPENSSL_VERSION_NUMBER >= 0x0090800fL
+#ifndef OPENSSL_NO_ECDH
+    int      nid;
+    EC_KEY  *ecdh;
+
+    /*
+     * Elliptic-Curve Diffie-Hellman parameters are either "named curves"
+     * from RFC 4492 section 5.1.1, or explicitly described curves over
+     * binary fields. OpenSSL only supports the "named curves", which provide
+     * maximum interoperability.
+     */
+
+    nid = OBJ_sn2nid((const char *) name->data);
+    if (nid == 0) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "Unknown curve name \"%s\"", name->data);
+        return NGX_ERROR;
+    }
+
+    ecdh = EC_KEY_new_by_curve_name(nid);
+    if (ecdh == NULL) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "Unable to create curve \"%s\"", name->data);
+        return NGX_ERROR;
+    }
+
+    SSL_CTX_set_options(ssl->ctx, SSL_OP_SINGLE_ECDH_USE);
+
+    SSL_CTX_set_tmp_ecdh(ssl->ctx, ecdh);
+
+    EC_KEY_free(ecdh);
+#endif
+#endif
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_create_connection(ngx_ssl_t *ssl, ngx_connection_t *c, ngx_uint_t flags)
+{
+    ngx_ssl_connection_t  *sc;
+
+    sc = ngx_pcalloc(c->pool, sizeof(ngx_ssl_connection_t));
+    if (sc == NULL) {
+        return NGX_ERROR;
+    }
+
+    sc->buffer = ((flags & NGX_SSL_BUFFER) != 0);
+    sc->buffer_size = ssl->buffer_size;
+
+    sc->connection = SSL_new(ssl->ctx);
+
+    if (sc->connection == NULL) {
+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, "SSL_new() failed");
+        return NGX_ERROR;
+    }
+
+    if (SSL_set_fd(sc->connection, c->fd) == 0) {
+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, "SSL_set_fd() failed");
+        return NGX_ERROR;
+    }
+
+    if (flags & NGX_SSL_CLIENT) {
+        SSL_set_connect_state(sc->connection);
+
+    } else {
+        SSL_set_accept_state(sc->connection);
+    }
+
+    if (SSL_set_ex_data(sc->connection, ngx_ssl_connection_index, c) == 0) {
+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, "SSL_set_ex_data() failed");
+        return NGX_ERROR;
+    }
+
+    c->ssl = sc;
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_set_session(ngx_connection_t *c, ngx_ssl_session_t *session)
+{
+    if (session) {
+        if (SSL_set_session(c->ssl->connection, session) == 0) {
+            ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, "SSL_set_session() failed");
+            return NGX_ERROR;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_handshake(ngx_connection_t *c)
+{
+    int        n, sslerr;
+    ngx_err_t  err;
+
+    ngx_ssl_clear_error(c->log);
+
+    n = SSL_do_handshake(c->ssl->connection);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_do_handshake: %d", n);
+
+    if (n == 1) {
+
+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+#if (NGX_DEBUG)
+        {
+        char         buf[129], *s, *d;
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+        const
+#endif
+        SSL_CIPHER  *cipher;
+
+        cipher = SSL_get_current_cipher(c->ssl->connection);
+
+        if (cipher) {
+            SSL_CIPHER_description(cipher, &buf[1], 128);
+
+            for (s = &buf[1], d = buf; *s; s++) {
+                if (*s == ' ' && *d == ' ') {
+                    continue;
+                }
+
+                if (*s == LF || *s == CR) {
+                    continue;
+                }
+
+                *++d = *s;
+            }
+
+            if (*d != ' ') {
+                d++;
+            }
+
+            *d = '\0';
+
+            ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                           "SSL: %s, cipher: \"%s\"",
+                           SSL_get_version(c->ssl->connection), &buf[1]);
+
+            if (SSL_session_reused(c->ssl->connection)) {
+                ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                               "SSL reused session");
+            }
+
+        } else {
+            ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                           "SSL no shared ciphers");
+        }
+        }
+#endif
+
+        c->ssl->handshaked = 1;
+
+        c->recv = ngx_ssl_recv;
+        c->send = ngx_ssl_write;
+        c->recv_chain = ngx_ssl_recv_chain;
+        c->send_chain = ngx_ssl_send_chain;
+
+        /* initial handshake done, disable renegotiation (CVE-2009-3555) */
+        if (c->ssl->connection->s3) {
+            c->ssl->connection->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;
+        }
+
+        return NGX_OK;
+    }
+
+    sslerr = SSL_get_error(c->ssl->connection, n);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_get_error: %d", sslerr);
+
+    if (sslerr == SSL_ERROR_WANT_READ) {
+        c->read->ready = 0;
+        c->read->handler = ngx_ssl_handshake_handler;
+        c->write->handler = ngx_ssl_handshake_handler;
+
+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        return NGX_AGAIN;
+    }
+
+    if (sslerr == SSL_ERROR_WANT_WRITE) {
+        c->write->ready = 0;
+        c->read->handler = ngx_ssl_handshake_handler;
+        c->write->handler = ngx_ssl_handshake_handler;
+
+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        return NGX_AGAIN;
+    }
+
+    err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;
+
+    c->ssl->no_wait_shutdown = 1;
+    c->ssl->no_send_shutdown = 1;
+    c->read->eof = 1;
+
+    if (sslerr == SSL_ERROR_ZERO_RETURN || ERR_peek_error() == 0) {
+        ngx_log_error(NGX_LOG_INFO, c->log, err,
+                      "peer closed connection in SSL handshake");
+
+        return NGX_ERROR;
+    }
+
+    c->read->error = 1;
+
+    ngx_ssl_connection_error(c, sslerr, err, "SSL_do_handshake() failed");
+
+    return NGX_ERROR;
+}
+
+
+static void
+ngx_ssl_handshake_handler(ngx_event_t *ev)
+{
+    ngx_connection_t  *c;
+
+    c = ev->data;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "SSL handshake handler: %d", ev->write);
+
+    if (ev->timedout) {
+        c->ssl->handler(c);
+        return;
+    }
+
+    if (ngx_ssl_handshake(c) == NGX_AGAIN) {
+        return;
+    }
+
+    c->ssl->handler(c);
+}
+
+
+ssize_t
+ngx_ssl_recv_chain(ngx_connection_t *c, ngx_chain_t *cl)
+{
+    u_char     *last;
+    ssize_t     n, bytes;
+    ngx_buf_t  *b;
+
+    bytes = 0;
+
+    b = cl->buf;
+    last = b->last;
+
+    for ( ;; ) {
+
+        n = ngx_ssl_recv(c, last, b->end - last);
+
+        if (n > 0) {
+            last += n;
+            bytes += n;
+
+            if (last == b->end) {
+                cl = cl->next;
+
+                if (cl == NULL) {
+                    return bytes;
+                }
+
+                b = cl->buf;
+                last = b->last;
+            }
+
+            continue;
+        }
+
+        if (bytes) {
+
+            if (n == 0 || n == NGX_ERROR) {
+                c->read->ready = 1;
+            }
+
+            return bytes;
+        }
+
+        return n;
+    }
+}
+
+
+ssize_t
+ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size)
+{
+    int  n, bytes;
+
+    if (c->ssl->last == NGX_ERROR) {
+        c->read->error = 1;
+        return NGX_ERROR;
+    }
+
+    if (c->ssl->last == NGX_DONE) {
+        c->read->ready = 0;
+        c->read->eof = 1;
+        return 0;
+    }
+
+    bytes = 0;
+
+    ngx_ssl_clear_error(c->log);
+
+    /*
+     * SSL_read() may return data in parts, so try to read
+     * until SSL_read() would return no data
+     */
+
+    for ( ;; ) {
+
+        n = SSL_read(c->ssl->connection, buf, size);
+
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_read: %d", n);
+
+        if (n > 0) {
+            bytes += n;
+        }
+
+        c->ssl->last = ngx_ssl_handle_recv(c, n);
+
+        if (c->ssl->last == NGX_OK) {
+
+            size -= n;
+
+            if (size == 0) {
+                c->read->ready = 1;
+                return bytes;
+            }
+
+            buf += n;
+
+            continue;
+        }
+
+        if (bytes) {
+            if (c->ssl->last != NGX_AGAIN) {
+                c->read->ready = 1;
+            }
+
+            return bytes;
+        }
+
+        switch (c->ssl->last) {
+
+        case NGX_DONE:
+            c->read->ready = 0;
+            c->read->eof = 1;
+            return 0;
+
+        case NGX_ERROR:
+            c->read->error = 1;
+
+            /* fall through */
+
+        case NGX_AGAIN:
+            return c->ssl->last;
+        }
+    }
+}
+
+
+static ngx_int_t
+ngx_ssl_handle_recv(ngx_connection_t *c, int n)
+{
+    int        sslerr;
+    ngx_err_t  err;
+
+    if (c->ssl->renegotiation) {
+        /*
+         * disable renegotiation (CVE-2009-3555):
+         * OpenSSL (at least up to 0.9.8l) does not handle disabled
+         * renegotiation gracefully, so drop connection here
+         */
+
+        ngx_log_error(NGX_LOG_NOTICE, c->log, 0, "SSL renegotiation disabled");
+
+        while (ERR_peek_error()) {
+            ngx_ssl_error(NGX_LOG_DEBUG, c->log, 0,
+                          "ignoring stale global SSL error");
+        }
+
+        ERR_clear_error();
+
+        c->ssl->no_wait_shutdown = 1;
+        c->ssl->no_send_shutdown = 1;
+
+        return NGX_ERROR;
+    }
+
+    if (n > 0) {
+
+        if (c->ssl->saved_write_handler) {
+
+            c->write->handler = c->ssl->saved_write_handler;
+            c->ssl->saved_write_handler = NULL;
+            c->write->ready = 1;
+
+            if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+                return NGX_ERROR;
+            }
+
+            ngx_post_event(c->write, &ngx_posted_events);
+        }
+
+        return NGX_OK;
+    }
+
+    sslerr = SSL_get_error(c->ssl->connection, n);
+
+    err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_get_error: %d", sslerr);
+
+    if (sslerr == SSL_ERROR_WANT_READ) {
+        c->read->ready = 0;
+        return NGX_AGAIN;
+    }
+
+    if (sslerr == SSL_ERROR_WANT_WRITE) {
+
+        ngx_log_error(NGX_LOG_INFO, c->log, 0,
+                      "peer started SSL renegotiation");
+
+        c->write->ready = 0;
+
+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        /*
+         * we do not set the timer because there is already the read event timer
+         */
+
+        if (c->ssl->saved_write_handler == NULL) {
+            c->ssl->saved_write_handler = c->write->handler;
+            c->write->handler = ngx_ssl_write_handler;
+        }
+
+        return NGX_AGAIN;
+    }
+
+    c->ssl->no_wait_shutdown = 1;
+    c->ssl->no_send_shutdown = 1;
+
+    if (sslerr == SSL_ERROR_ZERO_RETURN || ERR_peek_error() == 0) {
+        ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                       "peer shutdown SSL cleanly");
+        return NGX_DONE;
+    }
+
+    ngx_ssl_connection_error(c, sslerr, err, "SSL_read() failed");
+
+    return NGX_ERROR;
+}
+
+
+static void
+ngx_ssl_write_handler(ngx_event_t *wev)
+{
+    ngx_connection_t  *c;
+
+    c = wev->data;
+
+    c->read->handler(c->read);
+}
+
+
+/*
+ * OpenSSL has no SSL_writev() so we copy several bufs into our 16K buffer
+ * before the SSL_write() call to decrease a SSL overhead.
+ *
+ * Besides for protocols such as HTTP it is possible to always buffer
+ * the output to decrease a SSL overhead some more.
+ */
+
+ngx_chain_t *
+ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in, off_t limit)
+{
+    int          n;
+    ngx_uint_t   flush;
+    ssize_t      send, size;
+    ngx_buf_t   *buf;
+
+    if (!c->ssl->buffer) {
+
+        while (in) {
+            if (ngx_buf_special(in->buf)) {
+                in = in->next;
+                continue;
+            }
+
+            n = ngx_ssl_write(c, in->buf->pos, in->buf->last - in->buf->pos);
+
+            if (n == NGX_ERROR) {
+                return NGX_CHAIN_ERROR;
+            }
+
+            if (n == NGX_AGAIN) {
+                return in;
+            }
+
+            in->buf->pos += n;
+            c->sent += n;
+
+            if (in->buf->pos == in->buf->last) {
+                in = in->next;
+            }
+        }
+
+        return in;
+    }
+
+
+    /* the maximum limit size is the maximum int32_t value - the page size */
+
+    if (limit == 0 || limit > (off_t) (NGX_MAX_INT32_VALUE - ngx_pagesize)) {
+        limit = NGX_MAX_INT32_VALUE - ngx_pagesize;
+    }
+
+    buf = c->ssl->buf;
+
+    if (buf == NULL) {
+        buf = ngx_create_temp_buf(c->pool, c->ssl->buffer_size);
+        if (buf == NULL) {
+            return NGX_CHAIN_ERROR;
+        }
+
+        c->ssl->buf = buf;
+    }
+
+    if (buf->start == NULL) {
+        buf->start = ngx_palloc(c->pool, c->ssl->buffer_size);
+        if (buf->start == NULL) {
+            return NGX_CHAIN_ERROR;
+        }
+
+        buf->pos = buf->start;
+        buf->last = buf->start;
+        buf->end = buf->start + c->ssl->buffer_size;
+    }
+
+    send = buf->last - buf->pos;
+    flush = (in == NULL) ? 1 : buf->flush;
+
+    for ( ;; ) {
+
+        while (in && buf->last < buf->end && send < limit) {
+            if (in->buf->last_buf || in->buf->flush) {
+                flush = 1;
+            }
+
+            if (ngx_buf_special(in->buf)) {
+                in = in->next;
+                continue;
+            }
+
+            size = in->buf->last - in->buf->pos;
+
+            if (size > buf->end - buf->last) {
+                size = buf->end - buf->last;
+            }
+
+            if (send + size > limit) {
+                size = (ssize_t) (limit - send);
+            }
+
+            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                           "SSL buf copy: %d", size);
+
+            ngx_memcpy(buf->last, in->buf->pos, size);
+
+            buf->last += size;
+            in->buf->pos += size;
+            send += size;
+
+            if (in->buf->pos == in->buf->last) {
+                in = in->next;
+            }
+        }
+
+        if (!flush && send < limit && buf->last < buf->end) {
+            break;
+        }
+
+        size = buf->last - buf->pos;
+
+        if (size == 0) {
+            buf->flush = 0;
+            c->buffered &= ~NGX_SSL_BUFFERED;
+            return in;
+        }
+
+        n = ngx_ssl_write(c, buf->pos, size);
+
+        if (n == NGX_ERROR) {
+            return NGX_CHAIN_ERROR;
+        }
+
+        if (n == NGX_AGAIN) {
+            break;
+        }
+
+        buf->pos += n;
+        c->sent += n;
+
+        if (n < size) {
+            break;
+        }
+
+        flush = 0;
+
+        buf->pos = buf->start;
+        buf->last = buf->start;
+
+        if (in == NULL || send == limit) {
+            break;
+        }
+    }
+
+    buf->flush = flush;
+
+    if (buf->pos < buf->last) {
+        c->buffered |= NGX_SSL_BUFFERED;
+
+    } else {
+        c->buffered &= ~NGX_SSL_BUFFERED;
+    }
+
+    return in;
+}
+
+
+ssize_t
+ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size)
+{
+    int        n, sslerr;
+    ngx_err_t  err;
+
+    ngx_ssl_clear_error(c->log);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL to write: %d", size);
+
+    n = SSL_write(c->ssl->connection, data, size);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_write: %d", n);
+
+    if (n > 0) {
+
+        if (c->ssl->saved_read_handler) {
+
+            c->read->handler = c->ssl->saved_read_handler;
+            c->ssl->saved_read_handler = NULL;
+            c->read->ready = 1;
+
+            if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+                return NGX_ERROR;
+            }
+
+            ngx_post_event(c->read, &ngx_posted_events);
+        }
+
+        return n;
+    }
+
+    sslerr = SSL_get_error(c->ssl->connection, n);
+
+    err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;
+
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_get_error: %d", sslerr);
+
+    if (sslerr == SSL_ERROR_WANT_WRITE) {
+        c->write->ready = 0;
+        return NGX_AGAIN;
+    }
+
+    if (sslerr == SSL_ERROR_WANT_READ) {
+
+        ngx_log_error(NGX_LOG_INFO, c->log, 0,
+                      "peer started SSL renegotiation");
+
+        c->read->ready = 0;
+
+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        /*
+         * we do not set the timer because there is already
+         * the write event timer
+         */
+
+        if (c->ssl->saved_read_handler == NULL) {
+            c->ssl->saved_read_handler = c->read->handler;
+            c->read->handler = ngx_ssl_read_handler;
+        }
+
+        return NGX_AGAIN;
+    }
+
+    c->ssl->no_wait_shutdown = 1;
+    c->ssl->no_send_shutdown = 1;
+    c->write->error = 1;
+
+    ngx_ssl_connection_error(c, sslerr, err, "SSL_write() failed");
+
+    return NGX_ERROR;
+}
+
+
+static void
+ngx_ssl_read_handler(ngx_event_t *rev)
+{
+    ngx_connection_t  *c;
+
+    c = rev->data;
+
+    c->write->handler(c->write);
+}
+
+
+void
+ngx_ssl_free_buffer(ngx_connection_t *c)
+{
+    if (c->ssl->buf && c->ssl->buf->start) {
+        if (ngx_pfree(c->pool, c->ssl->buf->start) == NGX_OK) {
+            c->ssl->buf->start = NULL;
+        }
+    }
+}
+
+
+ngx_int_t
+ngx_ssl_shutdown(ngx_connection_t *c)
+{
+    int        n, sslerr, mode;
+    ngx_err_t  err;
+
+    if (c->timedout) {
+        mode = SSL_RECEIVED_SHUTDOWN|SSL_SENT_SHUTDOWN;
+        SSL_set_quiet_shutdown(c->ssl->connection, 1);
+
+    } else {
+        mode = SSL_get_shutdown(c->ssl->connection);
+
+        if (c->ssl->no_wait_shutdown) {
+            mode |= SSL_RECEIVED_SHUTDOWN;
+        }
+
+        if (c->ssl->no_send_shutdown) {
+            mode |= SSL_SENT_SHUTDOWN;
+        }
+
+        if (c->ssl->no_wait_shutdown && c->ssl->no_send_shutdown) {
+            SSL_set_quiet_shutdown(c->ssl->connection, 1);
+        }
+    }
+
+    SSL_set_shutdown(c->ssl->connection, mode);
+
+    ngx_ssl_clear_error(c->log);
+
+    n = SSL_shutdown(c->ssl->connection);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0, "SSL_shutdown: %d", n);
+
+    sslerr = 0;
+
+    /* SSL_shutdown() never returns -1, on error it returns 0 */
+
+    if (n != 1 && ERR_peek_error()) {
+        sslerr = SSL_get_error(c->ssl->connection, n);
+
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                       "SSL_get_error: %d", sslerr);
+    }
+
+    if (n == 1 || sslerr == 0 || sslerr == SSL_ERROR_ZERO_RETURN) {
+        SSL_free(c->ssl->connection);
+        c->ssl = NULL;
+
+        return NGX_OK;
+    }
+
+    if (sslerr == SSL_ERROR_WANT_READ || sslerr == SSL_ERROR_WANT_WRITE) {
+        c->read->handler = ngx_ssl_shutdown_handler;
+        c->write->handler = ngx_ssl_shutdown_handler;
+
+        if (ngx_handle_read_event(c->read, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        if (ngx_handle_write_event(c->write, 0) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        if (sslerr == SSL_ERROR_WANT_READ) {
+            ngx_add_timer(c->read, 30000);
+        }
+
+        return NGX_AGAIN;
+    }
+
+    err = (sslerr == SSL_ERROR_SYSCALL) ? ngx_errno : 0;
+
+    ngx_ssl_connection_error(c, sslerr, err, "SSL_shutdown() failed");
+
+    SSL_free(c->ssl->connection);
+    c->ssl = NULL;
+
+    return NGX_ERROR;
+}
+
+
+static void
+ngx_ssl_shutdown_handler(ngx_event_t *ev)
+{
+    ngx_connection_t           *c;
+    ngx_connection_handler_pt   handler;
+
+    c = ev->data;
+    handler = c->ssl->handler;
+
+    if (ev->timedout) {
+        c->timedout = 1;
+    }
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ev->log, 0, "SSL shutdown handler");
+
+    if (ngx_ssl_shutdown(c) == NGX_AGAIN) {
+        return;
+    }
+
+    handler(c);
+}
+
+
+static void
+ngx_ssl_connection_error(ngx_connection_t *c, int sslerr, ngx_err_t err,
+    char *text)
+{
+    int         n;
+    ngx_uint_t  level;
+
+    level = NGX_LOG_CRIT;
+
+    if (sslerr == SSL_ERROR_SYSCALL) {
+
+        if (err == NGX_ECONNRESET
+            || err == NGX_EPIPE
+            || err == NGX_ENOTCONN
+            || err == NGX_ETIMEDOUT
+            || err == NGX_ECONNREFUSED
+            || err == NGX_ENETDOWN
+            || err == NGX_ENETUNREACH
+            || err == NGX_EHOSTDOWN
+            || err == NGX_EHOSTUNREACH)
+        {
+            switch (c->log_error) {
+
+            case NGX_ERROR_IGNORE_ECONNRESET:
+            case NGX_ERROR_INFO:
+                level = NGX_LOG_INFO;
+                break;
+
+            case NGX_ERROR_ERR:
+                level = NGX_LOG_ERR;
+                break;
+
+            default:
+                break;
+            }
+        }
+
+    } else if (sslerr == SSL_ERROR_SSL) {
+
+        n = ERR_GET_REASON(ERR_peek_error());
+
+            /* handshake failures */
+        if (n == SSL_R_BAD_CHANGE_CIPHER_SPEC                        /*  103 */
+            || n == SSL_R_BLOCK_CIPHER_PAD_IS_WRONG                  /*  129 */
+            || n == SSL_R_DIGEST_CHECK_FAILED                        /*  149 */
+            || n == SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST              /*  151 */
+            || n == SSL_R_EXCESSIVE_MESSAGE_SIZE                     /*  152 */
+            || n == SSL_R_LENGTH_MISMATCH                            /*  159 */
+            || n == SSL_R_NO_CIPHERS_PASSED                          /*  182 */
+            || n == SSL_R_NO_CIPHERS_SPECIFIED                       /*  183 */
+            || n == SSL_R_NO_COMPRESSION_SPECIFIED                   /*  187 */
+            || n == SSL_R_NO_SHARED_CIPHER                           /*  193 */
+            || n == SSL_R_RECORD_LENGTH_MISMATCH                     /*  213 */
+#ifdef SSL_R_PARSE_TLSEXT
+            || n == SSL_R_PARSE_TLSEXT                               /*  227 */
+#endif
+            || n == SSL_R_UNEXPECTED_MESSAGE                         /*  244 */
+            || n == SSL_R_UNEXPECTED_RECORD                          /*  245 */
+            || n == SSL_R_UNKNOWN_ALERT_TYPE                         /*  246 */
+            || n == SSL_R_UNKNOWN_PROTOCOL                           /*  252 */
+            || n == SSL_R_WRONG_VERSION_NUMBER                       /*  267 */
+            || n == SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC        /*  281 */
+#ifdef SSL_R_RENEGOTIATE_EXT_TOO_LONG
+            || n == SSL_R_RENEGOTIATE_EXT_TOO_LONG                   /*  335 */
+            || n == SSL_R_RENEGOTIATION_ENCODING_ERR                 /*  336 */
+            || n == SSL_R_RENEGOTIATION_MISMATCH                     /*  337 */
+#endif
+#ifdef SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED
+            || n == SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED       /*  338 */
+#endif
+#ifdef SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING
+            || n == SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING           /*  345 */
+#endif
+            || n == 1000 /* SSL_R_SSLV3_ALERT_CLOSE_NOTIFY */
+            || n == SSL_R_SSLV3_ALERT_UNEXPECTED_MESSAGE             /* 1010 */
+            || n == SSL_R_SSLV3_ALERT_BAD_RECORD_MAC                 /* 1020 */
+            || n == SSL_R_TLSV1_ALERT_DECRYPTION_FAILED              /* 1021 */
+            || n == SSL_R_TLSV1_ALERT_RECORD_OVERFLOW                /* 1022 */
+            || n == SSL_R_SSLV3_ALERT_DECOMPRESSION_FAILURE          /* 1030 */
+            || n == SSL_R_SSLV3_ALERT_HANDSHAKE_FAILURE              /* 1040 */
+            || n == SSL_R_SSLV3_ALERT_NO_CERTIFICATE                 /* 1041 */
+            || n == SSL_R_SSLV3_ALERT_BAD_CERTIFICATE                /* 1042 */
+            || n == SSL_R_SSLV3_ALERT_UNSUPPORTED_CERTIFICATE        /* 1043 */
+            || n == SSL_R_SSLV3_ALERT_CERTIFICATE_REVOKED            /* 1044 */
+            || n == SSL_R_SSLV3_ALERT_CERTIFICATE_EXPIRED            /* 1045 */
+            || n == SSL_R_SSLV3_ALERT_CERTIFICATE_UNKNOWN            /* 1046 */
+            || n == SSL_R_SSLV3_ALERT_ILLEGAL_PARAMETER              /* 1047 */
+            || n == SSL_R_TLSV1_ALERT_UNKNOWN_CA                     /* 1048 */
+            || n == SSL_R_TLSV1_ALERT_ACCESS_DENIED                  /* 1049 */
+            || n == SSL_R_TLSV1_ALERT_DECODE_ERROR                   /* 1050 */
+            || n == SSL_R_TLSV1_ALERT_DECRYPT_ERROR                  /* 1051 */
+            || n == SSL_R_TLSV1_ALERT_EXPORT_RESTRICTION             /* 1060 */
+            || n == SSL_R_TLSV1_ALERT_PROTOCOL_VERSION               /* 1070 */
+            || n == SSL_R_TLSV1_ALERT_INSUFFICIENT_SECURITY          /* 1071 */
+            || n == SSL_R_TLSV1_ALERT_INTERNAL_ERROR                 /* 1080 */
+            || n == SSL_R_TLSV1_ALERT_USER_CANCELLED                 /* 1090 */
+            || n == SSL_R_TLSV1_ALERT_NO_RENEGOTIATION)              /* 1100 */
+        {
+            switch (c->log_error) {
+
+            case NGX_ERROR_IGNORE_ECONNRESET:
+            case NGX_ERROR_INFO:
+                level = NGX_LOG_INFO;
+                break;
+
+            case NGX_ERROR_ERR:
+                level = NGX_LOG_ERR;
+                break;
+
+            default:
+                break;
+            }
+        }
+    }
+
+    ngx_ssl_error(level, c->log, err, text);
+}
+
+
+static void
+ngx_ssl_clear_error(ngx_log_t *log)
+{
+    while (ERR_peek_error()) {
+        ngx_ssl_error(NGX_LOG_ALERT, log, 0, "ignoring stale global SSL error");
+    }
+
+    ERR_clear_error();
+}
+
+
+void ngx_cdecl
+ngx_ssl_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, char *fmt, ...)
+{
+    int          flags;
+    u_long       n;
+    va_list      args;
+    u_char      *p, *last;
+    u_char       errstr[NGX_MAX_CONF_ERRSTR];
+    const char  *data;
+
+    last = errstr + NGX_MAX_CONF_ERRSTR;
+
+    va_start(args, fmt);
+    p = ngx_vslprintf(errstr, last - 1, fmt, args);
+    va_end(args);
+
+    p = ngx_cpystrn(p, (u_char *) " (SSL:", last - p);
+
+    for ( ;; ) {
+
+        n = ERR_peek_error_line_data(NULL, NULL, &data, &flags);
+
+        if (n == 0) {
+            break;
+        }
+
+        if (p >= last) {
+            goto next;
+        }
+
+        *p++ = ' ';
+
+        ERR_error_string_n(n, (char *) p, last - p);
+
+        while (p < last && *p) {
+            p++;
+        }
+
+        if (p < last && *data && (flags & ERR_TXT_STRING)) {
+            *p++ = ':';
+            p = ngx_cpystrn(p, (u_char *) data, last - p);
+        }
+
+    next:
+
+        (void) ERR_get_error();
+    }
+
+    ngx_log_error(level, log, err, "%s)", errstr);
+}
+
+
+ngx_int_t
+ngx_ssl_session_cache(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,
+    ssize_t builtin_session_cache, ngx_shm_zone_t *shm_zone, time_t timeout)
+{
+    long  cache_mode;
+
+    SSL_CTX_set_timeout(ssl->ctx, (long) timeout);
+
+    if (builtin_session_cache == NGX_SSL_NO_SCACHE) {
+        SSL_CTX_set_session_cache_mode(ssl->ctx, SSL_SESS_CACHE_OFF);
+        return NGX_OK;
+    }
+
+    SSL_CTX_set_session_id_context(ssl->ctx, sess_ctx->data, sess_ctx->len);
+
+    if (builtin_session_cache == NGX_SSL_NONE_SCACHE) {
+
+        /*
+         * If the server explicitly says that it does not support
+         * session reuse (see SSL_SESS_CACHE_OFF above), then
+         * Outlook Express fails to upload a sent email to
+         * the Sent Items folder on the IMAP server via a separate IMAP
+         * connection in the background. Therefore we have a special
+         * mode (SSL_SESS_CACHE_SERVER|SSL_SESS_CACHE_NO_INTERNAL_STORE)
+         * where the server pretends that it supports session reuse,
+         * but it does not actually store any session.
+         */
+
+        SSL_CTX_set_session_cache_mode(ssl->ctx,
+                                       SSL_SESS_CACHE_SERVER
+                                       |SSL_SESS_CACHE_NO_AUTO_CLEAR
+                                       |SSL_SESS_CACHE_NO_INTERNAL_STORE);
+
+        SSL_CTX_sess_set_cache_size(ssl->ctx, 1);
+
+        return NGX_OK;
+    }
+
+    cache_mode = SSL_SESS_CACHE_SERVER;
+
+    if (shm_zone && builtin_session_cache == NGX_SSL_NO_BUILTIN_SCACHE) {
+        cache_mode |= SSL_SESS_CACHE_NO_INTERNAL;
+    }
+
+    SSL_CTX_set_session_cache_mode(ssl->ctx, cache_mode);
+
+    if (builtin_session_cache != NGX_SSL_NO_BUILTIN_SCACHE) {
+
+        if (builtin_session_cache != NGX_SSL_DFLT_BUILTIN_SCACHE) {
+            SSL_CTX_sess_set_cache_size(ssl->ctx, builtin_session_cache);
+        }
+    }
+
+    if (shm_zone) {
+        SSL_CTX_sess_set_new_cb(ssl->ctx, ngx_ssl_new_session);
+        SSL_CTX_sess_set_get_cb(ssl->ctx, ngx_ssl_get_cached_session);
+        SSL_CTX_sess_set_remove_cb(ssl->ctx, ngx_ssl_remove_session);
+
+        if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_session_cache_index, shm_zone)
+            == 0)
+        {
+            ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                          "SSL_CTX_set_ex_data() failed");
+            return NGX_ERROR;
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data)
+{
+    size_t                    len;
+    ngx_slab_pool_t          *shpool;
+    ngx_ssl_session_cache_t  *cache;
+
+    if (data) {
+        shm_zone->data = data;
+        return NGX_OK;
+    }
+
+    if (shm_zone->shm.exists) {
+        shm_zone->data = data;
+        return NGX_OK;
+    }
+
+    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;
+
+    cache = ngx_slab_alloc(shpool, sizeof(ngx_ssl_session_cache_t));
+    if (cache == NULL) {
+        return NGX_ERROR;
+    }
+
+    shpool->data = cache;
+    shm_zone->data = cache;
+
+    ngx_rbtree_init(&cache->session_rbtree, &cache->sentinel,
+                    ngx_ssl_session_rbtree_insert_value);
+
+    ngx_queue_init(&cache->expire_queue);
+
+    len = sizeof(" in SSL session shared cache \"\"") + shm_zone->shm.name.len;
+
+    shpool->log_ctx = ngx_slab_alloc(shpool, len);
+    if (shpool->log_ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_sprintf(shpool->log_ctx, " in SSL session shared cache \"%V\"%Z",
+                &shm_zone->shm.name);
+
+    return NGX_OK;
+}
+
+
+/*
+ * The length of the session id is 16 bytes for SSLv2 sessions and
+ * between 1 and 32 bytes for SSLv3/TLSv1, typically 32 bytes.
+ * It seems that the typical length of the external ASN1 representation
+ * of a session is 118 or 119 bytes for SSLv3/TSLv1.
+ *
+ * Thus on 32-bit platforms we allocate separately an rbtree node,
+ * a session id, and an ASN1 representation, they take accordingly
+ * 64, 32, and 128 bytes.
+ *
+ * On 64-bit platforms we allocate separately an rbtree node + session_id,
+ * and an ASN1 representation, they take accordingly 128 and 128 bytes.
+ *
+ * OpenSSL's i2d_SSL_SESSION() and d2i_SSL_SESSION are slow,
+ * so they are outside the code locked by shared pool mutex
+ */
+
+static int
+ngx_ssl_new_session(ngx_ssl_conn_t *ssl_conn, ngx_ssl_session_t *sess)
+{
+    int                       len;
+    u_char                   *p, *id, *cached_sess;
+    uint32_t                  hash;
+    SSL_CTX                  *ssl_ctx;
+    ngx_shm_zone_t           *shm_zone;
+    ngx_connection_t         *c;
+    ngx_slab_pool_t          *shpool;
+    ngx_ssl_sess_id_t        *sess_id;
+    ngx_ssl_session_cache_t  *cache;
+    u_char                    buf[NGX_SSL_MAX_SESSION_SIZE];
+
+    len = i2d_SSL_SESSION(sess, NULL);
+
+    /* do not cache too big session */
+
+    if (len > (int) NGX_SSL_MAX_SESSION_SIZE) {
+        return 0;
+    }
+
+    p = buf;
+    i2d_SSL_SESSION(sess, &p);
+
+    c = ngx_ssl_get_connection(ssl_conn);
+
+    ssl_ctx = SSL_get_SSL_CTX(ssl_conn);
+    shm_zone = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_session_cache_index);
+
+    cache = shm_zone->data;
+    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;
+
+    ngx_shmtx_lock(&shpool->mutex);
+
+    /* drop one or two expired sessions */
+    ngx_ssl_expire_sessions(cache, shpool, 1);
+
+    cached_sess = ngx_slab_alloc_locked(shpool, len);
+
+    if (cached_sess == NULL) {
+
+        /* drop the oldest non-expired session and try once more */
+
+        ngx_ssl_expire_sessions(cache, shpool, 0);
+
+        cached_sess = ngx_slab_alloc_locked(shpool, len);
+
+        if (cached_sess == NULL) {
+            sess_id = NULL;
+            goto failed;
+        }
+    }
+
+    sess_id = ngx_slab_alloc_locked(shpool, sizeof(ngx_ssl_sess_id_t));
+
+    if (sess_id == NULL) {
+
+        /* drop the oldest non-expired session and try once more */
+
+        ngx_ssl_expire_sessions(cache, shpool, 0);
+
+        sess_id = ngx_slab_alloc_locked(shpool, sizeof(ngx_ssl_sess_id_t));
+
+        if (sess_id == NULL) {
+            goto failed;
+        }
+    }
+
+#if (NGX_PTR_SIZE == 8)
+
+    id = sess_id->sess_id;
+
+#else
+
+    id = ngx_slab_alloc_locked(shpool, sess->session_id_length);
+
+    if (id == NULL) {
+
+        /* drop the oldest non-expired session and try once more */
+
+        ngx_ssl_expire_sessions(cache, shpool, 0);
+
+        id = ngx_slab_alloc_locked(shpool, sess->session_id_length);
+
+        if (id == NULL) {
+            goto failed;
+        }
+    }
+
+#endif
+
+    ngx_memcpy(cached_sess, buf, len);
+
+    ngx_memcpy(id, sess->session_id, sess->session_id_length);
+
+    hash = ngx_crc32_short(sess->session_id, sess->session_id_length);
+
+    ngx_log_debug3(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "ssl new session: %08XD:%d:%d",
+                   hash, sess->session_id_length, len);
+
+    sess_id->node.key = hash;
+    sess_id->node.data = (u_char) sess->session_id_length;
+    sess_id->id = id;
+    sess_id->len = len;
+    sess_id->session = cached_sess;
+
+    sess_id->expire = ngx_time() + SSL_CTX_get_timeout(ssl_ctx);
+
+    ngx_queue_insert_head(&cache->expire_queue, &sess_id->queue);
+
+    ngx_rbtree_insert(&cache->session_rbtree, &sess_id->node);
+
+    ngx_shmtx_unlock(&shpool->mutex);
+
+    return 0;
+
+failed:
+
+    if (cached_sess) {
+        ngx_slab_free_locked(shpool, cached_sess);
+    }
+
+    if (sess_id) {
+        ngx_slab_free_locked(shpool, sess_id);
+    }
+
+    ngx_shmtx_unlock(&shpool->mutex);
+
+    ngx_log_error(NGX_LOG_ALERT, c->log, 0,
+                  "could not add new SSL session to the session cache");
+
+    return 0;
+}
+
+
+static ngx_ssl_session_t *
+ngx_ssl_get_cached_session(ngx_ssl_conn_t *ssl_conn, u_char *id, int len,
+    int *copy)
+{
+#if OPENSSL_VERSION_NUMBER >= 0x0090707fL
+    const
+#endif
+    u_char                   *p;
+    uint32_t                  hash;
+    ngx_int_t                 rc;
+    ngx_shm_zone_t           *shm_zone;
+    ngx_slab_pool_t          *shpool;
+    ngx_rbtree_node_t        *node, *sentinel;
+    ngx_ssl_session_t        *sess;
+    ngx_ssl_sess_id_t        *sess_id;
+    ngx_ssl_session_cache_t  *cache;
+    u_char                    buf[NGX_SSL_MAX_SESSION_SIZE];
+#if (NGX_DEBUG)
+    ngx_connection_t         *c;
+#endif
+
+    hash = ngx_crc32_short(id, (size_t) len);
+    *copy = 0;
+
+#if (NGX_DEBUG)
+    c = ngx_ssl_get_connection(ssl_conn);
+
+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "ssl get session: %08XD:%d", hash, len);
+#endif
+
+    shm_zone = SSL_CTX_get_ex_data(SSL_get_SSL_CTX(ssl_conn),
+                                   ngx_ssl_session_cache_index);
+
+    cache = shm_zone->data;
+
+    sess = NULL;
+
+    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;
+
+    ngx_shmtx_lock(&shpool->mutex);
+
+    node = cache->session_rbtree.root;
+    sentinel = cache->session_rbtree.sentinel;
+
+    while (node != sentinel) {
+
+        if (hash < node->key) {
+            node = node->left;
+            continue;
+        }
+
+        if (hash > node->key) {
+            node = node->right;
+            continue;
+        }
+
+        /* hash == node->key */
+
+        sess_id = (ngx_ssl_sess_id_t *) node;
+
+        rc = ngx_memn2cmp(id, sess_id->id, (size_t) len, (size_t) node->data);
+
+        if (rc == 0) {
+
+            if (sess_id->expire > ngx_time()) {
+                ngx_memcpy(buf, sess_id->session, sess_id->len);
+
+                ngx_shmtx_unlock(&shpool->mutex);
+
+                p = buf;
+                sess = d2i_SSL_SESSION(NULL, &p, sess_id->len);
+
+                return sess;
+            }
+
+            ngx_queue_remove(&sess_id->queue);
+
+            ngx_rbtree_delete(&cache->session_rbtree, node);
+
+            ngx_slab_free_locked(shpool, sess_id->session);
+#if (NGX_PTR_SIZE == 4)
+            ngx_slab_free_locked(shpool, sess_id->id);
+#endif
+            ngx_slab_free_locked(shpool, sess_id);
+
+            sess = NULL;
+
+            goto done;
+        }
+
+        node = (rc < 0) ? node->left : node->right;
+    }
+
+done:
+
+    ngx_shmtx_unlock(&shpool->mutex);
+
+    return sess;
+}
+
+
+void
+ngx_ssl_remove_cached_session(SSL_CTX *ssl, ngx_ssl_session_t *sess)
+{
+     SSL_CTX_remove_session(ssl, sess);
+
+     ngx_ssl_remove_session(ssl, sess);
+}
+
+
+static void
+ngx_ssl_remove_session(SSL_CTX *ssl, ngx_ssl_session_t *sess)
+{
+    size_t                    len;
+    u_char                   *id;
+    uint32_t                  hash;
+    ngx_int_t                 rc;
+    ngx_shm_zone_t           *shm_zone;
+    ngx_slab_pool_t          *shpool;
+    ngx_rbtree_node_t        *node, *sentinel;
+    ngx_ssl_sess_id_t        *sess_id;
+    ngx_ssl_session_cache_t  *cache;
+
+    shm_zone = SSL_CTX_get_ex_data(ssl, ngx_ssl_session_cache_index);
+
+    if (shm_zone == NULL) {
+        return;
+    }
+
+    cache = shm_zone->data;
+
+    id = sess->session_id;
+    len = (size_t) sess->session_id_length;
+
+    hash = ngx_crc32_short(id, len);
+
+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ngx_cycle->log, 0,
+                   "ssl remove session: %08XD:%uz", hash, len);
+
+    shpool = (ngx_slab_pool_t *) shm_zone->shm.addr;
+
+    ngx_shmtx_lock(&shpool->mutex);
+
+    node = cache->session_rbtree.root;
+    sentinel = cache->session_rbtree.sentinel;
+
+    while (node != sentinel) {
+
+        if (hash < node->key) {
+            node = node->left;
+            continue;
+        }
+
+        if (hash > node->key) {
+            node = node->right;
+            continue;
+        }
+
+        /* hash == node->key */
+
+        sess_id = (ngx_ssl_sess_id_t *) node;
+
+        rc = ngx_memn2cmp(id, sess_id->id, len, (size_t) node->data);
+
+        if (rc == 0) {
+
+            ngx_queue_remove(&sess_id->queue);
+
+            ngx_rbtree_delete(&cache->session_rbtree, node);
+
+            ngx_slab_free_locked(shpool, sess_id->session);
+#if (NGX_PTR_SIZE == 4)
+            ngx_slab_free_locked(shpool, sess_id->id);
+#endif
+            ngx_slab_free_locked(shpool, sess_id);
+
+            goto done;
+        }
+
+        node = (rc < 0) ? node->left : node->right;
+    }
+
+done:
+
+    ngx_shmtx_unlock(&shpool->mutex);
+}
+
+
+static void
+ngx_ssl_expire_sessions(ngx_ssl_session_cache_t *cache,
+    ngx_slab_pool_t *shpool, ngx_uint_t n)
+{
+    time_t              now;
+    ngx_queue_t        *q;
+    ngx_ssl_sess_id_t  *sess_id;
+
+    now = ngx_time();
+
+    while (n < 3) {
+
+        if (ngx_queue_empty(&cache->expire_queue)) {
+            return;
+        }
+
+        q = ngx_queue_last(&cache->expire_queue);
+
+        sess_id = ngx_queue_data(q, ngx_ssl_sess_id_t, queue);
+
+        if (n++ != 0 && sess_id->expire > now) {
+            return;
+        }
+
+        ngx_queue_remove(q);
+
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ngx_cycle->log, 0,
+                       "expire session: %08Xi", sess_id->node.key);
+
+        ngx_rbtree_delete(&cache->session_rbtree, &sess_id->node);
+
+        ngx_slab_free_locked(shpool, sess_id->session);
+#if (NGX_PTR_SIZE == 4)
+        ngx_slab_free_locked(shpool, sess_id->id);
+#endif
+        ngx_slab_free_locked(shpool, sess_id);
+    }
+}
+
+
+static void
+ngx_ssl_session_rbtree_insert_value(ngx_rbtree_node_t *temp,
+    ngx_rbtree_node_t *node, ngx_rbtree_node_t *sentinel)
+{
+    ngx_rbtree_node_t  **p;
+    ngx_ssl_sess_id_t   *sess_id, *sess_id_temp;
+
+    for ( ;; ) {
+
+        if (node->key < temp->key) {
+
+            p = &temp->left;
+
+        } else if (node->key > temp->key) {
+
+            p = &temp->right;
+
+        } else { /* node->key == temp->key */
+
+            sess_id = (ngx_ssl_sess_id_t *) node;
+            sess_id_temp = (ngx_ssl_sess_id_t *) temp;
+
+            p = (ngx_memn2cmp(sess_id->id, sess_id_temp->id,
+                              (size_t) node->data, (size_t) temp->data)
+                 < 0) ? &temp->left : &temp->right;
+        }
+
+        if (*p == sentinel) {
+            break;
+        }
+
+        temp = *p;
+    }
+
+    *p = node;
+    node->parent = temp;
+    node->left = sentinel;
+    node->right = sentinel;
+    ngx_rbt_red(node);
+}
+
+
+#ifdef SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB
+
+ngx_int_t
+ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)
+{
+    u_char                         buf[48];
+    ssize_t                        n;
+    ngx_str_t                     *path;
+    ngx_file_t                     file;
+    ngx_uint_t                     i;
+    ngx_array_t                   *keys;
+    ngx_file_info_t                fi;
+    ngx_ssl_session_ticket_key_t  *key;
+
+    if (paths == NULL) {
+        return NGX_OK;
+    }
+
+    keys = ngx_array_create(cf->pool, paths->nelts,
+                            sizeof(ngx_ssl_session_ticket_key_t));
+    if (keys == NULL) {
+        return NGX_ERROR;
+    }
+
+    path = paths->elts;
+    for (i = 0; i < paths->nelts; i++) {
+
+        if (ngx_conf_full_name(cf->cycle, &path[i], 1) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        ngx_memzero(&file, sizeof(ngx_file_t));
+        file.name = path[i];
+        file.log = cf->log;
+
+        file.fd = ngx_open_file(file.name.data, NGX_FILE_RDONLY, 0, 0);
+        if (file.fd == NGX_INVALID_FILE) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,
+                               ngx_open_file_n " \"%V\" failed", &file.name);
+            return NGX_ERROR;
+        }
+
+        if (ngx_fd_info(file.fd, &fi) == NGX_FILE_ERROR) {
+            ngx_conf_log_error(NGX_LOG_CRIT, cf, ngx_errno,
+                               ngx_fd_info_n " \"%V\" failed", &file.name);
+            goto failed;
+        }
+
+        if (ngx_file_size(&fi) != 48) {
+            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                               "\"%V\" must be 48 bytes", &file.name);
+            goto failed;
+        }
+
+        n = ngx_read_file(&file, buf, 48, 0);
+
+        if (n == NGX_ERROR) {
+            ngx_conf_log_error(NGX_LOG_CRIT, cf, ngx_errno,
+                               ngx_read_file_n " \"%V\" failed", &file.name);
+            goto failed;
+        }
+
+        if (n != 48) {
+            ngx_conf_log_error(NGX_LOG_CRIT, cf, 0,
+                               ngx_read_file_n " \"%V\" returned only "
+                               "%z bytes instead of 48", &file.name, n);
+            goto failed;
+        }
+
+        key = ngx_array_push(keys);
+        if (key == NULL) {
+            goto failed;
+        }
+
+        ngx_memcpy(key->name, buf, 16);
+        ngx_memcpy(key->aes_key, buf + 16, 16);
+        ngx_memcpy(key->hmac_key, buf + 32, 16);
+
+        if (ngx_close_file(file.fd) == NGX_FILE_ERROR) {
+            ngx_log_error(NGX_LOG_ALERT, cf->log, ngx_errno,
+                          ngx_close_file_n " \"%V\" failed", &file.name);
+        }
+    }
+
+    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_session_ticket_keys_index, keys)
+        == 0)
+    {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "SSL_CTX_set_ex_data() failed");
+        return NGX_ERROR;
+    }
+
+    if (SSL_CTX_set_tlsext_ticket_key_cb(ssl->ctx,
+                                         ngx_ssl_session_ticket_key_callback)
+        == 0)
+    {
+        ngx_log_error(NGX_LOG_WARN, cf->log, 0,
+                      "nginx was built with Session Tickets support, however, "
+                      "now it is linked dynamically to an OpenSSL library "
+                      "which has no tlsext support, therefore Session Tickets "
+                      "are not available");
+    }
+
+    return NGX_OK;
+
+failed:
+
+    if (ngx_close_file(file.fd) == NGX_FILE_ERROR) {
+        ngx_log_error(NGX_LOG_ALERT, cf->log, ngx_errno,
+                      ngx_close_file_n " \"%V\" failed", &file.name);
+    }
+
+    return NGX_ERROR;
+}
+
+
+#ifdef OPENSSL_NO_SHA256
+#define ngx_ssl_session_ticket_md  EVP_sha1
+#else
+#define ngx_ssl_session_ticket_md  EVP_sha256
+#endif
+
+
+static int
+ngx_ssl_session_ticket_key_callback(ngx_ssl_conn_t *ssl_conn,
+    unsigned char *name, unsigned char *iv, EVP_CIPHER_CTX *ectx,
+    HMAC_CTX *hctx, int enc)
+{
+    SSL_CTX                       *ssl_ctx;
+    ngx_uint_t                     i;
+    ngx_array_t                   *keys;
+    ngx_ssl_session_ticket_key_t  *key;
+#if (NGX_DEBUG)
+    u_char                         buf[32];
+    ngx_connection_t              *c;
+#endif
+
+    ssl_ctx = SSL_get_SSL_CTX(ssl_conn);
+
+    keys = SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_session_ticket_keys_index);
+    if (keys == NULL) {
+        return -1;
+    }
+
+    key = keys->elts;
+
+#if (NGX_DEBUG)
+    c = ngx_ssl_get_connection(ssl_conn);
+#endif
+
+    if (enc == 1) {
+        /* encrypt session ticket */
+
+        ngx_log_debug3(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "ssl session ticket encrypt, key: \"%*s\" (%s session)",
+                       ngx_hex_dump(buf, key[0].name, 16) - buf, buf,
+                       SSL_session_reused(ssl_conn) ? "reused" : "new");
+
+        RAND_pseudo_bytes(iv, 16);
+        EVP_EncryptInit_ex(ectx, EVP_aes_128_cbc(), NULL, key[0].aes_key, iv);
+        HMAC_Init_ex(hctx, key[0].hmac_key, 16,
+                     ngx_ssl_session_ticket_md(), NULL);
+        memcpy(name, key[0].name, 16);
+
+        return 0;
+
+    } else {
+        /* decrypt session ticket */
+
+        for (i = 0; i < keys->nelts; i++) {
+            if (ngx_memcmp(name, key[i].name, 16) == 0) {
+                goto found;
+            }
+        }
+
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "ssl session ticket decrypt, key: \"%*s\" not found",
+                       ngx_hex_dump(buf, name, 16) - buf, buf);
+
+        return 0;
+
+    found:
+
+        ngx_log_debug3(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                       "ssl session ticket decrypt, key: \"%*s\"%s",
+                       ngx_hex_dump(buf, key[i].name, 16) - buf, buf,
+                       (i == 0) ? " (default)" : "");
+
+        HMAC_Init_ex(hctx, key[i].hmac_key, 16,
+                     ngx_ssl_session_ticket_md(), NULL);
+        EVP_DecryptInit_ex(ectx, EVP_aes_128_cbc(), NULL, key[i].aes_key, iv);
+
+        return (i == 0) ? 1 : 2 /* renew */;
+    }
+}
+
+#else
+
+ngx_int_t
+ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *paths)
+{
+    if (paths) {
+        ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+                      "\"ssl_session_ticket_keys\" ignored, not supported");
+    }
+
+    return NGX_OK;
+}
+
+#endif
+
+
+void
+ngx_ssl_cleanup_ctx(void *data)
+{
+    ngx_ssl_t  *ssl = data;
+
+    SSL_CTX_free(ssl->ctx);
+}
+
+
+ngx_int_t
+ngx_ssl_get_protocol(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    s->data = (u_char *) SSL_get_version(c->ssl->connection);
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_get_cipher_name(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    s->data = (u_char *) SSL_get_cipher_name(c->ssl->connection);
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_get_session_id(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    int           len;
+    u_char       *buf;
+    SSL_SESSION  *sess;
+
+    sess = SSL_get0_session(c->ssl->connection);
+    if (sess == NULL) {
+        s->len = 0;
+        return NGX_OK;
+    }
+
+    buf = sess->session_id;
+    len = sess->session_id_length;
+
+    s->len = 2 * len;
+    s->data = ngx_pnalloc(pool, 2 * len);
+    if (s->data == NULL) {
+        return NGX_ERROR;
+    }
+
+    ngx_hex_dump(s->data, buf, len);
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_get_session_reused(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    if (SSL_session_reused(c->ssl->connection)) {
+        ngx_str_set(s, "r");
+
+    } else {
+        ngx_str_set(s, ".");
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_get_raw_certificate(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    size_t   len;
+    BIO     *bio;
+    X509    *cert;
+
+    s->len = 0;
+
+    cert = SSL_get_peer_certificate(c->ssl->connection);
+    if (cert == NULL) {
+        return NGX_OK;
+    }
+
+    bio = BIO_new(BIO_s_mem());
+    if (bio == NULL) {
+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, "BIO_new() failed");
+        X509_free(cert);
+        return NGX_ERROR;
+    }
+
+    if (PEM_write_bio_X509(bio, cert) == 0) {
+        ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, "PEM_write_bio_X509() failed");
+        goto failed;
+    }
+
+    len = BIO_pending(bio);
+    s->len = len;
+
+    s->data = ngx_pnalloc(pool, len);
+    if (s->data == NULL) {
+        goto failed;
+    }
+
+    BIO_read(bio, s->data, len);
+
+    BIO_free(bio);
+    X509_free(cert);
+
+    return NGX_OK;
+
+failed:
+
+    BIO_free(bio);
+    X509_free(cert);
+
+    return NGX_ERROR;
+}
+
+
+ngx_int_t
+ngx_ssl_get_certificate(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    u_char      *p;
+    size_t       len;
+    ngx_uint_t   i;
+    ngx_str_t    cert;
+
+    if (ngx_ssl_get_raw_certificate(c, pool, &cert) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    if (cert.len == 0) {
+        s->len = 0;
+        return NGX_OK;
+    }
+
+    len = cert.len - 1;
+
+    for (i = 0; i < cert.len - 1; i++) {
+        if (cert.data[i] == LF) {
+            len++;
+        }
+    }
+
+    s->len = len;
+    s->data = ngx_pnalloc(pool, len);
+    if (s->data == NULL) {
+        return NGX_ERROR;
+    }
+
+    p = s->data;
+
+    for (i = 0; i < cert.len - 1; i++) {
+        *p++ = cert.data[i];
+        if (cert.data[i] == LF) {
+            *p++ = '\t';
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_get_subject_dn(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    char       *p;
+    size_t      len;
+    X509       *cert;
+    X509_NAME  *name;
+
+    s->len = 0;
+
+    cert = SSL_get_peer_certificate(c->ssl->connection);
+    if (cert == NULL) {
+        return NGX_OK;
+    }
+
+    name = X509_get_subject_name(cert);
+    if (name == NULL) {
+        X509_free(cert);
+        return NGX_ERROR;
+    }
+
+    p = X509_NAME_oneline(name, NULL, 0);
+
+    for (len = 0; p[len]; len++) { /* void */ }
+
+    s->len = len;
+    s->data = ngx_pnalloc(pool, len);
+    if (s->data == NULL) {
+        OPENSSL_free(p);
+        X509_free(cert);
+        return NGX_ERROR;
+    }
+
+    ngx_memcpy(s->data, p, len);
+
+    OPENSSL_free(p);
+    X509_free(cert);
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_get_issuer_dn(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    char       *p;
+    size_t      len;
+    X509       *cert;
+    X509_NAME  *name;
+
+    s->len = 0;
+
+    cert = SSL_get_peer_certificate(c->ssl->connection);
+    if (cert == NULL) {
+        return NGX_OK;
+    }
+
+    name = X509_get_issuer_name(cert);
+    if (name == NULL) {
+        X509_free(cert);
+        return NGX_ERROR;
+    }
+
+    p = X509_NAME_oneline(name, NULL, 0);
+
+    for (len = 0; p[len]; len++) { /* void */ }
+
+    s->len = len;
+    s->data = ngx_pnalloc(pool, len);
+    if (s->data == NULL) {
+        OPENSSL_free(p);
+        X509_free(cert);
+        return NGX_ERROR;
+    }
+
+    ngx_memcpy(s->data, p, len);
+
+    OPENSSL_free(p);
+    X509_free(cert);
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_get_serial_number(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    size_t   len;
+    X509    *cert;
+    BIO     *bio;
+
+    s->len = 0;
+
+    cert = SSL_get_peer_certificate(c->ssl->connection);
+    if (cert == NULL) {
+        return NGX_OK;
+    }
+
+    bio = BIO_new(BIO_s_mem());
+    if (bio == NULL) {
+        X509_free(cert);
+        return NGX_ERROR;
+    }
+
+    i2a_ASN1_INTEGER(bio, X509_get_serialNumber(cert));
+    len = BIO_pending(bio);
+
+    s->len = len;
+    s->data = ngx_pnalloc(pool, len);
+    if (s->data == NULL) {
+        BIO_free(bio);
+        X509_free(cert);
+        return NGX_ERROR;
+    }
+
+    BIO_read(bio, s->data, len);
+    BIO_free(bio);
+    X509_free(cert);
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_get_client_verify(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    X509  *cert;
+
+    if (SSL_get_verify_result(c->ssl->connection) != X509_V_OK) {
+        ngx_str_set(s, "FAILED");
+        return NGX_OK;
+    }
+
+    cert = SSL_get_peer_certificate(c->ssl->connection);
+
+    if (cert) {
+        ngx_str_set(s, "SUCCESS");
+
+    } else {
+        ngx_str_set(s, "NONE");
+    }
+
+    X509_free(cert);
+
+    return NGX_OK;
+}
+
+
+static void *
+ngx_openssl_create_conf(ngx_cycle_t *cycle)
+{
+    ngx_openssl_conf_t  *oscf;
+
+    oscf = ngx_pcalloc(cycle->pool, sizeof(ngx_openssl_conf_t));
+    if (oscf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc():
+     *
+     *     oscf->engine = 0;
+     */
+
+    return oscf;
+}
+
+
+static char *
+ngx_openssl_engine(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_openssl_conf_t *oscf = conf;
+
+    ENGINE     *engine;
+    ngx_str_t  *value;
+
+    if (oscf->engine) {
+        return "is duplicate";
+    }
+
+    oscf->engine = 1;
+
+    value = cf->args->elts;
+
+    engine = ENGINE_by_id((const char *) value[1].data);
+
+    if (engine == NULL) {
+        ngx_ssl_error(NGX_LOG_WARN, cf->log, 0,
+                      "ENGINE_by_id(\"%V\") failed", &value[1]);
+        return NGX_CONF_ERROR;
+    }
+
+    if (ENGINE_set_default(engine, ENGINE_METHOD_ALL) == 0) {
+        ngx_ssl_error(NGX_LOG_WARN, cf->log, 0,
+                      "ENGINE_set_default(\"%V\", ENGINE_METHOD_ALL) failed",
+                      &value[1]);
+
+        ENGINE_free(engine);
+
+        return NGX_CONF_ERROR;
+    }
+
+    ENGINE_free(engine);
+
+    return NGX_CONF_OK;
+}
+
+
+static void
+ngx_openssl_exit(ngx_cycle_t *cycle)
+{
+    EVP_cleanup();
+    ENGINE_cleanup();
+}
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl.c.rej workspace/src/event/ngx_event_openssl.c.rej
--- sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl.c.rej	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/event/ngx_event_openssl.c.rej	2014-03-28 21:15:31.000000000 -0700
@@ -0,0 +1,495 @@
+***************
+*** 84,100 ****
+      NGX_MODULE_V1_PADDING
+  };
+
+
+  int  ngx_ssl_connection_index;
+  int  ngx_ssl_server_conf_index;
+  int  ngx_ssl_session_cache_index;
+  int  ngx_ssl_session_ticket_keys_index;
+- int  ngx_ssl_certificate_index;
+  int  ngx_ssl_stapling_index;
+
+
+  ngx_int_t
+  ngx_ssl_init(ngx_log_t *log)
+  {
+      OPENSSL_config(NULL);
+
+--- 84,99 ----
+      NGX_MODULE_V1_PADDING
+  };
+
+
+  int  ngx_ssl_connection_index;
+  int  ngx_ssl_server_conf_index;
+  int  ngx_ssl_session_cache_index;
+  int  ngx_ssl_session_ticket_keys_index;
+  int  ngx_ssl_stapling_index;
+
+
+  ngx_int_t
+  ngx_ssl_init(ngx_log_t *log)
+  {
+      OPENSSL_config(NULL);
+
+***************
+*** 149,172 ****
+      ngx_ssl_session_ticket_keys_index = SSL_CTX_get_ex_new_index(0, NULL, NULL,
+                                                                   NULL, NULL);
+      if (ngx_ssl_session_ticket_keys_index == -1) {
+          ngx_ssl_error(NGX_LOG_ALERT, log, 0,
+                        "SSL_CTX_get_ex_new_index() failed");
+          return NGX_ERROR;
+      }
+
+-     ngx_ssl_certificate_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL,
+-                                                          NULL);
+-     if (ngx_ssl_certificate_index == -1) {
+-         ngx_ssl_error(NGX_LOG_ALERT, log, 0,
+-                       "SSL_CTX_get_ex_new_index() failed");
+-         return NGX_ERROR;
+-     }
+-
+      ngx_ssl_stapling_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL,
+                                                        NULL);
+      if (ngx_ssl_stapling_index == -1) {
+          ngx_ssl_error(NGX_LOG_ALERT, log, 0,
+                        "SSL_CTX_get_ex_new_index() failed");
+          return NGX_ERROR;
+      }
+
+--- 148,163 ----
+      ngx_ssl_session_ticket_keys_index = SSL_CTX_get_ex_new_index(0, NULL, NULL,
+                                                                   NULL, NULL);
+      if (ngx_ssl_session_ticket_keys_index == -1) {
+          ngx_ssl_error(NGX_LOG_ALERT, log, 0,
+                        "SSL_CTX_get_ex_new_index() failed");
+          return NGX_ERROR;
+      }
+
+      ngx_ssl_stapling_index = SSL_CTX_get_ex_new_index(0, NULL, NULL, NULL,
+                                                        NULL);
+      if (ngx_ssl_stapling_index == -1) {
+          ngx_ssl_error(NGX_LOG_ALERT, log, 0,
+                        "SSL_CTX_get_ex_new_index() failed");
+          return NGX_ERROR;
+      }
+
+***************
+*** 200,215 ****
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG);
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER);
+
+  #ifdef SSL_OP_MSIE_SSLV2_RSA_PADDING
+      /* this option allow a potential SSL 2.0 rollback (CAN-2005-2969) */
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_MSIE_SSLV2_RSA_PADDING);
+  #endif
+
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_SSLEAY_080_CLIENT_DH_BUG);
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_TLS_D5_BUG);
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_TLS_BLOCK_PADDING_BUG);
+
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
+
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_SINGLE_DH_USE);
+
+--- 191,210 ----
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG);
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER);
+
+  #ifdef SSL_OP_MSIE_SSLV2_RSA_PADDING
+      /* this option allow a potential SSL 2.0 rollback (CAN-2005-2969) */
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_MSIE_SSLV2_RSA_PADDING);
+  #endif
+
++ #ifdef SSL_OP_SAFARI_ECDHE_ECDSA_BUG
++     SSL_CTX_set_options(ssl->ctx, SSL_OP_SAFARI_ECDHE_ECDSA_BUG);
++ #endif
++
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_SSLEAY_080_CLIENT_DH_BUG);
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_TLS_D5_BUG);
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_TLS_BLOCK_PADDING_BUG);
+
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);
+
+      SSL_CTX_set_options(ssl->ctx, SSL_OP_SINGLE_DH_USE);
+
+***************
+*** 245,362 ****
+
+      SSL_CTX_set_info_callback(ssl->ctx, ngx_ssl_info_callback);
+
+      return NGX_OK;
+  }
+
+
+  ngx_int_t
+- ngx_ssl_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
+-     ngx_str_t *key)
+  {
+-     BIO     *bio;
+-     X509    *x509;
+-     u_long   n;
+-
+-     if (ngx_conf_full_name(cf->cycle, cert, 1) != NGX_OK) {
+          return NGX_ERROR;
+      }
+
+-     /*
+-      * we can't use SSL_CTX_use_certificate_chain_file() as it doesn't
+-      * allow to access certificate later from SSL_CTX, so we reimplement
+-      * it here
+-      */
+-
+-     bio = BIO_new_file((char *) cert->data, "r");
+-     if (bio == NULL) {
+-         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+-                       "BIO_new_file(\"%s\") failed", cert->data);
+-         return NGX_ERROR;
+-     }
+-
+-     x509 = PEM_read_bio_X509_AUX(bio, NULL, NULL, NULL);
+-     if (x509 == NULL) {
+-         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+-                       "PEM_read_bio_X509_AUX(\"%s\") failed", cert->data);
+-         BIO_free(bio);
+-         return NGX_ERROR;
+-     }
+-
+-     if (SSL_CTX_use_certificate(ssl->ctx, x509) == 0) {
+-         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+-                       "SSL_CTX_use_certificate(\"%s\") failed", cert->data);
+-         X509_free(x509);
+-         BIO_free(bio);
+-         return NGX_ERROR;
+-     }
+-
+-     if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_certificate_index, x509)
+-         == 0)
+-     {
+-         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+-                       "SSL_CTX_set_ex_data() failed");
+-         X509_free(x509);
+-         BIO_free(bio);
+-         return NGX_ERROR;
+-     }
+-
+-     X509_free(x509);
+-
+-     /* read rest of the chain */
+-
+-     for ( ;; ) {
+-
+-         x509 = PEM_read_bio_X509(bio, NULL, NULL, NULL);
+-         if (x509 == NULL) {
+-             n = ERR_peek_last_error();
+-
+-             if (ERR_GET_LIB(n) == ERR_LIB_PEM
+-                 && ERR_GET_REASON(n) == PEM_R_NO_START_LINE)
+-             {
+-                 /* end of file */
+-                 ERR_clear_error();
+-                 break;
+              }
+
+-             /* some real error */
+-
+-             ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+-                           "PEM_read_bio_X509(\"%s\") failed", cert->data);
+-             BIO_free(bio);
+              return NGX_ERROR;
+          }
+
+-         if (SSL_CTX_add_extra_chain_cert(ssl->ctx, x509) == 0) {
+              ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+-                           "SSL_CTX_add_extra_chain_cert(\"%s\") failed",
+-                           cert->data);
+-             X509_free(x509);
+-             BIO_free(bio);
+-             return NGX_ERROR;
+          }
+      }
+
+-     BIO_free(bio);
+-
+-     if (ngx_conf_full_name(cf->cycle, key, 1) != NGX_OK) {
+-         return NGX_ERROR;
+-     }
+-
+-     if (SSL_CTX_use_PrivateKey_file(ssl->ctx, (char *) key->data,
+-                                     SSL_FILETYPE_PEM)
+-         == 0)
+-     {
+-         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+-                       "SSL_CTX_use_PrivateKey_file(\"%s\") failed", key->data);
+-         return NGX_ERROR;
+-     }
+-
+      return NGX_OK;
+  }
+
+
+  ngx_int_t
+  ngx_ssl_client_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
+      ngx_int_t depth)
+  {
+      STACK_OF(X509_NAME)  *list;
+--- 240,495 ----
+
+      SSL_CTX_set_info_callback(ssl->ctx, ngx_ssl_info_callback);
+
+      return NGX_OK;
+  }
+
+
+  ngx_int_t
++ ngx_ssl_certificates(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_array_t *certs,
++     ngx_array_t *keys, ngx_flag_t stapling, ngx_array_t *stapling_files,
++     ngx_str_t *stapling_responder, ngx_flag_t stapling_verify)
+  {
++     ngx_str_t       *cert;
++     ngx_str_t       *key;
++     ngx_str_t       *stapling_file = NULL;
++     ngx_uint_t       i;
++     ngx_int_t        j;
++     u_long           n;
++     BIO             *bio = NULL;
++     EVP_PKEY        *pkey = NULL;
++     X509            *x509 = NULL;
++     X509            *x509_ca = NULL;
++ #ifndef SSL_CTX_add0_chain_cert
++     STACK_OF(X509)  *extra_certs;
++ #endif
++
++     cert = certs->elts;
++
++     if ((keys == NGX_CONF_UNSET_PTR) || (keys->nelts < certs->nelts)) {
++         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
++                       "no \"ssl_certificate_key\" is defined for "
++                       "ssl_certificate \"%V\"",
++                       &cert[(keys == NGX_CONF_UNSET_PTR) ? 0 : keys->nelts]);
+          return NGX_ERROR;
+      }
+
++     /* setup OCSP stapling for this SSL_CTX */
++
++     if (stapling) {
++
++         if (stapling_files != NGX_CONF_UNSET_PTR) {
++
++             if (stapling_files->nelts < certs->nelts) {
++                 ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
++                               "no \"ssl_stapling_file\" is defined for "
++                               "ssl_certificate \"%V\"",
++                               &cert[stapling_files->nelts]);
++                 return NGX_ERROR;
+              }
+
++             stapling_file = stapling_files->elts;
++
++         }
++
++         if (ngx_ssl_stapling(cf, ssl, stapling_verify) != NGX_OK) {
+              return NGX_ERROR;
+          }
+
++     }
++
++     key = keys->elts;
++
++     for (i = 0; i < certs->nelts; i++) {
++
++         /* load private key */
++
++         if (ngx_conf_full_name(cf->cycle, &key[i], 1) != NGX_OK) {
++             goto failed;
++         }
++
++         bio = BIO_new_file((char *) (&key[i])->data, "r");
++         if (bio == NULL) {
+              ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
++                           "BIO_new_file(\"%V\") failed", &key[i]);
++             goto failed;
+          }
++
++         pkey = PEM_read_bio_PrivateKey(bio, NULL, NULL, NULL);
++         if (pkey == NULL) {
++             ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
++                           "PEM_read_bio_PrivateKey(\"%V\") failed", &key[i]);
++             goto failed;
++         }
++
++         BIO_free(bio);
++         bio = NULL;
++
++         /* load server certificate */
++
++         if (ngx_conf_full_name(cf->cycle, &cert[i], 1) != NGX_OK) {
++             goto failed;
++         }
++
++         /*
++          * we can't use SSL_CTX_use_certificate_chain_file() as it doesn't
++          * allow to access certificate later from SSL_CTX, so we reimplement
++          * it here
++          */
++
++         bio = BIO_new_file((char *) (&cert[i])->data, "r");
++         if (bio == NULL) {
++             ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
++                           "BIO_new_file(\"%V\") failed", &cert[i]);
++             goto failed;
++         }
++
++         x509 = PEM_read_bio_X509_AUX(bio, NULL, NULL, NULL);
++         if (x509 == NULL) {
++             ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
++                           "PEM_read_bio_X509_AUX(\"%V\") failed", &cert[i]);
++             goto failed;
++         }
++
++         if (X509_check_private_key(x509, pkey) != 1) {
++             ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
++                           "X509_check_private_key(\"%V\") for \"%V\" failed",
++                           &key[i], &cert[i]);
++             goto failed;
++         }
++
++         if (SSL_CTX_use_certificate(ssl->ctx, x509) == 0) {
++             ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
++                           "SSL_CTX_use_certificate(\"%V\") failed", &cert[i]);
++             goto failed;
++         }
++
++         if (SSL_CTX_use_PrivateKey(ssl->ctx, pkey) != 1) {
++             ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
++                           "SSL_CTX_use_PrivateKey(\"%V\") failed", &key[i]);
++             goto failed;
++         }
++
++         /* read rest of the chain */
++
++         for (j = 0; ; j++) {
++
++             x509_ca = PEM_read_bio_X509(bio, NULL, NULL, NULL);
++             n = ERR_peek_last_error();
++
++             /* setup OCSP stapling for this server certificate */
++             if (stapling && (j == 0)) {
++                 if (ngx_ssl_stapling_cert(cf, ssl, x509_ca, x509, &cert[i],
++                                           stapling_file ? &stapling_file[i]
++                                                         : NULL,
++                                           stapling_responder) != NGX_OK)
++                     goto failed;
++             }
++
++             if (x509_ca == NULL) {
++
++                 if (ERR_GET_LIB(n) == ERR_LIB_PEM
++                     && ERR_GET_REASON(n) == PEM_R_NO_START_LINE)
++                 {
++                     /* end of file */
++                     ERR_clear_error();
++                     break;
++                 }
++
++                 /* some real error */
++
++                 ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
++                               "PEM_read_bio_X509(\"%V\") failed", &cert[i]);
++                 goto failed;
++             }
++
++ #ifdef SSL_CTX_add0_chain_cert
++             /* OpenSSL >=1.0.2 allows multiple server certificates in a single
++              * SSL_CTX to each have a different chain
++              */
++             if (SSL_CTX_add0_chain_cert(ssl->ctx, x509_ca) == 0) {
++                 ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
++                               "SSL_CTX_add0_chain_cert(\"%V\") failed",
++                               &cert[i]);
++                 goto failed;
++             }
++ #else
++             /* OpenSSL <1.0.2 restricts multiple server certificates in a single
++              * SSL_CTX to sharing the same "extra_certs" chain.
++              * If different chains are required, "extra_certs" must be left
++              * empty and all of the intermediates must be added to the
++              * ssl_trusted_certificate file.  (Note that this has the
++              * side-effect of enabling these intermediates for verification of
++              * client certificates and OCSP Responses)
++              */
++             if (i == 0) {
++
++                 if (SSL_CTX_add_extra_chain_cert(ssl->ctx, x509_ca) == 0) {
++                     ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
++                                   "SSL_CTX_add_extra_chain_cert() failed");
++                     goto failed;
++                 }
++
++             } else {
++
++ #ifdef SSL_CTX_get_extra_chain_certs
++                 SSL_CTX_get_extra_chain_certs(ssl->ctx, &extra_certs);
++ #else
++                 extra_certs = ssl->ctx->extra_certs;
++ #endif
++
++                 if ((extra_certs == NULL) || (j >= sk_X509_num(extra_certs))
++                     || (X509_cmp(x509_ca, sk_X509_value(extra_certs, j)) != 0))
++                 {
++                     ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
++                                   "the intermediate CA certificate(s) in "
++                                   "\"%V\" do not match those in \"%V\".  Due "
++                                   "to a limitation in the OpenSSL library that "
++                                   "nginx is using, you need to move all of the "
++                                   "CA certificates into the "
++                                   "\"ssl_trusted_certificate\" file, but be "
++                                   "aware that this will have the side-effect "
++                                   "of enabling them for verification of client "
++                                   "certificates and OCSP Responses",
++                                   &cert[i], &cert[0]);
++                     goto failed;
++                 }
++
++                 X509_free(x509_ca);
++
++             }
++ #endif
++
++         }
++
++         BIO_free(bio);
++         bio = NULL;
++
++         EVP_PKEY_free(pkey);
++         pkey = NULL;
++
++         X509_free(x509);
++         x509 = NULL;
++
+      }
+
+      return NGX_OK;
++
++ failed:
++     if (bio)
++         BIO_free(bio);
++     if (pkey)
++         EVP_PKEY_free(pkey);
++     if (x509)
++         X509_free(x509);
++     if (x509_ca)
++         X509_free(x509_ca);
++
++     return NGX_ERROR;
+  }
+
+
+  ngx_int_t
+  ngx_ssl_client_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
+      ngx_int_t depth)
+  {
+      STACK_OF(X509_NAME)  *list;
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl.h workspace/src/event/ngx_event_openssl.h
--- sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl.h	2014-03-28 21:15:34.000000000 -0700
+++ workspace/src/event/ngx_event_openssl.h	2014-03-28 21:14:16.000000000 -0700
@@ -111,15 +111,19 @@

 ngx_int_t ngx_ssl_init(ngx_log_t *log);
 ngx_int_t ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data);
-ngx_int_t ngx_ssl_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
-    ngx_str_t *cert, ngx_str_t *key);
+ngx_int_t ngx_ssl_certificates(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_array_t *certs, ngx_array_t *keys, ngx_flag_t stapling,
+    ngx_array_t *stapling_files, ngx_str_t *stapling_responder,
+    ngx_flag_t stapling_verify);
 ngx_int_t ngx_ssl_client_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
     ngx_str_t *cert, ngx_int_t depth);
 ngx_int_t ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
     ngx_str_t *cert, ngx_int_t depth);
 ngx_int_t ngx_ssl_crl(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *crl);
-ngx_int_t ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl,
-    ngx_str_t *file, ngx_str_t *responder, ngx_uint_t verify);
+ngx_int_t ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_uint_t verify);
+ngx_int_t ngx_ssl_stapling_cert(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    X509 *issuer, X509 *cert, ngx_str_t *cert_file, ngx_str_t *stapling_file,
+    ngx_str_t *responder);
 ngx_int_t ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
     ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);
 RSA *ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,
@@ -190,7 +194,6 @@
 extern int  ngx_ssl_server_conf_index;
 extern int  ngx_ssl_session_cache_index;
 extern int  ngx_ssl_session_ticket_keys_index;
-extern int  ngx_ssl_certificate_index;
 extern int  ngx_ssl_stapling_index;


diff -Naurdw sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl.h.orig workspace/src/event/ngx_event_openssl.h.orig
--- sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/event/ngx_event_openssl.h.orig	2014-03-28 20:55:34.000000000 -0700
@@ -0,0 +1,197 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#ifndef _NGX_EVENT_OPENSSL_H_INCLUDED_
+#define _NGX_EVENT_OPENSSL_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#include <openssl/conf.h>
+#include <openssl/engine.h>
+#include <openssl/evp.h>
+#include <openssl/ocsp.h>
+
+#define NGX_SSL_NAME     "OpenSSL"
+
+
+#define ngx_ssl_session_t       SSL_SESSION
+#define ngx_ssl_conn_t          SSL
+
+
+typedef struct {
+    SSL_CTX                    *ctx;
+    ngx_log_t                  *log;
+    size_t                      buffer_size;
+} ngx_ssl_t;
+
+
+typedef struct {
+    ngx_ssl_conn_t             *connection;
+
+    ngx_int_t                   last;
+    ngx_buf_t                  *buf;
+    size_t                      buffer_size;
+
+    ngx_connection_handler_pt   handler;
+
+    ngx_event_handler_pt        saved_read_handler;
+    ngx_event_handler_pt        saved_write_handler;
+
+    unsigned                    handshaked:1;
+    unsigned                    renegotiation:1;
+    unsigned                    buffer:1;
+    unsigned                    no_wait_shutdown:1;
+    unsigned                    no_send_shutdown:1;
+    unsigned                    handshake_buffer_set:1;
+} ngx_ssl_connection_t;
+
+
+#define NGX_SSL_NO_SCACHE            -2
+#define NGX_SSL_NONE_SCACHE          -3
+#define NGX_SSL_NO_BUILTIN_SCACHE    -4
+#define NGX_SSL_DFLT_BUILTIN_SCACHE  -5
+
+
+#define NGX_SSL_MAX_SESSION_SIZE  4096
+
+typedef struct ngx_ssl_sess_id_s  ngx_ssl_sess_id_t;
+
+struct ngx_ssl_sess_id_s {
+    ngx_rbtree_node_t           node;
+    u_char                     *id;
+    size_t                      len;
+    u_char                     *session;
+    ngx_queue_t                 queue;
+    time_t                      expire;
+#if (NGX_PTR_SIZE == 8)
+    void                       *stub;
+    u_char                      sess_id[32];
+#endif
+};
+
+
+typedef struct {
+    ngx_rbtree_t                session_rbtree;
+    ngx_rbtree_node_t           sentinel;
+    ngx_queue_t                 expire_queue;
+} ngx_ssl_session_cache_t;
+
+
+#ifdef SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB
+
+typedef struct {
+    u_char                      name[16];
+    u_char                      aes_key[16];
+    u_char                      hmac_key[16];
+} ngx_ssl_session_ticket_key_t;
+
+#endif
+
+
+#define NGX_SSL_SSLv2    0x0002
+#define NGX_SSL_SSLv3    0x0004
+#define NGX_SSL_TLSv1    0x0008
+#define NGX_SSL_TLSv1_1  0x0010
+#define NGX_SSL_TLSv1_2  0x0020
+
+
+#define NGX_SSL_BUFFER   1
+#define NGX_SSL_CLIENT   2
+
+#define NGX_SSL_BUFSIZE  16384
+
+
+ngx_int_t ngx_ssl_init(ngx_log_t *log);
+ngx_int_t ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data);
+ngx_int_t ngx_ssl_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_str_t *cert, ngx_str_t *key);
+ngx_int_t ngx_ssl_client_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_str_t *cert, ngx_int_t depth);
+ngx_int_t ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_str_t *cert, ngx_int_t depth);
+ngx_int_t ngx_ssl_crl(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *crl);
+ngx_int_t ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_str_t *file, ngx_str_t *responder, ngx_uint_t verify);
+ngx_int_t ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);
+RSA *ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,
+    int key_length);
+ngx_int_t ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file);
+ngx_int_t ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name);
+ngx_int_t ngx_ssl_session_cache(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,
+    ssize_t builtin_session_cache, ngx_shm_zone_t *shm_zone, time_t timeout);
+ngx_int_t ngx_ssl_session_ticket_keys(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_array_t *paths);
+ngx_int_t ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data);
+ngx_int_t ngx_ssl_create_connection(ngx_ssl_t *ssl, ngx_connection_t *c,
+    ngx_uint_t flags);
+
+void ngx_ssl_remove_cached_session(SSL_CTX *ssl, ngx_ssl_session_t *sess);
+ngx_int_t ngx_ssl_set_session(ngx_connection_t *c, ngx_ssl_session_t *session);
+#define ngx_ssl_get_session(c)      SSL_get1_session(c->ssl->connection)
+#define ngx_ssl_free_session        SSL_SESSION_free
+#define ngx_ssl_get_connection(ssl_conn)                                      \
+    SSL_get_ex_data(ssl_conn, ngx_ssl_connection_index)
+#define ngx_ssl_get_server_conf(ssl_ctx)                                      \
+    SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_server_conf_index)
+
+#define ngx_ssl_verify_error_optional(n)                                      \
+    (n == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT                              \
+     || n == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN                             \
+     || n == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY                     \
+     || n == X509_V_ERR_CERT_UNTRUSTED                                        \
+     || n == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE)
+
+
+ngx_int_t ngx_ssl_get_protocol(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+ngx_int_t ngx_ssl_get_cipher_name(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+ngx_int_t ngx_ssl_get_session_id(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+ngx_int_t ngx_ssl_get_session_reused(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+ngx_int_t ngx_ssl_get_raw_certificate(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+ngx_int_t ngx_ssl_get_certificate(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+ngx_int_t ngx_ssl_get_subject_dn(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+ngx_int_t ngx_ssl_get_issuer_dn(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+ngx_int_t ngx_ssl_get_serial_number(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+ngx_int_t ngx_ssl_get_client_verify(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+
+
+ngx_int_t ngx_ssl_handshake(ngx_connection_t *c);
+ssize_t ngx_ssl_recv(ngx_connection_t *c, u_char *buf, size_t size);
+ssize_t ngx_ssl_write(ngx_connection_t *c, u_char *data, size_t size);
+ssize_t ngx_ssl_recv_chain(ngx_connection_t *c, ngx_chain_t *cl);
+ngx_chain_t *ngx_ssl_send_chain(ngx_connection_t *c, ngx_chain_t *in,
+    off_t limit);
+void ngx_ssl_free_buffer(ngx_connection_t *c);
+ngx_int_t ngx_ssl_shutdown(ngx_connection_t *c);
+void ngx_cdecl ngx_ssl_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err,
+    char *fmt, ...);
+void ngx_ssl_cleanup_ctx(void *data);
+
+
+extern int  ngx_ssl_connection_index;
+extern int  ngx_ssl_server_conf_index;
+extern int  ngx_ssl_session_cache_index;
+extern int  ngx_ssl_session_ticket_keys_index;
+extern int  ngx_ssl_certificate_index;
+extern int  ngx_ssl_stapling_index;
+
+
+#endif /* _NGX_EVENT_OPENSSL_H_INCLUDED_ */
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl.h.rej workspace/src/event/ngx_event_openssl.h.rej
--- sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl.h.rej	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/event/ngx_event_openssl.h.rej	2014-03-28 21:15:31.000000000 -0700
@@ -0,0 +1,85 @@
+***************
+*** 106,130 ****
+  #define NGX_SSL_BUFFER   1
+  #define NGX_SSL_CLIENT   2
+
+  #define NGX_SSL_BUFSIZE  16384
+
+
+  ngx_int_t ngx_ssl_init(ngx_log_t *log);
+  ngx_int_t ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data);
+- ngx_int_t ngx_ssl_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
+-     ngx_str_t *cert, ngx_str_t *key);
+  ngx_int_t ngx_ssl_client_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
+      ngx_str_t *cert, ngx_int_t depth);
+  ngx_int_t ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
+      ngx_str_t *cert, ngx_int_t depth);
+  ngx_int_t ngx_ssl_crl(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *crl);
+- ngx_int_t ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl,
+-     ngx_str_t *file, ngx_str_t *responder, ngx_uint_t verify);
+  ngx_int_t ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
+      ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);
+  RSA *ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,
+      int key_length);
+  ngx_int_t ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file);
+  ngx_int_t ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name);
+  ngx_int_t ngx_ssl_session_cache(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,
+      ssize_t builtin_session_cache, ngx_shm_zone_t *shm_zone, time_t timeout);
+--- 106,134 ----
+  #define NGX_SSL_BUFFER   1
+  #define NGX_SSL_CLIENT   2
+
+  #define NGX_SSL_BUFSIZE  16384
+
+
+  ngx_int_t ngx_ssl_init(ngx_log_t *log);
+  ngx_int_t ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data);
++ ngx_int_t ngx_ssl_certificates(ngx_conf_t *cf, ngx_ssl_t *ssl,
++     ngx_array_t *certs, ngx_array_t *keys, ngx_flag_t stapling,
++     ngx_array_t *stapling_files, ngx_str_t *stapling_responder,
++     ngx_flag_t stapling_verify);
+  ngx_int_t ngx_ssl_client_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
+      ngx_str_t *cert, ngx_int_t depth);
+  ngx_int_t ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl,
+      ngx_str_t *cert, ngx_int_t depth);
+  ngx_int_t ngx_ssl_crl(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *crl);
++ ngx_int_t ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_uint_t verify);
++ ngx_int_t ngx_ssl_stapling_cert(ngx_conf_t *cf, ngx_ssl_t *ssl,
++     X509 *issuer, X509 *cert, ngx_str_t *cert_file, ngx_str_t *stapling_file,
++     ngx_str_t *responder);
+  ngx_int_t ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
+      ngx_resolver_t *resolver, ngx_msec_t resolver_timeout);
+  RSA *ngx_ssl_rsa512_key_callback(ngx_ssl_conn_t *ssl_conn, int is_export,
+      int key_length);
+  ngx_int_t ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file);
+  ngx_int_t ngx_ssl_ecdh_curve(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *name);
+  ngx_int_t ngx_ssl_session_cache(ngx_ssl_t *ssl, ngx_str_t *sess_ctx,
+      ssize_t builtin_session_cache, ngx_shm_zone_t *shm_zone, time_t timeout);
+***************
+*** 183,195 ****
+      char *fmt, ...);
+  void ngx_ssl_cleanup_ctx(void *data);
+
+
+  extern int  ngx_ssl_connection_index;
+  extern int  ngx_ssl_server_conf_index;
+  extern int  ngx_ssl_session_cache_index;
+  extern int  ngx_ssl_session_ticket_keys_index;
+- extern int  ngx_ssl_certificate_index;
+  extern int  ngx_ssl_stapling_index;
+
+
+  #endif /* _NGX_EVENT_OPENSSL_H_INCLUDED_ */
+--- 187,198 ----
+      char *fmt, ...);
+  void ngx_ssl_cleanup_ctx(void *data);
+
+
+  extern int  ngx_ssl_connection_index;
+  extern int  ngx_ssl_server_conf_index;
+  extern int  ngx_ssl_session_cache_index;
+  extern int  ngx_ssl_session_ticket_keys_index;
+  extern int  ngx_ssl_stapling_index;
+
+
+  #endif /* _NGX_EVENT_OPENSSL_H_INCLUDED_ */
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl_stapling.c workspace/src/event/ngx_event_openssl_stapling.c
--- sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl_stapling.c	2014-03-28 21:15:34.000000000 -0700
+++ workspace/src/event/ngx_event_openssl_stapling.c	2014-03-28 21:14:16.000000000 -0700
@@ -16,25 +16,32 @@

 typedef struct {
     ngx_str_t                    staple;
-    ngx_msec_t                   timeout;
-
-    ngx_resolver_t              *resolver;
-    ngx_msec_t                   resolver_timeout;

     ngx_addr_t                  *addrs;
     ngx_str_t                    host;
     ngx_str_t                    uri;
     in_port_t                    port;

-    SSL_CTX                     *ssl_ctx;
-
     X509                        *cert;
     X509                        *issuer;

     time_t                       valid;

-    unsigned                     verify:1;
     unsigned                     loading:1;
+} ngx_ssl_stapling_cert_t;
+
+
+typedef struct {
+    ngx_array_t                 *cert_staples;  /* ngx_ssl_stapling_cert_t[] */
+
+    ngx_msec_t                   timeout;
+
+    ngx_resolver_t              *resolver;
+    ngx_msec_t                   resolver_timeout;
+
+    SSL_CTX                     *ssl_ctx;
+
+    unsigned                     verify:1;
 } ngx_ssl_stapling_t;


@@ -57,7 +64,8 @@
     ngx_msec_t                   timeout;

     void                       (*handler)(ngx_ssl_ocsp_ctx_t *r);
-    void                        *data;
+    ngx_ssl_stapling_t          *staple;
+    ngx_ssl_stapling_cert_t     *cert_staple;

     ngx_buf_t                   *request;
     ngx_buf_t                   *response;
@@ -83,14 +91,17 @@


 static ngx_int_t ngx_ssl_stapling_file(ngx_conf_t *cf, ngx_ssl_t *ssl,
-    ngx_str_t *file);
-static ngx_int_t ngx_ssl_stapling_issuer(ngx_conf_t *cf, ngx_ssl_t *ssl);
+    ngx_ssl_stapling_cert_t *cert_staple, ngx_str_t *file);
+static ngx_int_t ngx_ssl_stapling_issuer(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_ssl_stapling_cert_t *cert_staple, ngx_str_t *cert_file);
 static ngx_int_t ngx_ssl_stapling_responder(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_ssl_stapling_cert_t *cert_staple, ngx_str_t *cert_file,
     ngx_str_t *responder);

 static int ngx_ssl_certificate_status_callback(ngx_ssl_conn_t *ssl_conn,
     void *data);
-static void ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple);
+static void ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple,
+    ngx_ssl_stapling_cert_t *cert_staple);
 static void ngx_ssl_stapling_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx);

 static void ngx_ssl_stapling_cleanup(void *data);
@@ -115,10 +126,8 @@


 ngx_int_t
-ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file,
-    ngx_str_t *responder, ngx_uint_t verify)
+ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_uint_t verify)
 {
-    ngx_int_t                  rc;
     ngx_pool_cleanup_t        *cln;
     ngx_ssl_stapling_t        *staple;

@@ -147,17 +156,56 @@
     staple->timeout = 60000;
     staple->verify = verify;

-    if (file->len) {
-        /* use OCSP response from the file */
+    staple->cert_staples = ngx_array_create(cf->pool, 3,
+                                            sizeof(ngx_ssl_stapling_cert_t));
+    if (staple->cert_staples == NULL) {
+        return NGX_ERROR;
+    }

-        if (ngx_ssl_stapling_file(cf, ssl, file) != NGX_OK) {
+    SSL_CTX_set_tlsext_status_cb(ssl->ctx, ngx_ssl_certificate_status_callback);
+    SSL_CTX_set_tlsext_status_arg(ssl->ctx, staple);
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_stapling_cert(ngx_conf_t *cf, ngx_ssl_t *ssl, X509 *issuer, X509 *cert,
+    ngx_str_t *cert_file, ngx_str_t *stapling_file, ngx_str_t *responder)
+{
+    ngx_int_t                  rc;
+    ngx_ssl_stapling_cert_t   *cert_staple;
+    ngx_ssl_stapling_t        *staple;
+
+    staple = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_stapling_index);
+
+    cert_staple = ngx_array_push(staple->cert_staples);
+    if (cert_staple == NULL) {
             return NGX_ERROR;
         }

-        goto done;
+    cert_staple->cert = cert;
+
+    if (stapling_file != NULL) {
+        /* use OCSP response from a file */
+
+        if (ngx_ssl_stapling_file(cf, ssl, cert_staple, stapling_file)
+            != NGX_OK)
+        {
+            return NGX_ERROR;
     }

-    rc = ngx_ssl_stapling_issuer(cf, ssl);
+        return NGX_OK;
+    }
+
+    if ((issuer != NULL) && ((X509_check_issued(issuer, cert) == X509_V_OK))) {
+        CRYPTO_add(&issuer->references, 1, CRYPTO_LOCK_X509);
+        cert_staple->issuer = issuer;
+    }
+    else {
+        /* lookup issuer certificate in trusted certificate store */
+
+        rc = ngx_ssl_stapling_issuer(cf, ssl, cert_staple, cert_file);

     if (rc == NGX_DECLINED) {
         return NGX_OK;
@@ -166,8 +214,9 @@
     if (rc != NGX_OK) {
         return NGX_ERROR;
     }
+    }

-    rc = ngx_ssl_stapling_responder(cf, ssl, responder);
+    rc = ngx_ssl_stapling_responder(cf, ssl, cert_staple, cert_file, responder);

     if (rc == NGX_DECLINED) {
         return NGX_OK;
@@ -177,25 +226,18 @@
         return NGX_ERROR;
     }

-done:
-
-    SSL_CTX_set_tlsext_status_cb(ssl->ctx, ngx_ssl_certificate_status_callback);
-    SSL_CTX_set_tlsext_status_arg(ssl->ctx, staple);
-
     return NGX_OK;
 }


 static ngx_int_t
-ngx_ssl_stapling_file(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)
+ngx_ssl_stapling_file(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_ssl_stapling_cert_t *cert_staple, ngx_str_t *file)
 {
     BIO                 *bio;
     int                  len;
     u_char              *p, *buf;
     OCSP_RESPONSE       *response;
-    ngx_ssl_stapling_t  *staple;
-
-    staple = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_stapling_index);

     if (ngx_conf_full_name(cf->cycle, file, 1) != NGX_OK) {
         return NGX_ERROR;
@@ -240,8 +282,8 @@
     OCSP_RESPONSE_free(response);
     BIO_free(bio);

-    staple->staple.data = buf;
-    staple->staple.len = len;
+    cert_staple->staple.data = buf;
+    cert_staple->staple.len = len;

     return NGX_OK;

@@ -255,43 +297,13 @@


 static ngx_int_t
-ngx_ssl_stapling_issuer(ngx_conf_t *cf, ngx_ssl_t *ssl)
+ngx_ssl_stapling_issuer(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_ssl_stapling_cert_t *cert_staple, ngx_str_t *cert_file)
 {
-    int                  i, n, rc;
-    X509                *cert, *issuer;
+    int                  rc;
+    X509                *issuer;
     X509_STORE          *store;
     X509_STORE_CTX      *store_ctx;
-    STACK_OF(X509)      *chain;
-    ngx_ssl_stapling_t  *staple;
-
-    staple = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_stapling_index);
-    cert = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_certificate_index);
-
-#if OPENSSL_VERSION_NUMBER >= 0x10001000L
-    SSL_CTX_get_extra_chain_certs(ssl->ctx, &chain);
-#else
-    chain = ssl->ctx->extra_certs;
-#endif
-
-    n = sk_X509_num(chain);
-
-    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
-                   "SSL get issuer: %d extra certs", n);
-
-    for (i = 0; i < n; i++) {
-        issuer = sk_X509_value(chain, i);
-        if (X509_check_issued(issuer, cert) == X509_V_OK) {
-            CRYPTO_add(&issuer->references, 1, CRYPTO_LOCK_X509);
-
-            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
-                           "SSL get issuer: found %p in extra certs", issuer);
-
-            staple->cert = cert;
-            staple->issuer = issuer;
-
-            return NGX_OK;
-        }
-    }

     store = SSL_CTX_get_cert_store(ssl->ctx);
     if (store == NULL) {
@@ -313,7 +325,7 @@
         return NGX_ERROR;
     }

-    rc = X509_STORE_CTX_get1_issuer(&issuer, store_ctx, cert);
+    rc = X509_STORE_CTX_get1_issuer(&issuer, store_ctx, cert_staple->cert);

     if (rc == -1) {
         ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
@@ -324,7 +336,9 @@

     if (rc == 0) {
         ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
-                      "\"ssl_stapling\" ignored, issuer certificate not found");
+                      "\"ssl_stapling\" ignored for \"%V\", issuer certificate "
+                      "not found",
+                      cert_file);
         X509_STORE_CTX_free(store_ctx);
         return NGX_DECLINED;
     }
@@ -334,32 +348,31 @@
     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
                    "SSL get issuer: found %p in cert store", issuer);

-    staple->cert = cert;
-    staple->issuer = issuer;
+    cert_staple->issuer = issuer;

     return NGX_OK;
 }


 static ngx_int_t
-ngx_ssl_stapling_responder(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder)
+ngx_ssl_stapling_responder(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_ssl_stapling_cert_t *cert_staple, ngx_str_t *cert_file,
+    ngx_str_t *responder)
 {
     ngx_url_t                  u;
     char                      *s;
-    ngx_ssl_stapling_t        *staple;
     STACK_OF(OPENSSL_STRING)  *aia;

-    staple = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_stapling_index);
-
     if (responder->len == 0) {

         /* extract OCSP responder URL from certificate */

-        aia = X509_get1_ocsp(staple->cert);
+        aia = X509_get1_ocsp(cert_staple->cert);
         if (aia == NULL) {
             ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
-                          "\"ssl_stapling\" ignored, "
-                          "no OCSP responder URL in the certificate");
+                          "\"ssl_stapling\" ignored for \"%V\", "
+                          "no OCSP responder URL in the certificate",
+                          cert_file);
             return NGX_DECLINED;
         }

@@ -370,8 +383,9 @@
 #endif
         if (s == NULL) {
             ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
-                          "\"ssl_stapling\" ignored, "
-                          "no OCSP responder URL in the certificate");
+                          "\"ssl_stapling\" ignored for \"%V\", "
+                          "no OCSP responder URL in the certificate",
+                          cert_file);
             X509_email_free(aia);
             return NGX_DECLINED;
         }
@@ -401,29 +415,31 @@

     } else {
         ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
-                      "\"ssl_stapling\" ignored, "
-                      "invalid URL prefix in OCSP responder \"%V\"", &u.url);
+                      "\"ssl_stapling\" ignored for \"%V\", "
+                      "invalid URL prefix in OCSP responder \"%V\"",
+                      cert_file, &u.url);
         return NGX_DECLINED;
     }

     if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
         if (u.err) {
             ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
-                          "\"ssl_stapling\" ignored, "
-                          "%s in OCSP responder \"%V\"", u.err, &u.url);
+                          "\"ssl_stapling\" ignored for \"%V\", "
+                          "%s in OCSP responder \"%V\"",
+                          cert_file, u.err, &u.url);
             return NGX_DECLINED;
         }

         return NGX_ERROR;
     }

-    staple->addrs = u.addrs;
-    staple->host = u.host;
-    staple->uri = u.uri;
-    staple->port = u.port;
+    cert_staple->addrs = u.addrs;
+    cert_staple->host = u.host;
+    cert_staple->uri = u.uri;
+    cert_staple->port = u.port;

-    if (staple->uri.len == 0) {
-        ngx_str_set(&staple->uri, "/");
+    if (cert_staple->uri.len == 0) {
+        ngx_str_set(&cert_staple->uri, "/");
     }

     return NGX_OK;
@@ -450,8 +466,11 @@
 {
     int                  rc;
     u_char              *p;
+    ngx_uint_t                i;
     ngx_connection_t    *c;
     ngx_ssl_stapling_t  *staple;
+    ngx_ssl_stapling_cert_t  *cert_staples, *cert_staple = NULL;
+    X509                     *cert;

     c = ngx_ssl_get_connection(ssl_conn);

@@ -461,60 +480,78 @@
     staple = data;
     rc = SSL_TLSEXT_ERR_NOACK;

-    if (staple->staple.len) {
+    /* lookup the stapling info for the server certificate that was sent */
+
+    cert = SSL_get_certificate(ssl_conn);
+    cert_staples = staple->cert_staples->elts;
+
+    for (i = 0; i < staple->cert_staples->nelts; i++) {
+        if (cert == (&cert_staples[i])->cert) {
+            cert_staple = &cert_staples[i];
+            break;
+        }
+    }
+
+    if (cert_staple == NULL) {
+        return rc;
+    }
+
+    if (cert_staple->staple.len) {
         /* we have to copy ocsp response as OpenSSL will free it by itself */

-        p = OPENSSL_malloc(staple->staple.len);
+        p = OPENSSL_malloc(cert_staple->staple.len);
         if (p == NULL) {
             ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, "OPENSSL_malloc() failed");
             return SSL_TLSEXT_ERR_NOACK;
         }

-        ngx_memcpy(p, staple->staple.data, staple->staple.len);
+        ngx_memcpy(p, cert_staple->staple.data, cert_staple->staple.len);

-        SSL_set_tlsext_status_ocsp_resp(ssl_conn, p, staple->staple.len);
+        SSL_set_tlsext_status_ocsp_resp(ssl_conn, p, cert_staple->staple.len);

         rc = SSL_TLSEXT_ERR_OK;
     }

-    ngx_ssl_stapling_update(staple);
+    ngx_ssl_stapling_update(staple, cert_staple);

     return rc;
 }


 static void
-ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple)
+ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple,
+    ngx_ssl_stapling_cert_t *cert_staple)
 {
     ngx_ssl_ocsp_ctx_t  *ctx;

-    if (staple->host.len == 0
-        || staple->loading || staple->valid >= ngx_time())
+    if (cert_staple->host.len == 0
+        || cert_staple->loading || cert_staple->valid >= ngx_time())
     {
         return;
     }

-    staple->loading = 1;
+    cert_staple->loading = 1;

     ctx = ngx_ssl_ocsp_start();
     if (ctx == NULL) {
         return;
     }

-    ctx->cert = staple->cert;
-    ctx->issuer = staple->issuer;
+    ctx->cert = cert_staple->cert;
+    ctx->issuer = cert_staple->issuer;

-    ctx->addrs = staple->addrs;
-    ctx->host = staple->host;
-    ctx->uri = staple->uri;
-    ctx->port = staple->port;
+    ctx->addrs = cert_staple->addrs;
+    ctx->host = cert_staple->host;
+    ctx->uri = cert_staple->uri;
+    ctx->port = cert_staple->port;
     ctx->timeout = staple->timeout;

     ctx->resolver = staple->resolver;
     ctx->resolver_timeout = staple->resolver_timeout;

     ctx->handler = ngx_ssl_stapling_ocsp_handler;
-    ctx->data = staple;
+    ctx->staple = staple;
+    ctx->cert_staple = cert_staple;

     ngx_ssl_ocsp_request(ctx);

@@ -534,13 +571,16 @@
     ngx_str_t              response;
     X509_STORE            *store;
     STACK_OF(X509)        *chain;
+    STACK_OF(X509)           *ichain = NULL;
     OCSP_CERTID           *id;
     OCSP_RESPONSE         *ocsp;
     OCSP_BASICRESP        *basic;
     ngx_ssl_stapling_t    *staple;
+    ngx_ssl_stapling_cert_t  *cert_staple;
     ASN1_GENERALIZEDTIME  *thisupdate, *nextupdate;

-    staple = ctx->data;
+    staple = ctx->staple;
+    cert_staple = ctx->cert_staple;
     ocsp = NULL;
     basic = NULL;
     id = NULL;
@@ -589,10 +629,19 @@
 #else
     chain = staple->ssl_ctx->extra_certs;
 #endif
+    if ((sk_X509_num(chain) <= 0) && (cert_staple->issuer != NULL)) {
+        ichain = sk_X509_new_null();
+        sk_X509_push(ichain, cert_staple->issuer);
+    }

-    if (OCSP_basic_verify(basic, chain, store,
-                          staple->verify ? OCSP_TRUSTOTHER : OCSP_NOVERIFY)
-        != 1)
+    if (OCSP_basic_verify(basic, ichain ? ichain : chain, store,
+                          staple->verify ? OCSP_TRUSTOTHER :
+                                           OCSP_NOVERIFY
+#if OPENSSL_VERSION_NUMBER < 0x10000000L
+        /* ECDSA/SHA-2 signature verification not supported */
+                                           | OCSP_NOSIGS
+#endif
+        ) == 0)
     {
         ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,
                       "OCSP_basic_verify() failed");
@@ -647,24 +696,28 @@
                    "ssl ocsp response, %s, %uz",
                    OCSP_cert_status_str(n), response.len);

-    if (staple->staple.data) {
-        ngx_free(staple->staple.data);
+    if (cert_staple->staple.data) {
+        ngx_free(cert_staple->staple.data);
     }

-    staple->staple = response;
+    cert_staple->staple = response;

 done:

-    staple->loading = 0;
-    staple->valid = ngx_time() + 3600; /* ssl_stapling_valid */
+    cert_staple->loading = 0;
+    cert_staple->valid = ngx_time() + 3600; /* ssl_stapling_valid */
+
+    if (ichain) {
+        sk_X509_free(chain);
+    }

     ngx_ssl_ocsp_done(ctx);
     return;

 error:

-    staple->loading = 0;
-    staple->valid = ngx_time() + 300; /* ssl_stapling_err_valid */
+    cert_staple->loading = 0;
+    cert_staple->valid = ngx_time() + 300; /* ssl_stapling_err_valid */

     if (id) {
         OCSP_CERTID_free(id);
@@ -678,6 +731,10 @@
         OCSP_RESPONSE_free(ocsp);
     }

+    if (ichain) {
+        sk_X509_free(chain);
+    }
+
     ngx_ssl_ocsp_done(ctx);
 }

@@ -686,13 +743,19 @@
 ngx_ssl_stapling_cleanup(void *data)
 {
     ngx_ssl_stapling_t  *staple = data;
+    ngx_ssl_stapling_cert_t  *cert_staples;
+    ngx_uint_t                i;

-    if (staple->issuer) {
-        X509_free(staple->issuer);
+    cert_staples = staple->cert_staples->elts;
+
+    for (i = 0; i < staple->cert_staples->nelts; i++) {
+        if ((&cert_staples[i])->issuer) {
+            X509_free((&cert_staples[i])->issuer);
     }

-    if (staple->staple.data) {
-        ngx_free(staple->staple.data);
+        if ((&cert_staples[i])->staple.data) {
+            ngx_free((&cert_staples[i])->staple.data);
+        }
     }
 }

@@ -1740,8 +1803,7 @@


 ngx_int_t
-ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file,
-    ngx_str_t *responder, ngx_uint_t verify)
+ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_uint_t verify)
 {
     ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
                   "\"ssl_stapling\" ignored, not supported");
@@ -1750,6 +1812,13 @@
 }

 ngx_int_t
+ngx_ssl_stapling_cert(ngx_conf_t *cf, ngx_ssl_t *ssl, X509 *issuer, X509 *cert,
+    ngx_str_t *cert_file, ngx_str_t *stapling_file, ngx_str_t *responder)
+{
+    return NGX_OK;
+}
+
+ngx_int_t
 ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
     ngx_resolver_t *resolver, ngx_msec_t resolver_timeout)
 {
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl_stapling.c.orig workspace/src/event/ngx_event_openssl_stapling.c.orig
--- sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl_stapling.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/event/ngx_event_openssl_stapling.c.orig	2014-03-28 20:55:34.000000000 -0700
@@ -0,0 +1,1760 @@
+
+/*
+ * Copyright (C) Maxim Dounin
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_event.h>
+#include <ngx_event_connect.h>
+
+
+#ifdef SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB
+
+
+typedef struct {
+    ngx_str_t                    staple;
+    ngx_msec_t                   timeout;
+
+    ngx_resolver_t              *resolver;
+    ngx_msec_t                   resolver_timeout;
+
+    ngx_addr_t                  *addrs;
+    ngx_str_t                    host;
+    ngx_str_t                    uri;
+    in_port_t                    port;
+
+    SSL_CTX                     *ssl_ctx;
+
+    X509                        *cert;
+    X509                        *issuer;
+
+    time_t                       valid;
+
+    unsigned                     verify:1;
+    unsigned                     loading:1;
+} ngx_ssl_stapling_t;
+
+
+typedef struct ngx_ssl_ocsp_ctx_s  ngx_ssl_ocsp_ctx_t;
+
+struct ngx_ssl_ocsp_ctx_s {
+    X509                        *cert;
+    X509                        *issuer;
+
+    ngx_uint_t                   naddrs;
+
+    ngx_addr_t                  *addrs;
+    ngx_str_t                    host;
+    ngx_str_t                    uri;
+    in_port_t                    port;
+
+    ngx_resolver_t              *resolver;
+    ngx_msec_t                   resolver_timeout;
+
+    ngx_msec_t                   timeout;
+
+    void                       (*handler)(ngx_ssl_ocsp_ctx_t *r);
+    void                        *data;
+
+    ngx_buf_t                   *request;
+    ngx_buf_t                   *response;
+    ngx_peer_connection_t        peer;
+
+    ngx_int_t                  (*process)(ngx_ssl_ocsp_ctx_t *r);
+
+    ngx_uint_t                   state;
+
+    ngx_uint_t                   code;
+    ngx_uint_t                   count;
+
+    ngx_uint_t                   done;
+
+    u_char                      *header_name_start;
+    u_char                      *header_name_end;
+    u_char                      *header_start;
+    u_char                      *header_end;
+
+    ngx_pool_t                  *pool;
+    ngx_log_t                   *log;
+};
+
+
+static ngx_int_t ngx_ssl_stapling_file(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_str_t *file);
+static ngx_int_t ngx_ssl_stapling_issuer(ngx_conf_t *cf, ngx_ssl_t *ssl);
+static ngx_int_t ngx_ssl_stapling_responder(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_str_t *responder);
+
+static int ngx_ssl_certificate_status_callback(ngx_ssl_conn_t *ssl_conn,
+    void *data);
+static void ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple);
+static void ngx_ssl_stapling_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx);
+
+static void ngx_ssl_stapling_cleanup(void *data);
+
+static ngx_ssl_ocsp_ctx_t *ngx_ssl_ocsp_start(void);
+static void ngx_ssl_ocsp_done(ngx_ssl_ocsp_ctx_t *ctx);
+static void ngx_ssl_ocsp_request(ngx_ssl_ocsp_ctx_t *ctx);
+static void ngx_ssl_ocsp_resolve_handler(ngx_resolver_ctx_t *resolve);
+static void ngx_ssl_ocsp_connect(ngx_ssl_ocsp_ctx_t *ctx);
+static void ngx_ssl_ocsp_write_handler(ngx_event_t *wev);
+static void ngx_ssl_ocsp_read_handler(ngx_event_t *rev);
+static void ngx_ssl_ocsp_dummy_handler(ngx_event_t *ev);
+
+static ngx_int_t ngx_ssl_ocsp_create_request(ngx_ssl_ocsp_ctx_t *ctx);
+static ngx_int_t ngx_ssl_ocsp_process_status_line(ngx_ssl_ocsp_ctx_t *ctx);
+static ngx_int_t ngx_ssl_ocsp_parse_status_line(ngx_ssl_ocsp_ctx_t *ctx);
+static ngx_int_t ngx_ssl_ocsp_process_headers(ngx_ssl_ocsp_ctx_t *ctx);
+static ngx_int_t ngx_ssl_ocsp_parse_header_line(ngx_ssl_ocsp_ctx_t *ctx);
+static ngx_int_t ngx_ssl_ocsp_process_body(ngx_ssl_ocsp_ctx_t *ctx);
+
+static u_char *ngx_ssl_ocsp_log_error(ngx_log_t *log, u_char *buf, size_t len);
+
+
+ngx_int_t
+ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file,
+    ngx_str_t *responder, ngx_uint_t verify)
+{
+    ngx_int_t                  rc;
+    ngx_pool_cleanup_t        *cln;
+    ngx_ssl_stapling_t        *staple;
+
+    staple = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_stapling_t));
+    if (staple == NULL) {
+        return NGX_ERROR;
+    }
+
+    cln = ngx_pool_cleanup_add(cf->pool, 0);
+    if (cln == NULL) {
+        return NGX_ERROR;
+    }
+
+    cln->handler = ngx_ssl_stapling_cleanup;
+    cln->data = staple;
+
+    if (SSL_CTX_set_ex_data(ssl->ctx, ngx_ssl_stapling_index, staple)
+        == 0)
+    {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "SSL_CTX_set_ex_data() failed");
+        return NGX_ERROR;
+    }
+
+    staple->ssl_ctx = ssl->ctx;
+    staple->timeout = 60000;
+    staple->verify = verify;
+
+    if (file->len) {
+        /* use OCSP response from the file */
+
+        if (ngx_ssl_stapling_file(cf, ssl, file) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        goto done;
+    }
+
+    rc = ngx_ssl_stapling_issuer(cf, ssl);
+
+    if (rc == NGX_DECLINED) {
+        return NGX_OK;
+    }
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    rc = ngx_ssl_stapling_responder(cf, ssl, responder);
+
+    if (rc == NGX_DECLINED) {
+        return NGX_OK;
+    }
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+done:
+
+    SSL_CTX_set_tlsext_status_cb(ssl->ctx, ngx_ssl_certificate_status_callback);
+    SSL_CTX_set_tlsext_status_arg(ssl->ctx, staple);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_ssl_stapling_file(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)
+{
+    BIO                 *bio;
+    int                  len;
+    u_char              *p, *buf;
+    OCSP_RESPONSE       *response;
+    ngx_ssl_stapling_t  *staple;
+
+    staple = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_stapling_index);
+
+    if (ngx_conf_full_name(cf->cycle, file, 1) != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    bio = BIO_new_file((char *) file->data, "r");
+    if (bio == NULL) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "BIO_new_file(\"%s\") failed", file->data);
+        return NGX_ERROR;
+    }
+
+    response = d2i_OCSP_RESPONSE_bio(bio, NULL);
+    if (response == NULL) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "d2i_OCSP_RESPONSE_bio(\"%s\") failed", file->data);
+        BIO_free(bio);
+        return NGX_ERROR;
+    }
+
+    len = i2d_OCSP_RESPONSE(response, NULL);
+    if (len <= 0) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "i2d_OCSP_RESPONSE(\"%s\") failed", file->data);
+        goto failed;
+    }
+
+    buf = ngx_alloc(len, ssl->log);
+    if (buf == NULL) {
+        goto failed;
+    }
+
+    p = buf;
+    len = i2d_OCSP_RESPONSE(response, &p);
+    if (len <= 0) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "i2d_OCSP_RESPONSE(\"%s\") failed", file->data);
+        ngx_free(buf);
+        goto failed;
+    }
+
+    OCSP_RESPONSE_free(response);
+    BIO_free(bio);
+
+    staple->staple.data = buf;
+    staple->staple.len = len;
+
+    return NGX_OK;
+
+failed:
+
+    OCSP_RESPONSE_free(response);
+    BIO_free(bio);
+
+    return NGX_ERROR;
+}
+
+
+static ngx_int_t
+ngx_ssl_stapling_issuer(ngx_conf_t *cf, ngx_ssl_t *ssl)
+{
+    int                  i, n, rc;
+    X509                *cert, *issuer;
+    X509_STORE          *store;
+    X509_STORE_CTX      *store_ctx;
+    STACK_OF(X509)      *chain;
+    ngx_ssl_stapling_t  *staple;
+
+    staple = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_stapling_index);
+    cert = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_certificate_index);
+
+#if OPENSSL_VERSION_NUMBER >= 0x10001000L
+    SSL_CTX_get_extra_chain_certs(ssl->ctx, &chain);
+#else
+    chain = ssl->ctx->extra_certs;
+#endif
+
+    n = sk_X509_num(chain);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
+                   "SSL get issuer: %d extra certs", n);
+
+    for (i = 0; i < n; i++) {
+        issuer = sk_X509_value(chain, i);
+        if (X509_check_issued(issuer, cert) == X509_V_OK) {
+            CRYPTO_add(&issuer->references, 1, CRYPTO_LOCK_X509);
+
+            ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
+                           "SSL get issuer: found %p in extra certs", issuer);
+
+            staple->cert = cert;
+            staple->issuer = issuer;
+
+            return NGX_OK;
+        }
+    }
+
+    store = SSL_CTX_get_cert_store(ssl->ctx);
+    if (store == NULL) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "SSL_CTX_get_cert_store() failed");
+        return NGX_ERROR;
+    }
+
+    store_ctx = X509_STORE_CTX_new();
+    if (store_ctx == NULL) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "X509_STORE_CTX_new() failed");
+        return NGX_ERROR;
+    }
+
+    if (X509_STORE_CTX_init(store_ctx, store, NULL, NULL) == 0) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "X509_STORE_CTX_init() failed");
+        return NGX_ERROR;
+    }
+
+    rc = X509_STORE_CTX_get1_issuer(&issuer, store_ctx, cert);
+
+    if (rc == -1) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "X509_STORE_CTX_get1_issuer() failed");
+        X509_STORE_CTX_free(store_ctx);
+        return NGX_ERROR;
+    }
+
+    if (rc == 0) {
+        ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+                      "\"ssl_stapling\" ignored, issuer certificate not found");
+        X509_STORE_CTX_free(store_ctx);
+        return NGX_DECLINED;
+    }
+
+    X509_STORE_CTX_free(store_ctx);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
+                   "SSL get issuer: found %p in cert store", issuer);
+
+    staple->cert = cert;
+    staple->issuer = issuer;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_ssl_stapling_responder(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder)
+{
+    ngx_url_t                  u;
+    char                      *s;
+    ngx_ssl_stapling_t        *staple;
+    STACK_OF(OPENSSL_STRING)  *aia;
+
+    staple = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_stapling_index);
+
+    if (responder->len == 0) {
+
+        /* extract OCSP responder URL from certificate */
+
+        aia = X509_get1_ocsp(staple->cert);
+        if (aia == NULL) {
+            ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+                          "\"ssl_stapling\" ignored, "
+                          "no OCSP responder URL in the certificate");
+            return NGX_DECLINED;
+        }
+
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+        s = sk_OPENSSL_STRING_value(aia, 0);
+#else
+        s = sk_value(aia, 0);
+#endif
+        if (s == NULL) {
+            ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+                          "\"ssl_stapling\" ignored, "
+                          "no OCSP responder URL in the certificate");
+            X509_email_free(aia);
+            return NGX_DECLINED;
+        }
+
+        responder->len = ngx_strlen(s);
+        responder->data = ngx_palloc(cf->pool, responder->len);
+        if (responder->data == NULL) {
+            X509_email_free(aia);
+            return NGX_ERROR;
+        }
+
+        ngx_memcpy(responder->data, s, responder->len);
+        X509_email_free(aia);
+    }
+
+    ngx_memzero(&u, sizeof(ngx_url_t));
+
+    u.url = *responder;
+    u.default_port = 80;
+    u.uri_part = 1;
+
+    if (u.url.len > 7
+        && ngx_strncasecmp(u.url.data, (u_char *) "http://", 7) == 0)
+    {
+        u.url.len -= 7;
+        u.url.data += 7;
+
+    } else {
+        ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+                      "\"ssl_stapling\" ignored, "
+                      "invalid URL prefix in OCSP responder \"%V\"", &u.url);
+        return NGX_DECLINED;
+    }
+
+    if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
+        if (u.err) {
+            ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+                          "\"ssl_stapling\" ignored, "
+                          "%s in OCSP responder \"%V\"", u.err, &u.url);
+            return NGX_DECLINED;
+        }
+
+        return NGX_ERROR;
+    }
+
+    staple->addrs = u.addrs;
+    staple->host = u.host;
+    staple->uri = u.uri;
+    staple->port = u.port;
+
+    if (staple->uri.len == 0) {
+        ngx_str_set(&staple->uri, "/");
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout)
+{
+    ngx_ssl_stapling_t  *staple;
+
+    staple = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_stapling_index);
+
+    staple->resolver = resolver;
+    staple->resolver_timeout = resolver_timeout;
+
+    return NGX_OK;
+}
+
+
+static int
+ngx_ssl_certificate_status_callback(ngx_ssl_conn_t *ssl_conn, void *data)
+{
+    int                  rc;
+    u_char              *p;
+    ngx_connection_t    *c;
+    ngx_ssl_stapling_t  *staple;
+
+    c = ngx_ssl_get_connection(ssl_conn);
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                   "SSL certificate status callback");
+
+    staple = data;
+    rc = SSL_TLSEXT_ERR_NOACK;
+
+    if (staple->staple.len) {
+        /* we have to copy ocsp response as OpenSSL will free it by itself */
+
+        p = OPENSSL_malloc(staple->staple.len);
+        if (p == NULL) {
+            ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, "OPENSSL_malloc() failed");
+            return SSL_TLSEXT_ERR_NOACK;
+        }
+
+        ngx_memcpy(p, staple->staple.data, staple->staple.len);
+
+        SSL_set_tlsext_status_ocsp_resp(ssl_conn, p, staple->staple.len);
+
+        rc = SSL_TLSEXT_ERR_OK;
+    }
+
+    ngx_ssl_stapling_update(staple);
+
+    return rc;
+}
+
+
+static void
+ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple)
+{
+    ngx_ssl_ocsp_ctx_t  *ctx;
+
+    if (staple->host.len == 0
+        || staple->loading || staple->valid >= ngx_time())
+    {
+        return;
+    }
+
+    staple->loading = 1;
+
+    ctx = ngx_ssl_ocsp_start();
+    if (ctx == NULL) {
+        return;
+    }
+
+    ctx->cert = staple->cert;
+    ctx->issuer = staple->issuer;
+
+    ctx->addrs = staple->addrs;
+    ctx->host = staple->host;
+    ctx->uri = staple->uri;
+    ctx->port = staple->port;
+    ctx->timeout = staple->timeout;
+
+    ctx->resolver = staple->resolver;
+    ctx->resolver_timeout = staple->resolver_timeout;
+
+    ctx->handler = ngx_ssl_stapling_ocsp_handler;
+    ctx->data = staple;
+
+    ngx_ssl_ocsp_request(ctx);
+
+    return;
+}
+
+
+static void
+ngx_ssl_stapling_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)
+{
+#if OPENSSL_VERSION_NUMBER >= 0x0090707fL
+    const
+#endif
+    u_char                *p;
+    int                    n;
+    size_t                 len;
+    ngx_str_t              response;
+    X509_STORE            *store;
+    STACK_OF(X509)        *chain;
+    OCSP_CERTID           *id;
+    OCSP_RESPONSE         *ocsp;
+    OCSP_BASICRESP        *basic;
+    ngx_ssl_stapling_t    *staple;
+    ASN1_GENERALIZEDTIME  *thisupdate, *nextupdate;
+
+    staple = ctx->data;
+    ocsp = NULL;
+    basic = NULL;
+    id = NULL;
+
+    if (ctx->code != 200) {
+        goto error;
+    }
+
+    /* check the response */
+
+    len = ctx->response->last - ctx->response->pos;
+    p = ctx->response->pos;
+
+    ocsp = d2i_OCSP_RESPONSE(NULL, &p, len);
+    if (ocsp == NULL) {
+        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,
+                      "d2i_OCSP_RESPONSE() failed");
+        goto error;
+    }
+
+    n = OCSP_response_status(ocsp);
+
+    if (n != OCSP_RESPONSE_STATUS_SUCCESSFUL) {
+        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,
+                      "OCSP response not successful (%d: %s)",
+                      n, OCSP_response_status_str(n));
+        goto error;
+    }
+
+    basic = OCSP_response_get1_basic(ocsp);
+    if (basic == NULL) {
+        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,
+                      "OCSP_response_get1_basic() failed");
+        goto error;
+    }
+
+    store = SSL_CTX_get_cert_store(staple->ssl_ctx);
+    if (store == NULL) {
+        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,
+                      "SSL_CTX_get_cert_store() failed");
+        goto error;
+    }
+
+#if OPENSSL_VERSION_NUMBER >= 0x10001000L
+    SSL_CTX_get_extra_chain_certs(staple->ssl_ctx, &chain);
+#else
+    chain = staple->ssl_ctx->extra_certs;
+#endif
+
+    if (OCSP_basic_verify(basic, chain, store,
+                          staple->verify ? OCSP_TRUSTOTHER : OCSP_NOVERIFY)
+        != 1)
+    {
+        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,
+                      "OCSP_basic_verify() failed");
+        goto error;
+    }
+
+    id = OCSP_cert_to_id(NULL, ctx->cert, ctx->issuer);
+    if (id == NULL) {
+        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,
+                      "OCSP_cert_to_id() failed");
+        goto error;
+    }
+
+    if (OCSP_resp_find_status(basic, id, &n, NULL, NULL,
+                              &thisupdate, &nextupdate)
+        != 1)
+    {
+        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,
+                      "certificate status not found in the OCSP response");
+        goto error;
+    }
+
+    if (n != V_OCSP_CERTSTATUS_GOOD) {
+        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,
+                      "certificate status \"%s\" in the OCSP response",
+                      OCSP_cert_status_str(n));
+        goto error;
+    }
+
+    if (OCSP_check_validity(thisupdate, nextupdate, 300, -1) != 1) {
+        ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,
+                      "OCSP_check_validity() failed");
+        goto error;
+    }
+
+    OCSP_CERTID_free(id);
+    OCSP_BASICRESP_free(basic);
+    OCSP_RESPONSE_free(ocsp);
+
+    /* copy the response to memory not in ctx->pool */
+
+    response.len = len;
+    response.data = ngx_alloc(response.len, ctx->log);
+
+    if (response.data == NULL) {
+        goto done;
+    }
+
+    ngx_memcpy(response.data, ctx->response->pos, response.len);
+
+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                   "ssl ocsp response, %s, %uz",
+                   OCSP_cert_status_str(n), response.len);
+
+    if (staple->staple.data) {
+        ngx_free(staple->staple.data);
+    }
+
+    staple->staple = response;
+
+done:
+
+    staple->loading = 0;
+    staple->valid = ngx_time() + 3600; /* ssl_stapling_valid */
+
+    ngx_ssl_ocsp_done(ctx);
+    return;
+
+error:
+
+    staple->loading = 0;
+    staple->valid = ngx_time() + 300; /* ssl_stapling_err_valid */
+
+    if (id) {
+        OCSP_CERTID_free(id);
+    }
+
+    if (basic) {
+        OCSP_BASICRESP_free(basic);
+    }
+
+    if (ocsp) {
+        OCSP_RESPONSE_free(ocsp);
+    }
+
+    ngx_ssl_ocsp_done(ctx);
+}
+
+
+static void
+ngx_ssl_stapling_cleanup(void *data)
+{
+    ngx_ssl_stapling_t  *staple = data;
+
+    if (staple->issuer) {
+        X509_free(staple->issuer);
+    }
+
+    if (staple->staple.data) {
+        ngx_free(staple->staple.data);
+    }
+}
+
+
+static ngx_ssl_ocsp_ctx_t *
+ngx_ssl_ocsp_start(void)
+{
+    ngx_log_t           *log;
+    ngx_pool_t          *pool;
+    ngx_ssl_ocsp_ctx_t  *ctx;
+
+    pool = ngx_create_pool(2048, ngx_cycle->log);
+    if (pool == NULL) {
+        return NULL;
+    }
+
+    ctx = ngx_pcalloc(pool, sizeof(ngx_ssl_ocsp_ctx_t));
+    if (ctx == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+    log = ngx_palloc(pool, sizeof(ngx_log_t));
+    if (log == NULL) {
+        ngx_destroy_pool(pool);
+        return NULL;
+    }
+
+    ctx->pool = pool;
+
+    *log = *ctx->pool->log;
+
+    ctx->pool->log = log;
+    ctx->log = log;
+
+    log->handler = ngx_ssl_ocsp_log_error;
+    log->data = ctx;
+    log->action = "requesting certificate status";
+
+    return ctx;
+}
+
+
+static void
+ngx_ssl_ocsp_done(ngx_ssl_ocsp_ctx_t *ctx)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                   "ssl ocsp done");
+
+    if (ctx->peer.connection) {
+        ngx_close_connection(ctx->peer.connection);
+    }
+
+    ngx_destroy_pool(ctx->pool);
+}
+
+
+static void
+ngx_ssl_ocsp_error(ngx_ssl_ocsp_ctx_t *ctx)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                   "ssl ocsp error");
+
+    ctx->code = 0;
+    ctx->handler(ctx);
+}
+
+
+static void
+ngx_ssl_ocsp_request(ngx_ssl_ocsp_ctx_t *ctx)
+{
+    ngx_resolver_ctx_t  *resolve, temp;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                   "ssl ocsp request");
+
+    if (ngx_ssl_ocsp_create_request(ctx) != NGX_OK) {
+        ngx_ssl_ocsp_error(ctx);
+        return;
+    }
+
+    if (ctx->resolver) {
+        /* resolve OCSP responder hostname */
+
+        temp.name = ctx->host;
+
+        resolve = ngx_resolve_start(ctx->resolver, &temp);
+        if (resolve == NULL) {
+            ngx_ssl_ocsp_error(ctx);
+            return;
+        }
+
+        if (resolve == NGX_NO_RESOLVER) {
+            ngx_log_error(NGX_LOG_WARN, ctx->log, 0,
+                          "no resolver defined to resolve %V", &ctx->host);
+            goto connect;
+        }
+
+        resolve->name = ctx->host;
+        resolve->handler = ngx_ssl_ocsp_resolve_handler;
+        resolve->data = ctx;
+        resolve->timeout = ctx->resolver_timeout;
+
+        if (ngx_resolve_name(resolve) != NGX_OK) {
+            ngx_ssl_ocsp_error(ctx);
+            return;
+        }
+
+        return;
+    }
+
+connect:
+
+    ngx_ssl_ocsp_connect(ctx);
+}
+
+
+static void
+ngx_ssl_ocsp_resolve_handler(ngx_resolver_ctx_t *resolve)
+{
+    ngx_ssl_ocsp_ctx_t *ctx = resolve->data;
+
+    u_char           *p;
+    size_t            len;
+    in_port_t         port;
+    socklen_t         socklen;
+    ngx_uint_t        i;
+    struct sockaddr  *sockaddr;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                   "ssl ocsp resolve handler");
+
+    if (resolve->state) {
+        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,
+                      "%V could not be resolved (%i: %s)",
+                      &resolve->name, resolve->state,
+                      ngx_resolver_strerror(resolve->state));
+        goto failed;
+    }
+
+#if (NGX_DEBUG)
+    {
+    u_char     text[NGX_SOCKADDR_STRLEN];
+    ngx_str_t  addr;
+
+    addr.data = text;
+
+    for (i = 0; i < resolve->naddrs; i++) {
+        addr.len = ngx_sock_ntop(resolve->addrs[i].sockaddr,
+                                 resolve->addrs[i].socklen,
+                                 text, NGX_SOCKADDR_STRLEN, 0);
+
+        ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                       "name was resolved to %V", &addr);
+
+    }
+    }
+#endif
+
+    ctx->naddrs = resolve->naddrs;
+    ctx->addrs = ngx_pcalloc(ctx->pool, ctx->naddrs * sizeof(ngx_addr_t));
+
+    if (ctx->addrs == NULL) {
+        goto failed;
+    }
+
+    port = htons(ctx->port);
+
+    for (i = 0; i < resolve->naddrs; i++) {
+
+        socklen = resolve->addrs[i].socklen;
+
+        sockaddr = ngx_palloc(ctx->pool, socklen);
+        if (sockaddr == NULL) {
+            goto failed;
+        }
+
+        ngx_memcpy(sockaddr, resolve->addrs[i].sockaddr, socklen);
+
+        switch (sockaddr->sa_family) {
+#if (NGX_HAVE_INET6)
+        case AF_INET6:
+            ((struct sockaddr_in6 *) sockaddr)->sin6_port = port;
+            break;
+#endif
+        default: /* AF_INET */
+            ((struct sockaddr_in *) sockaddr)->sin_port = port;
+        }
+
+        ctx->addrs[i].sockaddr = sockaddr;
+        ctx->addrs[i].socklen = socklen;
+
+        p = ngx_pnalloc(ctx->pool, NGX_SOCKADDR_STRLEN);
+        if (p == NULL) {
+            goto failed;
+        }
+
+        len = ngx_sock_ntop(sockaddr, socklen, p, NGX_SOCKADDR_STRLEN, 1);
+
+        ctx->addrs[i].name.len = len;
+        ctx->addrs[i].name.data = p;
+    }
+
+    ngx_resolve_name_done(resolve);
+
+    ngx_ssl_ocsp_connect(ctx);
+    return;
+
+failed:
+
+    ngx_resolve_name_done(resolve);
+    ngx_ssl_ocsp_error(ctx);
+}
+
+
+static void
+ngx_ssl_ocsp_connect(ngx_ssl_ocsp_ctx_t *ctx)
+{
+    ngx_int_t    rc;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                   "ssl ocsp connect");
+
+    /* TODO: use all ip addresses */
+
+    ctx->peer.sockaddr = ctx->addrs[0].sockaddr;
+    ctx->peer.socklen = ctx->addrs[0].socklen;
+    ctx->peer.name = &ctx->addrs[0].name;
+    ctx->peer.get = ngx_event_get_peer;
+    ctx->peer.log = ctx->log;
+    ctx->peer.log_error = NGX_ERROR_ERR;
+
+    rc = ngx_event_connect_peer(&ctx->peer);
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                   "ssl ocsp connect peer done");
+
+    if (rc == NGX_ERROR || rc == NGX_BUSY || rc == NGX_DECLINED) {
+        ngx_ssl_ocsp_error(ctx);
+        return;
+    }
+
+    ctx->peer.connection->data = ctx;
+    ctx->peer.connection->pool = ctx->pool;
+
+    ctx->peer.connection->read->handler = ngx_ssl_ocsp_read_handler;
+    ctx->peer.connection->write->handler = ngx_ssl_ocsp_write_handler;
+
+    ctx->process = ngx_ssl_ocsp_process_status_line;
+
+    ngx_add_timer(ctx->peer.connection->read, ctx->timeout);
+    ngx_add_timer(ctx->peer.connection->write, ctx->timeout);
+
+    if (rc == NGX_OK) {
+        ngx_ssl_ocsp_write_handler(ctx->peer.connection->write);
+        return;
+    }
+}
+
+
+static void
+ngx_ssl_ocsp_write_handler(ngx_event_t *wev)
+{
+    ssize_t              n, size;
+    ngx_connection_t    *c;
+    ngx_ssl_ocsp_ctx_t  *ctx;
+
+    c = wev->data;
+    ctx = c->data;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, wev->log, 0,
+                   "ssl ocsp write handler");
+
+    if (wev->timedout) {
+        ngx_log_error(NGX_LOG_ERR, wev->log, NGX_ETIMEDOUT,
+                      "OCSP responder timed out");
+        ngx_ssl_ocsp_error(ctx);
+        return;
+    }
+
+    size = ctx->request->last - ctx->request->pos;
+
+    n = ngx_send(c, ctx->request->pos, size);
+
+    if (n == NGX_ERROR) {
+        ngx_ssl_ocsp_error(ctx);
+        return;
+    }
+
+    if (n > 0) {
+        ctx->request->pos += n;
+
+        if (n == size) {
+            wev->handler = ngx_ssl_ocsp_dummy_handler;
+
+            if (wev->timer_set) {
+                ngx_del_timer(wev);
+            }
+
+            if (ngx_handle_write_event(wev, 0) != NGX_OK) {
+                ngx_ssl_ocsp_error(ctx);
+            }
+
+            return;
+        }
+    }
+
+    if (!wev->timer_set) {
+        ngx_add_timer(wev, ctx->timeout);
+    }
+}
+
+
+static void
+ngx_ssl_ocsp_read_handler(ngx_event_t *rev)
+{
+    ssize_t            n, size;
+    ngx_int_t          rc;
+    ngx_ssl_ocsp_ctx_t    *ctx;
+    ngx_connection_t  *c;
+
+    c = rev->data;
+    ctx = c->data;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, rev->log, 0,
+                   "ssl ocsp read handler");
+
+    if (rev->timedout) {
+        ngx_log_error(NGX_LOG_ERR, rev->log, NGX_ETIMEDOUT,
+                      "OCSP responder timed out");
+        ngx_ssl_ocsp_error(ctx);
+        return;
+    }
+
+    if (ctx->response == NULL) {
+        ctx->response = ngx_create_temp_buf(ctx->pool, 16384);
+        if (ctx->response == NULL) {
+            ngx_ssl_ocsp_error(ctx);
+            return;
+        }
+    }
+
+    for ( ;; ) {
+
+        size = ctx->response->end - ctx->response->last;
+
+        n = ngx_recv(c, ctx->response->last, size);
+
+        if (n > 0) {
+            ctx->response->last += n;
+
+            rc = ctx->process(ctx);
+
+            if (rc == NGX_ERROR) {
+                ngx_ssl_ocsp_error(ctx);
+                return;
+            }
+
+            continue;
+        }
+
+        if (n == NGX_AGAIN) {
+
+            if (ngx_handle_read_event(rev, 0) != NGX_OK) {
+                ngx_ssl_ocsp_error(ctx);
+            }
+
+            return;
+        }
+
+        break;
+    }
+
+    ctx->done = 1;
+
+    rc = ctx->process(ctx);
+
+    if (rc == NGX_DONE) {
+        /* ctx->handler() was called */
+        return;
+    }
+
+    ngx_log_error(NGX_LOG_ERR, ctx->log, 0,
+                  "OCSP responder prematurely closed connection");
+
+    ngx_ssl_ocsp_error(ctx);
+}
+
+
+static void
+ngx_ssl_ocsp_dummy_handler(ngx_event_t *ev)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ev->log, 0,
+                   "ssl ocsp dummy handler");
+}
+
+
+static ngx_int_t
+ngx_ssl_ocsp_create_request(ngx_ssl_ocsp_ctx_t *ctx)
+{
+    int            len;
+    u_char        *p;
+    uintptr_t      escape;
+    ngx_str_t      binary, base64;
+    ngx_buf_t     *b;
+    OCSP_CERTID   *id;
+    OCSP_REQUEST  *ocsp;
+
+    ocsp = OCSP_REQUEST_new();
+    if (ocsp == NULL) {
+        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,
+                      "OCSP_REQUEST_new() failed");
+        return NGX_ERROR;
+    }
+
+    id = OCSP_cert_to_id(NULL, ctx->cert, ctx->issuer);
+    if (id == NULL) {
+        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,
+                      "OCSP_cert_to_id() failed");
+        goto failed;
+    }
+
+    if (OCSP_request_add0_id(ocsp, id) == NULL) {
+        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,
+                      "OCSP_request_add0_id() failed");
+        goto failed;
+    }
+
+    len = i2d_OCSP_REQUEST(ocsp, NULL);
+    if (len <= 0) {
+        ngx_ssl_error(NGX_LOG_CRIT, ctx->log, 0,
+                      "i2d_OCSP_REQUEST() failed");
+        goto failed;
+    }
+
+    binary.len = len;
+    binary.data = ngx_palloc(ctx->pool, len);
+    if (binary.data == NULL) {
+        goto failed;
+    }
+
+    p = binary.data;
+    len = i2d_OCSP_REQUEST(ocsp, &p);
+    if (len <= 0) {
+        ngx_ssl_error(NGX_LOG_EMERG, ctx->log, 0,
+                      "i2d_OCSP_REQUEST() failed");
+        goto failed;
+    }
+
+    base64.len = ngx_base64_encoded_length(binary.len);
+    base64.data = ngx_palloc(ctx->pool, base64.len);
+    if (base64.data == NULL) {
+        goto failed;
+    }
+
+    ngx_encode_base64(&base64, &binary);
+
+    escape = ngx_escape_uri(NULL, base64.data, base64.len,
+                            NGX_ESCAPE_URI_COMPONENT);
+
+    ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                   "ssl ocsp request length %z, escape %d",
+                   base64.len, escape);
+
+    len = sizeof("GET ") - 1 + ctx->uri.len + sizeof("/") - 1
+          + base64.len + 2 * escape + sizeof(" HTTP/1.0" CRLF) - 1
+          + sizeof("Host: ") - 1 + ctx->host.len + sizeof(CRLF) - 1
+          + sizeof(CRLF) - 1;
+
+    b = ngx_create_temp_buf(ctx->pool, len);
+    if (b == NULL) {
+        goto failed;
+    }
+
+    p = b->last;
+
+    p = ngx_cpymem(p, "GET ", sizeof("GET ") - 1);
+    p = ngx_cpymem(p, ctx->uri.data, ctx->uri.len);
+
+    if (ctx->uri.data[ctx->uri.len - 1] != '/') {
+        *p++ = '/';
+    }
+
+    if (escape == 0) {
+        p = ngx_cpymem(p, base64.data, base64.len);
+
+    } else {
+        p = (u_char *) ngx_escape_uri(p, base64.data, base64.len,
+                                      NGX_ESCAPE_URI_COMPONENT);
+    }
+
+    p = ngx_cpymem(p, " HTTP/1.0" CRLF, sizeof(" HTTP/1.0" CRLF) - 1);
+    p = ngx_cpymem(p, "Host: ", sizeof("Host: ") - 1);
+    p = ngx_cpymem(p, ctx->host.data, ctx->host.len);
+    *p++ = CR; *p++ = LF;
+
+    /* add "\r\n" at the header end */
+    *p++ = CR; *p++ = LF;
+
+    b->last = p;
+    ctx->request = b;
+
+    return NGX_OK;
+
+failed:
+
+    OCSP_REQUEST_free(ocsp);
+
+    return NGX_ERROR;
+}
+
+
+static ngx_int_t
+ngx_ssl_ocsp_process_status_line(ngx_ssl_ocsp_ctx_t *ctx)
+{
+    ngx_int_t  rc;
+
+    rc = ngx_ssl_ocsp_parse_status_line(ctx);
+
+    if (rc == NGX_OK) {
+#if 0
+        ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                       "ssl ocsp status line \"%*s\"",
+                       ctx->response->pos - ctx->response->start,
+                       ctx->response->start);
+#endif
+
+        ctx->process = ngx_ssl_ocsp_process_headers;
+        return ctx->process(ctx);
+    }
+
+    if (rc == NGX_AGAIN) {
+        return NGX_AGAIN;
+    }
+
+    /* rc == NGX_ERROR */
+
+    ngx_log_error(NGX_LOG_ERR, ctx->log, 0,
+                  "OCSP responder sent invalid response");
+
+    return NGX_ERROR;
+}
+
+
+static ngx_int_t
+ngx_ssl_ocsp_parse_status_line(ngx_ssl_ocsp_ctx_t *ctx)
+{
+    u_char      ch;
+    u_char     *p;
+    ngx_buf_t  *b;
+    enum {
+        sw_start = 0,
+        sw_H,
+        sw_HT,
+        sw_HTT,
+        sw_HTTP,
+        sw_first_major_digit,
+        sw_major_digit,
+        sw_first_minor_digit,
+        sw_minor_digit,
+        sw_status,
+        sw_space_after_status,
+        sw_status_text,
+        sw_almost_done
+    } state;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                   "ssl ocsp process status line");
+
+    state = ctx->state;
+    b = ctx->response;
+
+    for (p = b->pos; p < b->last; p++) {
+        ch = *p;
+
+        switch (state) {
+
+        /* "HTTP/" */
+        case sw_start:
+            switch (ch) {
+            case 'H':
+                state = sw_H;
+                break;
+            default:
+                return NGX_ERROR;
+            }
+            break;
+
+        case sw_H:
+            switch (ch) {
+            case 'T':
+                state = sw_HT;
+                break;
+            default:
+                return NGX_ERROR;
+            }
+            break;
+
+        case sw_HT:
+            switch (ch) {
+            case 'T':
+                state = sw_HTT;
+                break;
+            default:
+                return NGX_ERROR;
+            }
+            break;
+
+        case sw_HTT:
+            switch (ch) {
+            case 'P':
+                state = sw_HTTP;
+                break;
+            default:
+                return NGX_ERROR;
+            }
+            break;
+
+        case sw_HTTP:
+            switch (ch) {
+            case '/':
+                state = sw_first_major_digit;
+                break;
+            default:
+                return NGX_ERROR;
+            }
+            break;
+
+        /* the first digit of major HTTP version */
+        case sw_first_major_digit:
+            if (ch < '1' || ch > '9') {
+                return NGX_ERROR;
+            }
+
+            state = sw_major_digit;
+            break;
+
+        /* the major HTTP version or dot */
+        case sw_major_digit:
+            if (ch == '.') {
+                state = sw_first_minor_digit;
+                break;
+            }
+
+            if (ch < '0' || ch > '9') {
+                return NGX_ERROR;
+            }
+
+            break;
+
+        /* the first digit of minor HTTP version */
+        case sw_first_minor_digit:
+            if (ch < '0' || ch > '9') {
+                return NGX_ERROR;
+            }
+
+            state = sw_minor_digit;
+            break;
+
+        /* the minor HTTP version or the end of the request line */
+        case sw_minor_digit:
+            if (ch == ' ') {
+                state = sw_status;
+                break;
+            }
+
+            if (ch < '0' || ch > '9') {
+                return NGX_ERROR;
+            }
+
+            break;
+
+        /* HTTP status code */
+        case sw_status:
+            if (ch == ' ') {
+                break;
+            }
+
+            if (ch < '0' || ch > '9') {
+                return NGX_ERROR;
+            }
+
+            ctx->code = ctx->code * 10 + ch - '0';
+
+            if (++ctx->count == 3) {
+                state = sw_space_after_status;
+            }
+
+            break;
+
+        /* space or end of line */
+        case sw_space_after_status:
+            switch (ch) {
+            case ' ':
+                state = sw_status_text;
+                break;
+            case '.':                    /* IIS may send 403.1, 403.2, etc */
+                state = sw_status_text;
+                break;
+            case CR:
+                state = sw_almost_done;
+                break;
+            case LF:
+                goto done;
+            default:
+                return NGX_ERROR;
+            }
+            break;
+
+        /* any text until end of line */
+        case sw_status_text:
+            switch (ch) {
+            case CR:
+                state = sw_almost_done;
+                break;
+            case LF:
+                goto done;
+            }
+            break;
+
+        /* end of status line */
+        case sw_almost_done:
+            switch (ch) {
+            case LF:
+                goto done;
+            default:
+                return NGX_ERROR;
+            }
+        }
+    }
+
+    b->pos = p;
+    ctx->state = state;
+
+    return NGX_AGAIN;
+
+done:
+
+    b->pos = p + 1;
+    ctx->state = sw_start;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_ssl_ocsp_process_headers(ngx_ssl_ocsp_ctx_t *ctx)
+{
+    size_t     len;
+    ngx_int_t  rc;
+
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                   "ssl ocsp process headers");
+
+    for ( ;; ) {
+        rc = ngx_ssl_ocsp_parse_header_line(ctx);
+
+        if (rc == NGX_OK) {
+
+            ngx_log_debug4(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                           "ssl ocsp header \"%*s: %*s\"",
+                           ctx->header_name_end - ctx->header_name_start,
+                           ctx->header_name_start,
+                           ctx->header_end - ctx->header_start,
+                           ctx->header_start);
+
+            len = ctx->header_name_end - ctx->header_name_start;
+
+            if (len == sizeof("Content-Type") - 1
+                && ngx_strncasecmp(ctx->header_name_start,
+                                   (u_char *) "Content-Type",
+                                   sizeof("Content-Type") - 1)
+                   == 0)
+            {
+                len = ctx->header_end - ctx->header_start;
+
+                if (len != sizeof("application/ocsp-response") - 1
+                    || ngx_strncasecmp(ctx->header_start,
+                                       (u_char *) "application/ocsp-response",
+                                       sizeof("application/ocsp-response") - 1)
+                       != 0)
+                {
+                    ngx_log_error(NGX_LOG_ERR, ctx->log, 0,
+                                  "OCSP responder sent invalid "
+                                  "\"Content-Type\" header: \"%*s\"",
+                                  ctx->header_end - ctx->header_start,
+                                  ctx->header_start);
+                    return NGX_ERROR;
+                }
+
+                continue;
+            }
+
+            /* TODO: honor Content-Length */
+
+            continue;
+        }
+
+        if (rc == NGX_DONE) {
+            break;
+        }
+
+        if (rc == NGX_AGAIN) {
+            return NGX_AGAIN;
+        }
+
+        /* rc == NGX_ERROR */
+
+        ngx_log_error(NGX_LOG_ERR, ctx->log, 0,
+                      "OCSP responder sent invalid response");
+
+        return NGX_ERROR;
+    }
+
+    ctx->process = ngx_ssl_ocsp_process_body;
+    return ctx->process(ctx);
+}
+
+static ngx_int_t
+ngx_ssl_ocsp_parse_header_line(ngx_ssl_ocsp_ctx_t *ctx)
+{
+    u_char      c, ch, *p;
+    enum {
+        sw_start = 0,
+        sw_name,
+        sw_space_before_value,
+        sw_value,
+        sw_space_after_value,
+        sw_almost_done,
+        sw_header_almost_done
+    } state;
+
+    state = ctx->state;
+
+    for (p = ctx->response->pos; p < ctx->response->last; p++) {
+        ch = *p;
+
+#if 0
+        ngx_log_debug3(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                       "s:%d in:'%02Xd:%c'", state, ch, ch);
+#endif
+
+        switch (state) {
+
+        /* first char */
+        case sw_start:
+
+            switch (ch) {
+            case CR:
+                ctx->header_end = p;
+                state = sw_header_almost_done;
+                break;
+            case LF:
+                ctx->header_end = p;
+                goto header_done;
+            default:
+                state = sw_name;
+                ctx->header_name_start = p;
+
+                c = (u_char) (ch | 0x20);
+                if (c >= 'a' && c <= 'z') {
+                    break;
+                }
+
+                if (ch >= '0' && ch <= '9') {
+                    break;
+                }
+
+                return NGX_ERROR;
+            }
+            break;
+
+        /* header name */
+        case sw_name:
+            c = (u_char) (ch | 0x20);
+            if (c >= 'a' && c <= 'z') {
+                break;
+            }
+
+            if (ch == ':') {
+                ctx->header_name_end = p;
+                state = sw_space_before_value;
+                break;
+            }
+
+            if (ch == '-') {
+                break;
+            }
+
+            if (ch >= '0' && ch <= '9') {
+                break;
+            }
+
+            if (ch == CR) {
+                ctx->header_name_end = p;
+                ctx->header_start = p;
+                ctx->header_end = p;
+                state = sw_almost_done;
+                break;
+            }
+
+            if (ch == LF) {
+                ctx->header_name_end = p;
+                ctx->header_start = p;
+                ctx->header_end = p;
+                goto done;
+            }
+
+            return NGX_ERROR;
+
+        /* space* before header value */
+        case sw_space_before_value:
+            switch (ch) {
+            case ' ':
+                break;
+            case CR:
+                ctx->header_start = p;
+                ctx->header_end = p;
+                state = sw_almost_done;
+                break;
+            case LF:
+                ctx->header_start = p;
+                ctx->header_end = p;
+                goto done;
+            default:
+                ctx->header_start = p;
+                state = sw_value;
+                break;
+            }
+            break;
+
+        /* header value */
+        case sw_value:
+            switch (ch) {
+            case ' ':
+                ctx->header_end = p;
+                state = sw_space_after_value;
+                break;
+            case CR:
+                ctx->header_end = p;
+                state = sw_almost_done;
+                break;
+            case LF:
+                ctx->header_end = p;
+                goto done;
+            }
+            break;
+
+        /* space* before end of header line */
+        case sw_space_after_value:
+            switch (ch) {
+            case ' ':
+                break;
+            case CR:
+                state = sw_almost_done;
+                break;
+            case LF:
+                goto done;
+            default:
+                state = sw_value;
+                break;
+            }
+            break;
+
+        /* end of header line */
+        case sw_almost_done:
+            switch (ch) {
+            case LF:
+                goto done;
+            default:
+                return NGX_ERROR;
+            }
+
+        /* end of header */
+        case sw_header_almost_done:
+            switch (ch) {
+            case LF:
+                goto header_done;
+            default:
+                return NGX_ERROR;
+            }
+        }
+    }
+
+    ctx->response->pos = p;
+    ctx->state = state;
+
+    return NGX_AGAIN;
+
+done:
+
+    ctx->response->pos = p + 1;
+    ctx->state = sw_start;
+
+    return NGX_OK;
+
+header_done:
+
+    ctx->response->pos = p + 1;
+    ctx->state = sw_start;
+
+    return NGX_DONE;
+}
+
+
+static ngx_int_t
+ngx_ssl_ocsp_process_body(ngx_ssl_ocsp_ctx_t *ctx)
+{
+    ngx_log_debug0(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                   "ssl ocsp process body");
+
+    if (ctx->done) {
+        ctx->handler(ctx);
+        return NGX_DONE;
+    }
+
+    return NGX_AGAIN;
+}
+
+
+static u_char *
+ngx_ssl_ocsp_log_error(ngx_log_t *log, u_char *buf, size_t len)
+{
+    u_char              *p;
+    ngx_ssl_ocsp_ctx_t  *ctx;
+
+    p = buf;
+
+    if (log->action) {
+        p = ngx_snprintf(buf, len, " while %s", log->action);
+        len -= p - buf;
+    }
+
+    ctx = log->data;
+
+    if (ctx) {
+        p = ngx_snprintf(p, len, ", responder: %V", &ctx->host);
+    }
+
+    return p;
+}
+
+
+#else
+
+
+ngx_int_t
+ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file,
+    ngx_str_t *responder, ngx_uint_t verify)
+{
+    ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+                  "\"ssl_stapling\" ignored, not supported");
+
+    return NGX_OK;
+}
+
+ngx_int_t
+ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
+    ngx_resolver_t *resolver, ngx_msec_t resolver_timeout)
+{
+    return NGX_OK;
+}
+
+
+#endif
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl_stapling.c.rej workspace/src/event/ngx_event_openssl_stapling.c.rej
--- sources/1.5.13/nginx-1.5.13/src/event/ngx_event_openssl_stapling.c.rej	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/event/ngx_event_openssl_stapling.c.rej	2014-03-28 21:15:31.000000000 -0700
@@ -0,0 +1,1225 @@
+***************
+*** 11,45 ****
+  #include <ngx_event_connect.h>
+
+
+  #ifdef SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB
+
+
+  typedef struct {
+      ngx_str_t                    staple;
+-     ngx_msec_t                   timeout;
+-
+-     ngx_resolver_t              *resolver;
+-     ngx_msec_t                   resolver_timeout;
+
+      ngx_addr_t                  *addrs;
+      ngx_str_t                    host;
+      ngx_str_t                    uri;
+      in_port_t                    port;
+
+-     SSL_CTX                     *ssl_ctx;
+-
+      X509                        *cert;
+      X509                        *issuer;
+
+      time_t                       valid;
+
+      unsigned                     verify:1;
+-     unsigned                     loading:1;
+  } ngx_ssl_stapling_t;
+
+
+  typedef struct ngx_ssl_ocsp_ctx_s  ngx_ssl_ocsp_ctx_t;
+
+  struct ngx_ssl_ocsp_ctx_s {
+      X509                        *cert;
+      X509                        *issuer;
+--- 11,52 ----
+  #include <ngx_event_connect.h>
+
+
+  #ifdef SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB
+
+
+  typedef struct {
+      ngx_str_t                    staple;
+
+      ngx_addr_t                  *addrs;
+      ngx_str_t                    host;
+      ngx_str_t                    uri;
+      in_port_t                    port;
+
+      X509                        *cert;
+      X509                        *issuer;
+
+      time_t                       valid;
+
++     unsigned                     loading:1;
++ } ngx_ssl_stapling_cert_t;
++
++
++ typedef struct {
++     ngx_array_t                 *cert_staples;  /* ngx_ssl_stapling_cert_t[] */
++
++     ngx_msec_t                   timeout;
++
++     ngx_resolver_t              *resolver;
++     ngx_msec_t                   resolver_timeout;
++
++     SSL_CTX                     *ssl_ctx;
++
+      unsigned                     verify:1;
+  } ngx_ssl_stapling_t;
+
+
+  typedef struct ngx_ssl_ocsp_ctx_s  ngx_ssl_ocsp_ctx_t;
+
+  struct ngx_ssl_ocsp_ctx_s {
+      X509                        *cert;
+      X509                        *issuer;
+***************
+*** 52,68 ****
+      in_port_t                    port;
+
+      ngx_resolver_t              *resolver;
+      ngx_msec_t                   resolver_timeout;
+
+      ngx_msec_t                   timeout;
+
+      void                       (*handler)(ngx_ssl_ocsp_ctx_t *r);
+-     void                        *data;
+
+      ngx_buf_t                   *request;
+      ngx_buf_t                   *response;
+      ngx_peer_connection_t        peer;
+
+      ngx_int_t                  (*process)(ngx_ssl_ocsp_ctx_t *r);
+
+      ngx_uint_t                   state;
+--- 59,76 ----
+      in_port_t                    port;
+
+      ngx_resolver_t              *resolver;
+      ngx_msec_t                   resolver_timeout;
+
+      ngx_msec_t                   timeout;
+
+      void                       (*handler)(ngx_ssl_ocsp_ctx_t *r);
++     ngx_ssl_stapling_t          *staple;
++     ngx_ssl_stapling_cert_t     *cert_staple;
+
+      ngx_buf_t                   *request;
+      ngx_buf_t                   *response;
+      ngx_peer_connection_t        peer;
+
+      ngx_int_t                  (*process)(ngx_ssl_ocsp_ctx_t *r);
+
+      ngx_uint_t                   state;
+***************
+*** 78,101 ****
+      u_char                      *header_end;
+
+      ngx_pool_t                  *pool;
+      ngx_log_t                   *log;
+  };
+
+
+  static ngx_int_t ngx_ssl_stapling_file(ngx_conf_t *cf, ngx_ssl_t *ssl,
+-     ngx_str_t *file);
+- static ngx_int_t ngx_ssl_stapling_issuer(ngx_conf_t *cf, ngx_ssl_t *ssl);
+  static ngx_int_t ngx_ssl_stapling_responder(ngx_conf_t *cf, ngx_ssl_t *ssl,
+      ngx_str_t *responder);
+
+  static int ngx_ssl_certificate_status_callback(ngx_ssl_conn_t *ssl_conn,
+      void *data);
+- static void ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple);
+  static void ngx_ssl_stapling_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx);
+
+  static void ngx_ssl_stapling_cleanup(void *data);
+
+  static ngx_ssl_ocsp_ctx_t *ngx_ssl_ocsp_start(void);
+  static void ngx_ssl_ocsp_done(ngx_ssl_ocsp_ctx_t *ctx);
+  static void ngx_ssl_ocsp_request(ngx_ssl_ocsp_ctx_t *ctx);
+  static void ngx_ssl_ocsp_resolve_handler(ngx_resolver_ctx_t *resolve);
+--- 86,112 ----
+      u_char                      *header_end;
+
+      ngx_pool_t                  *pool;
+      ngx_log_t                   *log;
+  };
+
+
+  static ngx_int_t ngx_ssl_stapling_file(ngx_conf_t *cf, ngx_ssl_t *ssl,
++     ngx_ssl_stapling_cert_t *cert_staple, ngx_str_t *file);
++ static ngx_int_t ngx_ssl_stapling_issuer(ngx_conf_t *cf, ngx_ssl_t *ssl,
++     ngx_ssl_stapling_cert_t *cert_staple, ngx_str_t *cert_file);
+  static ngx_int_t ngx_ssl_stapling_responder(ngx_conf_t *cf, ngx_ssl_t *ssl,
++     ngx_ssl_stapling_cert_t *cert_staple, ngx_str_t *cert_file,
+      ngx_str_t *responder);
+
+  static int ngx_ssl_certificate_status_callback(ngx_ssl_conn_t *ssl_conn,
+      void *data);
++ static void ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple,
++     ngx_ssl_stapling_cert_t *cert_staple);
+  static void ngx_ssl_stapling_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx);
+
+  static void ngx_ssl_stapling_cleanup(void *data);
+
+  static ngx_ssl_ocsp_ctx_t *ngx_ssl_ocsp_start(void);
+  static void ngx_ssl_ocsp_done(ngx_ssl_ocsp_ctx_t *ctx);
+  static void ngx_ssl_ocsp_request(ngx_ssl_ocsp_ctx_t *ctx);
+  static void ngx_ssl_ocsp_resolve_handler(ngx_resolver_ctx_t *resolve);
+***************
+*** 110,129 ****
+  static ngx_int_t ngx_ssl_ocsp_process_headers(ngx_ssl_ocsp_ctx_t *ctx);
+  static ngx_int_t ngx_ssl_ocsp_parse_header_line(ngx_ssl_ocsp_ctx_t *ctx);
+  static ngx_int_t ngx_ssl_ocsp_process_body(ngx_ssl_ocsp_ctx_t *ctx);
+
+  static u_char *ngx_ssl_ocsp_log_error(ngx_log_t *log, u_char *buf, size_t len);
+
+
+  ngx_int_t
+- ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file,
+-     ngx_str_t *responder, ngx_uint_t verify)
+  {
+-     ngx_int_t                  rc;
+      ngx_pool_cleanup_t        *cln;
+      ngx_ssl_stapling_t        *staple;
+
+      staple = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_stapling_t));
+      if (staple == NULL) {
+          return NGX_ERROR;
+      }
+
+--- 121,138 ----
+  static ngx_int_t ngx_ssl_ocsp_process_headers(ngx_ssl_ocsp_ctx_t *ctx);
+  static ngx_int_t ngx_ssl_ocsp_parse_header_line(ngx_ssl_ocsp_ctx_t *ctx);
+  static ngx_int_t ngx_ssl_ocsp_process_body(ngx_ssl_ocsp_ctx_t *ctx);
+
+  static u_char *ngx_ssl_ocsp_log_error(ngx_log_t *log, u_char *buf, size_t len);
+
+
+  ngx_int_t
++ ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_uint_t verify)
+  {
+      ngx_pool_cleanup_t        *cln;
+      ngx_ssl_stapling_t        *staple;
+
+      staple = ngx_pcalloc(cf->pool, sizeof(ngx_ssl_stapling_t));
+      if (staple == NULL) {
+          return NGX_ERROR;
+      }
+
+***************
+*** 142,206 ****
+                        "SSL_CTX_set_ex_data() failed");
+          return NGX_ERROR;
+      }
+
+      staple->ssl_ctx = ssl->ctx;
+      staple->timeout = 60000;
+      staple->verify = verify;
+
+-     if (file->len) {
+-         /* use OCSP response from the file */
+
+-         if (ngx_ssl_stapling_file(cf, ssl, file) != NGX_OK) {
+              return NGX_ERROR;
+          }
+
+-         goto done;
+      }
+
+-     rc = ngx_ssl_stapling_issuer(cf, ssl);
+
+      if (rc == NGX_DECLINED) {
+          return NGX_OK;
+      }
+
+      if (rc != NGX_OK) {
+          return NGX_ERROR;
+      }
+
+-     rc = ngx_ssl_stapling_responder(cf, ssl, responder);
+-
+-     if (rc == NGX_DECLINED) {
+-         return NGX_OK;
+-     }
+-
+-     if (rc != NGX_OK) {
+-         return NGX_ERROR;
+-     }
+-
+- done:
+-
+-     SSL_CTX_set_tlsext_status_cb(ssl->ctx, ngx_ssl_certificate_status_callback);
+-     SSL_CTX_set_tlsext_status_arg(ssl->ctx, staple);
+-
+      return NGX_OK;
+  }
+
+
+  static ngx_int_t
+- ngx_ssl_stapling_file(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)
+  {
+      BIO                 *bio;
+      int                  len;
+      u_char              *p, *buf;
+      OCSP_RESPONSE       *response;
+-     ngx_ssl_stapling_t  *staple;
+-
+-     staple = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_stapling_index);
+
+      if (ngx_conf_full_name(cf->cycle, file, 1) != NGX_OK) {
+          return NGX_ERROR;
+      }
+
+      bio = BIO_new_file((char *) file->data, "r");
+      if (bio == NULL) {
+          ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+--- 151,248 ----
+                        "SSL_CTX_set_ex_data() failed");
+          return NGX_ERROR;
+      }
+
+      staple->ssl_ctx = ssl->ctx;
+      staple->timeout = 60000;
+      staple->verify = verify;
+
++     staple->cert_staples = ngx_array_create(cf->pool, 3,
++                                             sizeof(ngx_ssl_stapling_cert_t));
++     if (staple->cert_staples == NULL) {
++         return NGX_ERROR;
++     }
+
++     SSL_CTX_set_tlsext_status_cb(ssl->ctx, ngx_ssl_certificate_status_callback);
++     SSL_CTX_set_tlsext_status_arg(ssl->ctx, staple);
++
++     return NGX_OK;
++ }
++
++
++ ngx_int_t
++ ngx_ssl_stapling_cert(ngx_conf_t *cf, ngx_ssl_t *ssl, X509 *issuer, X509 *cert,
++     ngx_str_t *cert_file, ngx_str_t *stapling_file, ngx_str_t *responder)
++ {
++     ngx_int_t                  rc;
++     ngx_ssl_stapling_cert_t   *cert_staple;
++     ngx_ssl_stapling_t        *staple;
++
++     staple = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_stapling_index);
++
++     cert_staple = ngx_array_push(staple->cert_staples);
++     if (cert_staple == NULL) {
++         return NGX_ERROR;
++     }
++
++     cert_staple->cert = cert;
++
++     if (stapling_file != NULL) {
++         /* use OCSP response from a file */
++
++         if (ngx_ssl_stapling_file(cf, ssl, cert_staple, stapling_file)
++             != NGX_OK)
++         {
+              return NGX_ERROR;
+          }
+
++         return NGX_OK;
+      }
+
++     if ((issuer != NULL) && ((X509_check_issued(issuer, cert) == X509_V_OK))) {
++         CRYPTO_add(&issuer->references, 1, CRYPTO_LOCK_X509);
++         cert_staple->issuer = issuer;
++     }
++     else {
++         /* lookup issuer certificate in trusted certificate store */
++
++         rc = ngx_ssl_stapling_issuer(cf, ssl, cert_staple, cert_file);
++
++         if (rc == NGX_DECLINED) {
++             return NGX_OK;
++         }
++
++         if (rc != NGX_OK) {
++             return NGX_ERROR;
++         }
++     }
++
++     rc = ngx_ssl_stapling_responder(cf, ssl, cert_staple, cert_file, responder);
+
+      if (rc == NGX_DECLINED) {
+          return NGX_OK;
+      }
+
+      if (rc != NGX_OK) {
+          return NGX_ERROR;
+      }
+
+      return NGX_OK;
+  }
+
+
+  static ngx_int_t
++ ngx_ssl_stapling_file(ngx_conf_t *cf, ngx_ssl_t *ssl,
++     ngx_ssl_stapling_cert_t *cert_staple, ngx_str_t *file)
+  {
+      BIO                 *bio;
+      int                  len;
+      u_char              *p, *buf;
+      OCSP_RESPONSE       *response;
+
+      if (ngx_conf_full_name(cf->cycle, file, 1) != NGX_OK) {
+          return NGX_ERROR;
+      }
+
+      bio = BIO_new_file((char *) file->data, "r");
+      if (bio == NULL) {
+          ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+***************
+*** 235,302 ****
+                        "i2d_OCSP_RESPONSE(\"%s\") failed", file->data);
+          ngx_free(buf);
+          goto failed;
+      }
+
+      OCSP_RESPONSE_free(response);
+      BIO_free(bio);
+
+-     staple->staple.data = buf;
+-     staple->staple.len = len;
+
+      return NGX_OK;
+
+  failed:
+
+      OCSP_RESPONSE_free(response);
+      BIO_free(bio);
+
+      return NGX_ERROR;
+  }
+
+
+  static ngx_int_t
+- ngx_ssl_stapling_issuer(ngx_conf_t *cf, ngx_ssl_t *ssl)
+  {
+-     int                  i, n, rc;
+-     X509                *cert, *issuer;
+      X509_STORE          *store;
+      X509_STORE_CTX      *store_ctx;
+-     STACK_OF(X509)      *chain;
+-     ngx_ssl_stapling_t  *staple;
+-
+-     staple = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_stapling_index);
+-     cert = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_certificate_index);
+-
+- #if OPENSSL_VERSION_NUMBER >= 0x10001000L
+-     SSL_CTX_get_extra_chain_certs(ssl->ctx, &chain);
+- #else
+-     chain = ssl->ctx->extra_certs;
+- #endif
+-
+-     n = sk_X509_num(chain);
+-
+-     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
+-                    "SSL get issuer: %d extra certs", n);
+-
+-     for (i = 0; i < n; i++) {
+-         issuer = sk_X509_value(chain, i);
+-         if (X509_check_issued(issuer, cert) == X509_V_OK) {
+-             CRYPTO_add(&issuer->references, 1, CRYPTO_LOCK_X509);
+-
+-             ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
+-                            "SSL get issuer: found %p in extra certs", issuer);
+-
+-             staple->cert = cert;
+-             staple->issuer = issuer;
+-
+-             return NGX_OK;
+-         }
+-     }
+
+      store = SSL_CTX_get_cert_store(ssl->ctx);
+      if (store == NULL) {
+          ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                        "SSL_CTX_get_cert_store() failed");
+          return NGX_ERROR;
+      }
+
+--- 277,314 ----
+                        "i2d_OCSP_RESPONSE(\"%s\") failed", file->data);
+          ngx_free(buf);
+          goto failed;
+      }
+
+      OCSP_RESPONSE_free(response);
+      BIO_free(bio);
+
++     cert_staple->staple.data = buf;
++     cert_staple->staple.len = len;
+
+      return NGX_OK;
+
+  failed:
+
+      OCSP_RESPONSE_free(response);
+      BIO_free(bio);
+
+      return NGX_ERROR;
+  }
+
+
+  static ngx_int_t
++ ngx_ssl_stapling_issuer(ngx_conf_t *cf, ngx_ssl_t *ssl,
++     ngx_ssl_stapling_cert_t *cert_staple, ngx_str_t *cert_file)
+  {
++     int                  rc;
++     X509                *issuer;
+      X509_STORE          *store;
+      X509_STORE_CTX      *store_ctx;
+
+      store = SSL_CTX_get_cert_store(ssl->ctx);
+      if (store == NULL) {
+          ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                        "SSL_CTX_get_cert_store() failed");
+          return NGX_ERROR;
+      }
+
+***************
+*** 308,382 ****
+      }
+
+      if (X509_STORE_CTX_init(store_ctx, store, NULL, NULL) == 0) {
+          ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                        "X509_STORE_CTX_init() failed");
+          return NGX_ERROR;
+      }
+
+-     rc = X509_STORE_CTX_get1_issuer(&issuer, store_ctx, cert);
+
+      if (rc == -1) {
+          ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                        "X509_STORE_CTX_get1_issuer() failed");
+          X509_STORE_CTX_free(store_ctx);
+          return NGX_ERROR;
+      }
+
+      if (rc == 0) {
+          ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+-                       "\"ssl_stapling\" ignored, issuer certificate not found");
+          X509_STORE_CTX_free(store_ctx);
+          return NGX_DECLINED;
+      }
+
+      X509_STORE_CTX_free(store_ctx);
+
+      ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
+                     "SSL get issuer: found %p in cert store", issuer);
+
+-     staple->cert = cert;
+-     staple->issuer = issuer;
+
+      return NGX_OK;
+  }
+
+
+  static ngx_int_t
+- ngx_ssl_stapling_responder(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *responder)
+  {
+      ngx_url_t                  u;
+      char                      *s;
+-     ngx_ssl_stapling_t        *staple;
+      STACK_OF(OPENSSL_STRING)  *aia;
+
+-     staple = SSL_CTX_get_ex_data(ssl->ctx, ngx_ssl_stapling_index);
+-
+      if (responder->len == 0) {
+
+          /* extract OCSP responder URL from certificate */
+
+-         aia = X509_get1_ocsp(staple->cert);
+          if (aia == NULL) {
+              ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+-                           "\"ssl_stapling\" ignored, "
+-                           "no OCSP responder URL in the certificate");
+              return NGX_DECLINED;
+          }
+
+  #if OPENSSL_VERSION_NUMBER >= 0x10000000L
+          s = sk_OPENSSL_STRING_value(aia, 0);
+  #else
+          s = sk_value(aia, 0);
+  #endif
+          if (s == NULL) {
+              ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+-                           "\"ssl_stapling\" ignored, "
+-                           "no OCSP responder URL in the certificate");
+              X509_email_free(aia);
+              return NGX_DECLINED;
+          }
+
+          responder->len = ngx_strlen(s);
+          responder->data = ngx_palloc(cf->pool, responder->len);
+          if (responder->data == NULL) {
+              X509_email_free(aia);
+--- 320,396 ----
+      }
+
+      if (X509_STORE_CTX_init(store_ctx, store, NULL, NULL) == 0) {
+          ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                        "X509_STORE_CTX_init() failed");
+          return NGX_ERROR;
+      }
+
++     rc = X509_STORE_CTX_get1_issuer(&issuer, store_ctx, cert_staple->cert);
+
+      if (rc == -1) {
+          ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                        "X509_STORE_CTX_get1_issuer() failed");
+          X509_STORE_CTX_free(store_ctx);
+          return NGX_ERROR;
+      }
+
+      if (rc == 0) {
+          ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
++                       "\"ssl_stapling\" ignored for \"%V\", issuer certificate "
++                       "not found",
++                       cert_file);
+          X509_STORE_CTX_free(store_ctx);
+          return NGX_DECLINED;
+      }
+
+      X509_STORE_CTX_free(store_ctx);
+
+      ngx_log_debug1(NGX_LOG_DEBUG_EVENT, ssl->log, 0,
+                     "SSL get issuer: found %p in cert store", issuer);
+
++     cert_staple->issuer = issuer;
+
+      return NGX_OK;
+  }
+
+
+  static ngx_int_t
++ ngx_ssl_stapling_responder(ngx_conf_t *cf, ngx_ssl_t *ssl,
++     ngx_ssl_stapling_cert_t *cert_staple, ngx_str_t *cert_file,
++     ngx_str_t *responder)
+  {
+      ngx_url_t                  u;
+      char                      *s;
+      STACK_OF(OPENSSL_STRING)  *aia;
+
+      if (responder->len == 0) {
+
+          /* extract OCSP responder URL from certificate */
+
++         aia = X509_get1_ocsp(cert_staple->cert);
+          if (aia == NULL) {
+              ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
++                           "\"ssl_stapling\" ignored for \"%V\", "
++                           "no OCSP responder URL in the certificate",
++                           cert_file);
+              return NGX_DECLINED;
+          }
+
+  #if OPENSSL_VERSION_NUMBER >= 0x10000000L
+          s = sk_OPENSSL_STRING_value(aia, 0);
+  #else
+          s = sk_value(aia, 0);
+  #endif
+          if (s == NULL) {
+              ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
++                           "\"ssl_stapling\" ignored for \"%V\", "
++                           "no OCSP responder URL in the certificate",
++                           cert_file);
+              X509_email_free(aia);
+              return NGX_DECLINED;
+          }
+
+          responder->len = ngx_strlen(s);
+          responder->data = ngx_palloc(cf->pool, responder->len);
+          if (responder->data == NULL) {
+              X509_email_free(aia);
+***************
+*** 396,434 ****
+      if (u.url.len > 7
+          && ngx_strncasecmp(u.url.data, (u_char *) "http://", 7) == 0)
+      {
+          u.url.len -= 7;
+          u.url.data += 7;
+
+      } else {
+          ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+-                       "\"ssl_stapling\" ignored, "
+-                       "invalid URL prefix in OCSP responder \"%V\"", &u.url);
+          return NGX_DECLINED;
+      }
+
+      if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
+          if (u.err) {
+              ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+-                           "\"ssl_stapling\" ignored, "
+-                           "%s in OCSP responder \"%V\"", u.err, &u.url);
+              return NGX_DECLINED;
+          }
+
+          return NGX_ERROR;
+      }
+
+-     staple->addrs = u.addrs;
+-     staple->host = u.host;
+-     staple->uri = u.uri;
+-     staple->port = u.port;
+
+-     if (staple->uri.len == 0) {
+-         ngx_str_set(&staple->uri, "/");
+      }
+
+      return NGX_OK;
+  }
+
+
+  ngx_int_t
+  ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
+--- 410,450 ----
+      if (u.url.len > 7
+          && ngx_strncasecmp(u.url.data, (u_char *) "http://", 7) == 0)
+      {
+          u.url.len -= 7;
+          u.url.data += 7;
+
+      } else {
+          ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
++                       "\"ssl_stapling\" ignored for \"%V\", "
++                       "invalid URL prefix in OCSP responder \"%V\"",
++                       cert_file, &u.url);
+          return NGX_DECLINED;
+      }
+
+      if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
+          if (u.err) {
+              ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
++                           "\"ssl_stapling\" ignored for \"%V\", "
++                           "%s in OCSP responder \"%V\"",
++                           cert_file, u.err, &u.url);
+              return NGX_DECLINED;
+          }
+
+          return NGX_ERROR;
+      }
+
++     cert_staple->addrs = u.addrs;
++     cert_staple->host = u.host;
++     cert_staple->uri = u.uri;
++     cert_staple->port = u.port;
+
++     if (cert_staple->uri.len == 0) {
++         ngx_str_set(&cert_staple->uri, "/");
+      }
+
+      return NGX_OK;
+  }
+
+
+  ngx_int_t
+  ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
+***************
+*** 443,551 ****
+
+      return NGX_OK;
+  }
+
+
+  static int
+  ngx_ssl_certificate_status_callback(ngx_ssl_conn_t *ssl_conn, void *data)
+  {
+-     int                  rc;
+-     u_char              *p;
+-     ngx_connection_t    *c;
+-     ngx_ssl_stapling_t  *staple;
+
+      c = ngx_ssl_get_connection(ssl_conn);
+
+      ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                     "SSL certificate status callback");
+
+      staple = data;
+      rc = SSL_TLSEXT_ERR_NOACK;
+
+-     if (staple->staple.len) {
+          /* we have to copy ocsp response as OpenSSL will free it by itself */
+
+-         p = OPENSSL_malloc(staple->staple.len);
+          if (p == NULL) {
+              ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, "OPENSSL_malloc() failed");
+              return SSL_TLSEXT_ERR_NOACK;
+          }
+
+-         ngx_memcpy(p, staple->staple.data, staple->staple.len);
+
+-         SSL_set_tlsext_status_ocsp_resp(ssl_conn, p, staple->staple.len);
+
+          rc = SSL_TLSEXT_ERR_OK;
+      }
+
+-     ngx_ssl_stapling_update(staple);
+
+      return rc;
+  }
+
+
+  static void
+- ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple)
+  {
+      ngx_ssl_ocsp_ctx_t  *ctx;
+
+-     if (staple->host.len == 0
+-         || staple->loading || staple->valid >= ngx_time())
+      {
+          return;
+      }
+
+-     staple->loading = 1;
+
+      ctx = ngx_ssl_ocsp_start();
+      if (ctx == NULL) {
+          return;
+      }
+
+-     ctx->cert = staple->cert;
+-     ctx->issuer = staple->issuer;
+
+-     ctx->addrs = staple->addrs;
+-     ctx->host = staple->host;
+-     ctx->uri = staple->uri;
+-     ctx->port = staple->port;
+      ctx->timeout = staple->timeout;
+
+      ctx->resolver = staple->resolver;
+      ctx->resolver_timeout = staple->resolver_timeout;
+
+      ctx->handler = ngx_ssl_stapling_ocsp_handler;
+-     ctx->data = staple;
+
+      ngx_ssl_ocsp_request(ctx);
+
+      return;
+  }
+
+
+  static void
+  ngx_ssl_stapling_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)
+  {
+  #if OPENSSL_VERSION_NUMBER >= 0x0090707fL
+      const
+  #endif
+-     u_char                *p;
+-     int                    n;
+-     size_t                 len;
+-     ngx_str_t              response;
+-     X509_STORE            *store;
+-     STACK_OF(X509)        *chain;
+-     OCSP_CERTID           *id;
+-     OCSP_RESPONSE         *ocsp;
+-     OCSP_BASICRESP        *basic;
+-     ngx_ssl_stapling_t    *staple;
+-     ASN1_GENERALIZEDTIME  *thisupdate, *nextupdate;
+
+-     staple = ctx->data;
+      ocsp = NULL;
+      basic = NULL;
+      id = NULL;
+
+      if (ctx->code != 200) {
+          goto error;
+      }
+
+--- 459,591 ----
+
+      return NGX_OK;
+  }
+
+
+  static int
+  ngx_ssl_certificate_status_callback(ngx_ssl_conn_t *ssl_conn, void *data)
+  {
++     int                       rc;
++     u_char                   *p;
++     ngx_uint_t                i;
++     ngx_connection_t         *c;
++     ngx_ssl_stapling_t       *staple;
++     ngx_ssl_stapling_cert_t  *cert_staples, *cert_staple = NULL;
++     X509                     *cert;
+
+      c = ngx_ssl_get_connection(ssl_conn);
+
+      ngx_log_debug0(NGX_LOG_DEBUG_EVENT, c->log, 0,
+                     "SSL certificate status callback");
+
+      staple = data;
+      rc = SSL_TLSEXT_ERR_NOACK;
+
++     /* lookup the stapling info for the server certificate that was sent */
++
++     cert = SSL_get_certificate(ssl_conn);
++     cert_staples = staple->cert_staples->elts;
++
++     for (i = 0; i < staple->cert_staples->nelts; i++) {
++         if (cert == (&cert_staples[i])->cert) {
++             cert_staple = &cert_staples[i];
++             break;
++         }
++     }
++
++     if (cert_staple == NULL) {
++         return rc;
++     }
++
++     if (cert_staple->staple.len) {
+          /* we have to copy ocsp response as OpenSSL will free it by itself */
+
++         p = OPENSSL_malloc(cert_staple->staple.len);
+          if (p == NULL) {
+              ngx_ssl_error(NGX_LOG_ALERT, c->log, 0, "OPENSSL_malloc() failed");
+              return SSL_TLSEXT_ERR_NOACK;
+          }
+
++         ngx_memcpy(p, cert_staple->staple.data, cert_staple->staple.len);
+
++         SSL_set_tlsext_status_ocsp_resp(ssl_conn, p, cert_staple->staple.len);
+
+          rc = SSL_TLSEXT_ERR_OK;
+      }
+
++     ngx_ssl_stapling_update(staple, cert_staple);
+
+      return rc;
+  }
+
+
+  static void
++ ngx_ssl_stapling_update(ngx_ssl_stapling_t *staple,
++     ngx_ssl_stapling_cert_t *cert_staple)
+  {
+      ngx_ssl_ocsp_ctx_t  *ctx;
+
++     if (cert_staple->host.len == 0
++         || cert_staple->loading || cert_staple->valid >= ngx_time())
+      {
+          return;
+      }
+
++     cert_staple->loading = 1;
+
+      ctx = ngx_ssl_ocsp_start();
+      if (ctx == NULL) {
+          return;
+      }
+
++     ctx->cert = cert_staple->cert;
++     ctx->issuer = cert_staple->issuer;
+
++     ctx->addrs = cert_staple->addrs;
++     ctx->host = cert_staple->host;
++     ctx->uri = cert_staple->uri;
++     ctx->port = cert_staple->port;
+      ctx->timeout = staple->timeout;
+
+      ctx->resolver = staple->resolver;
+      ctx->resolver_timeout = staple->resolver_timeout;
+
+      ctx->handler = ngx_ssl_stapling_ocsp_handler;
++     ctx->staple = staple;
++     ctx->cert_staple = cert_staple;
+
+      ngx_ssl_ocsp_request(ctx);
+
+      return;
+  }
+
+
+  static void
+  ngx_ssl_stapling_ocsp_handler(ngx_ssl_ocsp_ctx_t *ctx)
+  {
+  #if OPENSSL_VERSION_NUMBER >= 0x0090707fL
+      const
+  #endif
++     u_char                   *p;
++     int                       n;
++     size_t                    len;
++     ngx_str_t                 response;
++     X509_STORE               *store;
++     STACK_OF(X509)           *chain;
++     STACK_OF(X509)           *ichain = NULL;
++     OCSP_CERTID              *id;
++     OCSP_RESPONSE            *ocsp;
++     OCSP_BASICRESP           *basic;
++     ngx_ssl_stapling_t       *staple;
++     ngx_ssl_stapling_cert_t  *cert_staple;
++     ASN1_GENERALIZEDTIME     *thisupdate, *nextupdate;
+
++     staple = ctx->staple;
++     cert_staple = ctx->cert_staple;
+      ocsp = NULL;
+      basic = NULL;
+      id = NULL;
+
+      if (ctx->code != 200) {
+          goto error;
+      }
+
+***************
+*** 584,603 ****
+          goto error;
+      }
+
+  #if OPENSSL_VERSION_NUMBER >= 0x10001000L
+      SSL_CTX_get_extra_chain_certs(staple->ssl_ctx, &chain);
+  #else
+      chain = staple->ssl_ctx->extra_certs;
+  #endif
+
+-     if (OCSP_basic_verify(basic, chain, store,
+-                           staple->verify ? OCSP_TRUSTOTHER : OCSP_NOVERIFY)
+-         != 1)
+      {
+          ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,
+                        "OCSP_basic_verify() failed");
+          goto error;
+      }
+
+      id = OCSP_cert_to_id(NULL, ctx->cert, ctx->issuer);
+      if (id == NULL) {
+--- 624,652 ----
+          goto error;
+      }
+
+  #if OPENSSL_VERSION_NUMBER >= 0x10001000L
+      SSL_CTX_get_extra_chain_certs(staple->ssl_ctx, &chain);
+  #else
+      chain = staple->ssl_ctx->extra_certs;
+  #endif
++     if ((sk_X509_num(chain) <= 0) && (cert_staple->issuer != NULL)) {
++         ichain = sk_X509_new_null();
++         sk_X509_push(ichain, cert_staple->issuer);
++     }
+
++     if (OCSP_basic_verify(basic, ichain ? ichain : chain, store,
++                           staple->verify ? OCSP_TRUSTOTHER :
++                                            OCSP_NOVERIFY
++ #if OPENSSL_VERSION_NUMBER < 0x10000000L
++         /* ECDSA/SHA-2 signature verification not supported */
++                                            | OCSP_NOSIGS
++ #endif
++         ) == 0)
+      {
+          ngx_ssl_error(NGX_LOG_ERR, ctx->log, 0,
+                        "OCSP_basic_verify() failed");
+          goto error;
+      }
+
+      id = OCSP_cert_to_id(NULL, ctx->cert, ctx->issuer);
+      if (id == NULL) {
+***************
+*** 642,703 ****
+      }
+
+      ngx_memcpy(response.data, ctx->response->pos, response.len);
+
+      ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                     "ssl ocsp response, %s, %uz",
+                     OCSP_cert_status_str(n), response.len);
+
+-     if (staple->staple.data) {
+-         ngx_free(staple->staple.data);
+      }
+
+-     staple->staple = response;
+
+  done:
+
+-     staple->loading = 0;
+-     staple->valid = ngx_time() + 3600; /* ssl_stapling_valid */
+
+      ngx_ssl_ocsp_done(ctx);
+      return;
+
+  error:
+
+-     staple->loading = 0;
+-     staple->valid = ngx_time() + 300; /* ssl_stapling_err_valid */
+
+      if (id) {
+          OCSP_CERTID_free(id);
+      }
+
+      if (basic) {
+          OCSP_BASICRESP_free(basic);
+      }
+
+      if (ocsp) {
+          OCSP_RESPONSE_free(ocsp);
+      }
+
+      ngx_ssl_ocsp_done(ctx);
+  }
+
+
+  static void
+  ngx_ssl_stapling_cleanup(void *data)
+  {
+-     ngx_ssl_stapling_t  *staple = data;
+
+-     if (staple->issuer) {
+-         X509_free(staple->issuer);
+-     }
+
+-     if (staple->staple.data) {
+-         ngx_free(staple->staple.data);
+      }
+  }
+
+
+  static ngx_ssl_ocsp_ctx_t *
+  ngx_ssl_ocsp_start(void)
+  {
+      ngx_log_t           *log;
+--- 691,766 ----
+      }
+
+      ngx_memcpy(response.data, ctx->response->pos, response.len);
+
+      ngx_log_debug2(NGX_LOG_DEBUG_EVENT, ctx->log, 0,
+                     "ssl ocsp response, %s, %uz",
+                     OCSP_cert_status_str(n), response.len);
+
++     if (cert_staple->staple.data) {
++         ngx_free(cert_staple->staple.data);
+      }
+
++     cert_staple->staple = response;
+
+  done:
+
++     cert_staple->loading = 0;
++     cert_staple->valid = ngx_time() + 3600; /* ssl_stapling_valid */
++
++     if (ichain) {
++         sk_X509_free(chain);
++     }
+
+      ngx_ssl_ocsp_done(ctx);
+      return;
+
+  error:
+
++     cert_staple->loading = 0;
++     cert_staple->valid = ngx_time() + 300; /* ssl_stapling_err_valid */
+
+      if (id) {
+          OCSP_CERTID_free(id);
+      }
+
+      if (basic) {
+          OCSP_BASICRESP_free(basic);
+      }
+
+      if (ocsp) {
+          OCSP_RESPONSE_free(ocsp);
+      }
+
++     if (ichain) {
++         sk_X509_free(chain);
++     }
++
+      ngx_ssl_ocsp_done(ctx);
+  }
+
+
+  static void
+  ngx_ssl_stapling_cleanup(void *data)
+  {
++     ngx_ssl_stapling_t       *staple = data;
++     ngx_ssl_stapling_cert_t  *cert_staples;
++     ngx_uint_t                i;
+
++     cert_staples = staple->cert_staples->elts;
+
++     for (i = 0; i < staple->cert_staples->nelts; i++) {
++         if ((&cert_staples[i])->issuer) {
++             X509_free((&cert_staples[i])->issuer);
++         }
++
++         if ((&cert_staples[i])->staple.data) {
++             ngx_free((&cert_staples[i])->staple.data);
++         }
+      }
+  }
+
+
+  static ngx_ssl_ocsp_ctx_t *
+  ngx_ssl_ocsp_start(void)
+  {
+      ngx_log_t           *log;
+***************
+*** 1724,1749 ****
+      return p;
+  }
+
+
+  #else
+
+
+  ngx_int_t
+- ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file,
+-     ngx_str_t *responder, ngx_uint_t verify)
+  {
+      ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+                    "\"ssl_stapling\" ignored, not supported");
+
+      return NGX_OK;
+  }
+
+  ngx_int_t
+  ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
+      ngx_resolver_t *resolver, ngx_msec_t resolver_timeout)
+  {
+      return NGX_OK;
+  }
+
+
+  #endif
+--- 1787,1818 ----
+      return p;
+  }
+
+
+  #else
+
+
+  ngx_int_t
++ ngx_ssl_stapling(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_uint_t verify)
+  {
+      ngx_log_error(NGX_LOG_WARN, ssl->log, 0,
+                    "\"ssl_stapling\" ignored, not supported");
+
+      return NGX_OK;
+  }
+
+  ngx_int_t
++ ngx_ssl_stapling_cert(ngx_conf_t *cf, ngx_ssl_t *ssl, X509 *issuer, X509 *cert,
++     ngx_str_t *cert_file, ngx_str_t *stapling_file, ngx_str_t *responder)
++ {
++     return NGX_OK;
++ }
++
++ ngx_int_t
+  ngx_ssl_stapling_resolver(ngx_conf_t *cf, ngx_ssl_t *ssl,
+      ngx_resolver_t *resolver, ngx_msec_t resolver_timeout)
+  {
+      return NGX_OK;
+  }
+
+
+  #endif
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/http/modules/ngx_http_ssl_module.c workspace/src/http/modules/ngx_http_ssl_module.c
--- sources/1.5.13/nginx-1.5.13/src/http/modules/ngx_http_ssl_module.c	2014-03-28 21:15:34.000000000 -0700
+++ workspace/src/http/modules/ngx_http_ssl_module.c	2014-03-28 21:14:16.000000000 -0700
@@ -79,16 +79,16 @@

     { ngx_string("ssl_certificate"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
-      ngx_conf_set_str_slot,
+      ngx_conf_set_str_array_slot,
       NGX_HTTP_SRV_CONF_OFFSET,
-      offsetof(ngx_http_ssl_srv_conf_t, certificate),
+      offsetof(ngx_http_ssl_srv_conf_t, certificates),
       NULL },

     { ngx_string("ssl_certificate_key"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
-      ngx_conf_set_str_slot,
+      ngx_conf_set_str_array_slot,
       NGX_HTTP_SRV_CONF_OFFSET,
-      offsetof(ngx_http_ssl_srv_conf_t, certificate_key),
+      offsetof(ngx_http_ssl_srv_conf_t, certificate_keys),
       NULL },

     { ngx_string("ssl_dhparam"),
@@ -205,9 +205,9 @@

     { ngx_string("ssl_stapling_file"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
-      ngx_conf_set_str_slot,
+      ngx_conf_set_str_array_slot,
       NGX_HTTP_SRV_CONF_OFFSET,
-      offsetof(ngx_http_ssl_srv_conf_t, stapling_file),
+      offsetof(ngx_http_ssl_srv_conf_t, stapling_files),
       NULL },

     { ngx_string("ssl_stapling_responder"),
@@ -490,8 +490,6 @@
      * set by ngx_pcalloc():
      *
      *     sscf->protocols = 0;
-     *     sscf->certificate = { 0, NULL };
-     *     sscf->certificate_key = { 0, NULL };
      *     sscf->dhparam = { 0, NULL };
      *     sscf->ecdh_curve = { 0, NULL };
      *     sscf->client_certificate = { 0, NULL };
@@ -499,7 +497,6 @@
      *     sscf->crl = { 0, NULL };
      *     sscf->ciphers = { 0, NULL };
      *     sscf->shm_zone = NULL;
-     *     sscf->stapling_file = { 0, NULL };
      *     sscf->stapling_responder = { 0, NULL };
      */

@@ -510,10 +507,13 @@
     sscf->verify_depth = NGX_CONF_UNSET_UINT;
     sscf->builtin_session_cache = NGX_CONF_UNSET;
     sscf->session_timeout = NGX_CONF_UNSET;
+    sscf->certificates = NGX_CONF_UNSET_PTR;
+    sscf->certificate_keys = NGX_CONF_UNSET_PTR;
     sscf->session_tickets = NGX_CONF_UNSET;
     sscf->session_ticket_keys = NGX_CONF_UNSET_PTR;
     sscf->stapling = NGX_CONF_UNSET;
     sscf->stapling_verify = NGX_CONF_UNSET;
+    sscf->stapling_files = NGX_CONF_UNSET_PTR;

     return sscf;
 }
@@ -554,8 +554,10 @@
     ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);
     ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);

-    ngx_conf_merge_str_value(conf->certificate, prev->certificate, "");
-    ngx_conf_merge_str_value(conf->certificate_key, prev->certificate_key, "");
+    ngx_conf_merge_ptr_value(conf->certificates, prev->certificates,
+                         NGX_CONF_UNSET_PTR);
+    ngx_conf_merge_ptr_value(conf->certificate_keys, prev->certificate_keys,
+                         NGX_CONF_UNSET_PTR);

     ngx_conf_merge_str_value(conf->dhparam, prev->dhparam, "");

@@ -572,46 +574,29 @@

     ngx_conf_merge_value(conf->stapling, prev->stapling, 0);
     ngx_conf_merge_value(conf->stapling_verify, prev->stapling_verify, 0);
-    ngx_conf_merge_str_value(conf->stapling_file, prev->stapling_file, "");
+    ngx_conf_merge_ptr_value(conf->stapling_files, prev->stapling_files,
+                         NGX_CONF_UNSET_PTR);
     ngx_conf_merge_str_value(conf->stapling_responder,
                          prev->stapling_responder, "");

     conf->ssl.log = cf->log;

+    if ((conf->certificates == NGX_CONF_UNSET_PTR)
+           || (conf->certificates->nelts == 0)) {
     if (conf->enable) {
-
-        if (conf->certificate.len == 0) {
             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
                           "no \"ssl_certificate\" is defined for "
                           "the \"ssl\" directive in %s:%ui",
                           conf->file, conf->line);
             return NGX_CONF_ERROR;
         }
-
-        if (conf->certificate_key.len == 0) {
-            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
-                          "no \"ssl_certificate_key\" is defined for "
-                          "the \"ssl\" directive in %s:%ui",
-                          conf->file, conf->line);
-            return NGX_CONF_ERROR;
-        }
-
-    } else {
-
-        if (conf->certificate.len == 0) {
             return NGX_CONF_OK;
         }

-        if (conf->certificate_key.len == 0) {
-            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
-                          "no \"ssl_certificate_key\" is defined "
-                          "for certificate \"%V\"", &conf->certificate);
+    if (ngx_ssl_create(&conf->ssl, conf->protocols, conf) != NGX_OK) {
             return NGX_CONF_ERROR;
         }
-    }

-    if (ngx_ssl_create(&conf->ssl, conf->protocols, conf) != NGX_OK) {
-        return NGX_CONF_ERROR;
     }

 #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME
@@ -645,13 +630,6 @@
     cln->handler = ngx_ssl_cleanup_ctx;
     cln->data = &conf->ssl;

-    if (ngx_ssl_certificate(cf, &conf->ssl, &conf->certificate,
-                            &conf->certificate_key)
-        != NGX_OK)
-    {
-        return NGX_CONF_ERROR;
-    }
-
     if (SSL_CTX_set_cipher_list(conf->ssl.ctx,
                                 (const char *) conf->ciphers.data)
         == 0)
@@ -689,6 +667,15 @@
         return NGX_CONF_ERROR;
     }

+    if (ngx_ssl_certificates(cf, &conf->ssl, conf->certificates,
+                             conf->certificate_keys, conf->stapling,
+                             conf->stapling_files, &conf->stapling_responder,
+                             conf->stapling_verify)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+
     if (ngx_ssl_crl(cf, &conf->ssl, &conf->crl) != NGX_OK) {
         return NGX_CONF_ERROR;
     }
@@ -740,17 +727,6 @@
         return NGX_CONF_ERROR;
     }

-    if (conf->stapling) {
-
-        if (ngx_ssl_stapling(cf, &conf->ssl, &conf->stapling_file,
-                             &conf->stapling_responder, conf->stapling_verify)
-            != NGX_OK)
-        {
-            return NGX_CONF_ERROR;
-        }
-
-    }
-
     return NGX_CONF_OK;
 }

diff -Naurdw sources/1.5.13/nginx-1.5.13/src/http/modules/ngx_http_ssl_module.c.orig workspace/src/http/modules/ngx_http_ssl_module.c.orig
--- sources/1.5.13/nginx-1.5.13/src/http/modules/ngx_http_ssl_module.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/http/modules/ngx_http_ssl_module.c.orig	2014-03-28 21:12:46.000000000 -0700
@@ -0,0 +1,906 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+
+
+typedef ngx_int_t (*ngx_ssl_variable_handler_pt)(ngx_connection_t *c,
+    ngx_pool_t *pool, ngx_str_t *s);
+
+
+#define NGX_DEFAULT_CIPHERS     "HIGH:!aNULL:!MD5"
+#define NGX_DEFAULT_ECDH_CURVE  "prime256v1"
+
+#define NGX_HTTP_NPN_ADVERTISE  "\x08http/1.1"
+
+
+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation
+static int ngx_http_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn,
+    const unsigned char **out, unsigned char *outlen,
+    const unsigned char *in, unsigned int inlen, void *arg);
+#endif
+
+#ifdef TLSEXT_TYPE_next_proto_neg
+static int ngx_http_ssl_npn_advertised(ngx_ssl_conn_t *ssl_conn,
+    const unsigned char **out, unsigned int *outlen, void *arg);
+#endif
+
+static ngx_int_t ngx_http_ssl_static_variable(ngx_http_request_t *r,
+    ngx_http_variable_value_t *v, uintptr_t data);
+static ngx_int_t ngx_http_ssl_variable(ngx_http_request_t *r,
+    ngx_http_variable_value_t *v, uintptr_t data);
+
+static ngx_int_t ngx_http_ssl_add_variables(ngx_conf_t *cf);
+static void *ngx_http_ssl_create_srv_conf(ngx_conf_t *cf);
+static char *ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf,
+    void *parent, void *child);
+
+static char *ngx_http_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+
+static ngx_int_t ngx_http_ssl_init(ngx_conf_t *cf);
+
+
+static ngx_conf_bitmask_t  ngx_http_ssl_protocols[] = {
+    { ngx_string("SSLv2"), NGX_SSL_SSLv2 },
+    { ngx_string("SSLv3"), NGX_SSL_SSLv3 },
+    { ngx_string("TLSv1"), NGX_SSL_TLSv1 },
+    { ngx_string("TLSv1.1"), NGX_SSL_TLSv1_1 },
+    { ngx_string("TLSv1.2"), NGX_SSL_TLSv1_2 },
+    { ngx_null_string, 0 }
+};
+
+
+static ngx_conf_enum_t  ngx_http_ssl_verify[] = {
+    { ngx_string("off"), 0 },
+    { ngx_string("on"), 1 },
+    { ngx_string("optional"), 2 },
+    { ngx_string("optional_no_ca"), 3 },
+    { ngx_null_string, 0 }
+};
+
+
+static ngx_command_t  ngx_http_ssl_commands[] = {
+
+    { ngx_string("ssl"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_http_ssl_enable,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, enable),
+      NULL },
+
+    { ngx_string("ssl_certificate"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, certificate),
+      NULL },
+
+    { ngx_string("ssl_certificate_key"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, certificate_key),
+      NULL },
+
+    { ngx_string("ssl_dhparam"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, dhparam),
+      NULL },
+
+    { ngx_string("ssl_ecdh_curve"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, ecdh_curve),
+      NULL },
+
+    { ngx_string("ssl_protocols"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_1MORE,
+      ngx_conf_set_bitmask_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, protocols),
+      &ngx_http_ssl_protocols },
+
+    { ngx_string("ssl_ciphers"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, ciphers),
+      NULL },
+
+    { ngx_string("ssl_buffer_size"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_size_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, buffer_size),
+      NULL },
+
+    { ngx_string("ssl_verify_client"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_enum_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, verify),
+      &ngx_http_ssl_verify },
+
+    { ngx_string("ssl_verify_depth"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_num_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, verify_depth),
+      NULL },
+
+    { ngx_string("ssl_client_certificate"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, client_certificate),
+      NULL },
+
+    { ngx_string("ssl_trusted_certificate"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, trusted_certificate),
+      NULL },
+
+    { ngx_string("ssl_prefer_server_ciphers"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, prefer_server_ciphers),
+      NULL },
+
+    { ngx_string("ssl_session_cache"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE12,
+      ngx_http_ssl_session_cache,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("ssl_session_tickets"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, session_tickets),
+      NULL },
+
+    { ngx_string("ssl_session_ticket_key"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_array_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, session_ticket_keys),
+      NULL },
+
+    { ngx_string("ssl_session_timeout"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_sec_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, session_timeout),
+      NULL },
+
+    { ngx_string("ssl_crl"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, crl),
+      NULL },
+
+    { ngx_string("ssl_stapling"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, stapling),
+      NULL },
+
+    { ngx_string("ssl_stapling_file"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, stapling_file),
+      NULL },
+
+    { ngx_string("ssl_stapling_responder"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, stapling_responder),
+      NULL },
+
+    { ngx_string("ssl_stapling_verify"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, stapling_verify),
+      NULL },
+
+      ngx_null_command
+};
+
+
+static ngx_http_module_t  ngx_http_ssl_module_ctx = {
+    ngx_http_ssl_add_variables,            /* preconfiguration */
+    ngx_http_ssl_init,                     /* postconfiguration */
+
+    NULL,                                  /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    ngx_http_ssl_create_srv_conf,          /* create server configuration */
+    ngx_http_ssl_merge_srv_conf,           /* merge server configuration */
+
+    NULL,                                  /* create location configuration */
+    NULL                                   /* merge location configuration */
+};
+
+
+ngx_module_t  ngx_http_ssl_module = {
+    NGX_MODULE_V1,
+    &ngx_http_ssl_module_ctx,              /* module context */
+    ngx_http_ssl_commands,                 /* module directives */
+    NGX_HTTP_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_http_variable_t  ngx_http_ssl_vars[] = {
+
+    { ngx_string("ssl_protocol"), NULL, ngx_http_ssl_static_variable,
+      (uintptr_t) ngx_ssl_get_protocol, NGX_HTTP_VAR_CHANGEABLE, 0 },
+
+    { ngx_string("ssl_cipher"), NULL, ngx_http_ssl_static_variable,
+      (uintptr_t) ngx_ssl_get_cipher_name, NGX_HTTP_VAR_CHANGEABLE, 0 },
+
+    { ngx_string("ssl_session_id"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_session_id, NGX_HTTP_VAR_CHANGEABLE, 0 },
+
+    { ngx_string("ssl_session_reused"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_session_reused, NGX_HTTP_VAR_CHANGEABLE, 0 },
+
+    { ngx_string("ssl_client_cert"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_certificate, NGX_HTTP_VAR_CHANGEABLE, 0 },
+
+    { ngx_string("ssl_client_raw_cert"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_raw_certificate,
+      NGX_HTTP_VAR_CHANGEABLE, 0 },
+
+    { ngx_string("ssl_client_s_dn"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_subject_dn, NGX_HTTP_VAR_CHANGEABLE, 0 },
+
+    { ngx_string("ssl_client_i_dn"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_issuer_dn, NGX_HTTP_VAR_CHANGEABLE, 0 },
+
+    { ngx_string("ssl_client_serial"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_serial_number, NGX_HTTP_VAR_CHANGEABLE, 0 },
+
+    { ngx_string("ssl_client_verify"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_client_verify, NGX_HTTP_VAR_CHANGEABLE, 0 },
+
+    { ngx_null_string, NULL, NULL, 0, 0, 0 }
+};
+
+
+static ngx_str_t ngx_http_ssl_sess_id_ctx = ngx_string("HTTP");
+
+
+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation
+
+static int
+ngx_http_ssl_alpn_select(ngx_ssl_conn_t *ssl_conn, const unsigned char **out,
+    unsigned char *outlen, const unsigned char *in, unsigned int inlen,
+    void *arg)
+{
+    unsigned int            srvlen;
+    unsigned char          *srv;
+#if (NGX_DEBUG)
+    unsigned int            i;
+#endif
+#if (NGX_HTTP_SPDY)
+    ngx_http_connection_t  *hc;
+#endif
+#if (NGX_HTTP_SPDY || NGX_DEBUG)
+    ngx_connection_t       *c;
+
+    c = ngx_ssl_get_connection(ssl_conn);
+#endif
+
+#if (NGX_DEBUG)
+    for (i = 0; i < inlen; i += in[i] + 1) {
+         ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                        "SSL ALPN supported by client: %*s", in[i], &in[i + 1]);
+    }
+#endif
+
+#if (NGX_HTTP_SPDY)
+    hc = c->data;
+
+    if (hc->addr_conf->spdy) {
+        srv = (unsigned char *) NGX_SPDY_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE;
+        srvlen = sizeof(NGX_SPDY_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE) - 1;
+
+    } else
+#endif
+    {
+        srv = (unsigned char *) NGX_HTTP_NPN_ADVERTISE;
+        srvlen = sizeof(NGX_HTTP_NPN_ADVERTISE) - 1;
+    }
+
+    if (SSL_select_next_proto((unsigned char **) out, outlen, srv, srvlen,
+                              in, inlen)
+        != OPENSSL_NPN_NEGOTIATED)
+    {
+        return SSL_TLSEXT_ERR_NOACK;
+    }
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
+                   "SSL ALPN selected: %*s", *outlen, *out);
+
+    return SSL_TLSEXT_ERR_OK;
+}
+
+#endif
+
+
+#ifdef TLSEXT_TYPE_next_proto_neg
+
+static int
+ngx_http_ssl_npn_advertised(ngx_ssl_conn_t *ssl_conn,
+    const unsigned char **out, unsigned int *outlen, void *arg)
+{
+#if (NGX_HTTP_SPDY || NGX_DEBUG)
+    ngx_connection_t  *c;
+
+    c = ngx_ssl_get_connection(ssl_conn);
+    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, "SSL NPN advertised");
+#endif
+
+#if (NGX_HTTP_SPDY)
+    {
+    ngx_http_connection_t  *hc;
+
+    hc = c->data;
+
+    if (hc->addr_conf->spdy) {
+        *out = (unsigned char *) NGX_SPDY_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE;
+        *outlen = sizeof(NGX_SPDY_NPN_ADVERTISE NGX_HTTP_NPN_ADVERTISE) - 1;
+
+        return SSL_TLSEXT_ERR_OK;
+    }
+    }
+#endif
+
+    *out = (unsigned char *) NGX_HTTP_NPN_ADVERTISE;
+    *outlen = sizeof(NGX_HTTP_NPN_ADVERTISE) - 1;
+
+    return SSL_TLSEXT_ERR_OK;
+}
+
+#endif
+
+
+static ngx_int_t
+ngx_http_ssl_static_variable(ngx_http_request_t *r,
+    ngx_http_variable_value_t *v, uintptr_t data)
+{
+    ngx_ssl_variable_handler_pt  handler = (ngx_ssl_variable_handler_pt) data;
+
+    size_t     len;
+    ngx_str_t  s;
+
+    if (r->connection->ssl) {
+
+        (void) handler(r->connection, NULL, &s);
+
+        v->data = s.data;
+
+        for (len = 0; v->data[len]; len++) { /* void */ }
+
+        v->len = len;
+        v->valid = 1;
+        v->no_cacheable = 0;
+        v->not_found = 0;
+
+        return NGX_OK;
+    }
+
+    v->not_found = 1;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_ssl_variable(ngx_http_request_t *r, ngx_http_variable_value_t *v,
+    uintptr_t data)
+{
+    ngx_ssl_variable_handler_pt  handler = (ngx_ssl_variable_handler_pt) data;
+
+    ngx_str_t  s;
+
+    if (r->connection->ssl) {
+
+        if (handler(r->connection, r->pool, &s) != NGX_OK) {
+            return NGX_ERROR;
+        }
+
+        v->len = s.len;
+        v->data = s.data;
+
+        if (v->len) {
+            v->valid = 1;
+            v->no_cacheable = 0;
+            v->not_found = 0;
+
+            return NGX_OK;
+        }
+    }
+
+    v->not_found = 1;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_ssl_add_variables(ngx_conf_t *cf)
+{
+    ngx_http_variable_t  *var, *v;
+
+    for (v = ngx_http_ssl_vars; v->name.len; v++) {
+        var = ngx_http_add_variable(cf, &v->name, v->flags);
+        if (var == NULL) {
+            return NGX_ERROR;
+        }
+
+        var->get_handler = v->get_handler;
+        var->data = v->data;
+    }
+
+    return NGX_OK;
+}
+
+
+static void *
+ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)
+{
+    ngx_http_ssl_srv_conf_t  *sscf;
+
+    sscf = ngx_pcalloc(cf->pool, sizeof(ngx_http_ssl_srv_conf_t));
+    if (sscf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc():
+     *
+     *     sscf->protocols = 0;
+     *     sscf->dhparam = { 0, NULL };
+     *     sscf->ecdh_curve = { 0, NULL };
+     *     sscf->client_certificate = { 0, NULL };
+     *     sscf->trusted_certificate = { 0, NULL };
+     *     sscf->crl = { 0, NULL };
+     *     sscf->ciphers = { 0, NULL };
+     *     sscf->shm_zone = NULL;
+     *     sscf->stapling_responder = { 0, NULL };
+     */
+
+    sscf->enable = NGX_CONF_UNSET;
+    sscf->prefer_server_ciphers = NGX_CONF_UNSET;
+    sscf->buffer_size = NGX_CONF_UNSET_SIZE;
+    sscf->verify = NGX_CONF_UNSET_UINT;
+    sscf->verify_depth = NGX_CONF_UNSET_UINT;
+    sscf->builtin_session_cache = NGX_CONF_UNSET;
+    sscf->session_timeout = NGX_CONF_UNSET;
+    sscf->certificates = NGX_CONF_UNSET_PTR;
+    sscf->certificate_keys = NGX_CONF_UNSET_PTR;
+    sscf->session_tickets = NGX_CONF_UNSET;
+    sscf->session_ticket_keys = NGX_CONF_UNSET_PTR;
+    sscf->stapling = NGX_CONF_UNSET;
+    sscf->stapling_verify = NGX_CONF_UNSET;
+    sscf->stapling_files = NGX_CONF_UNSET_PTR;
+
+    return sscf;
+}
+
+
+static char *
+ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
+{
+    ngx_http_ssl_srv_conf_t *prev = parent;
+    ngx_http_ssl_srv_conf_t *conf = child;
+
+    ngx_pool_cleanup_t  *cln;
+
+    if (conf->enable == NGX_CONF_UNSET) {
+        if (prev->enable == NGX_CONF_UNSET) {
+            conf->enable = 0;
+
+        } else {
+            conf->enable = prev->enable;
+            conf->file = prev->file;
+            conf->line = prev->line;
+        }
+    }
+
+    ngx_conf_merge_value(conf->session_timeout,
+                         prev->session_timeout, 300);
+
+    ngx_conf_merge_value(conf->prefer_server_ciphers,
+                         prev->prefer_server_ciphers, 0);
+
+    ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,
+                         (NGX_CONF_BITMASK_SET|NGX_SSL_SSLv3|NGX_SSL_TLSv1
+                          |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));
+
+    ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,
+                         NGX_SSL_BUFSIZE);
+
+    ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);
+    ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);
+
+    ngx_conf_merge_ptr_value(conf->certificates, prev->certificates,
+                         NGX_CONF_UNSET_PTR);
+    ngx_conf_merge_ptr_value(conf->certificate_keys, prev->certificate_keys,
+                         NGX_CONF_UNSET_PTR);
+
+    ngx_conf_merge_str_value(conf->dhparam, prev->dhparam, "");
+
+    ngx_conf_merge_str_value(conf->client_certificate, prev->client_certificate,
+                         "");
+    ngx_conf_merge_str_value(conf->trusted_certificate,
+                         prev->trusted_certificate, "");
+    ngx_conf_merge_str_value(conf->crl, prev->crl, "");
+
+    ngx_conf_merge_str_value(conf->ecdh_curve, prev->ecdh_curve,
+                         NGX_DEFAULT_ECDH_CURVE);
+
+    ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);
+
+    ngx_conf_merge_value(conf->stapling, prev->stapling, 0);
+    ngx_conf_merge_value(conf->stapling_verify, prev->stapling_verify, 0);
+    ngx_conf_merge_ptr_value(conf->stapling_files, prev->stapling_files,
+                         NGX_CONF_UNSET_PTR);
+    ngx_conf_merge_str_value(conf->stapling_responder,
+                         prev->stapling_responder, "");
+
+    conf->ssl.log = cf->log;
+
+    if ((conf->certificates == NGX_CONF_UNSET_PTR)
+           || (conf->certificates->nelts == 0)) {
+        if (conf->enable) {
+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                          "no \"ssl_certificate\" is defined for "
+                          "the \"ssl\" directive in %s:%ui",
+                          conf->file, conf->line);
+            return NGX_CONF_ERROR;
+        }
+        return NGX_CONF_OK;
+    }
+
+    if (ngx_ssl_create(&conf->ssl, conf->protocols, conf) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+  }
+
+#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME
+
+    if (SSL_CTX_set_tlsext_servername_callback(conf->ssl.ctx,
+                                               ngx_http_ssl_servername)
+        == 0)
+    {
+        ngx_log_error(NGX_LOG_WARN, cf->log, 0,
+            "nginx was built with SNI support, however, now it is linked "
+            "dynamically to an OpenSSL library which has no tlsext support, "
+            "therefore SNI is not available");
+    }
+
+#endif
+
+#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation
+    SSL_CTX_set_alpn_select_cb(conf->ssl.ctx, ngx_http_ssl_alpn_select, NULL);
+#endif
+
+#ifdef TLSEXT_TYPE_next_proto_neg
+    SSL_CTX_set_next_protos_advertised_cb(conf->ssl.ctx,
+                                          ngx_http_ssl_npn_advertised, NULL);
+#endif
+
+    cln = ngx_pool_cleanup_add(cf->pool, 0);
+    if (cln == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    cln->handler = ngx_ssl_cleanup_ctx;
+    cln->data = &conf->ssl;
+
+    if (ngx_ssl_certificate(cf, &conf->ssl, &conf->certificate,
+                            &conf->certificate_key)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+
+    if (SSL_CTX_set_cipher_list(conf->ssl.ctx,
+                                (const char *) conf->ciphers.data)
+        == 0)
+    {
+        ngx_ssl_error(NGX_LOG_EMERG, cf->log, 0,
+                      "SSL_CTX_set_cipher_list(\"%V\") failed",
+                      &conf->ciphers);
+        return NGX_CONF_ERROR;
+    }
+
+    conf->ssl.buffer_size = conf->buffer_size;
+
+    if (conf->verify) {
+
+        if (conf->client_certificate.len == 0 && conf->verify != 3) {
+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                          "no ssl_client_certificate for ssl_client_verify");
+            return NGX_CONF_ERROR;
+        }
+
+        if (ngx_ssl_client_certificate(cf, &conf->ssl,
+                                       &conf->client_certificate,
+                                       conf->verify_depth)
+            != NGX_OK)
+        {
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    if (ngx_ssl_trusted_certificate(cf, &conf->ssl,
+                                    &conf->trusted_certificate,
+                                    conf->verify_depth)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+
+    if (ngx_ssl_crl(cf, &conf->ssl, &conf->crl) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (conf->prefer_server_ciphers) {
+        SSL_CTX_set_options(conf->ssl.ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
+    }
+
+    /* a temporary 512-bit RSA key is required for export versions of MSIE */
+    SSL_CTX_set_tmp_rsa_callback(conf->ssl.ctx, ngx_ssl_rsa512_key_callback);
+
+    if (ngx_ssl_dhparam(cf, &conf->ssl, &conf->dhparam) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (ngx_ssl_ecdh_curve(cf, &conf->ssl, &conf->ecdh_curve) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_conf_merge_value(conf->builtin_session_cache,
+                         prev->builtin_session_cache, NGX_SSL_NONE_SCACHE);
+
+    if (conf->shm_zone == NULL) {
+        conf->shm_zone = prev->shm_zone;
+    }
+
+    if (ngx_ssl_session_cache(&conf->ssl, &ngx_http_ssl_sess_id_ctx,
+                              conf->builtin_session_cache,
+                              conf->shm_zone, conf->session_timeout)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_conf_merge_value(conf->session_tickets, prev->session_tickets, 1);
+
+#ifdef SSL_OP_NO_TICKET
+    if (!conf->session_tickets) {
+        SSL_CTX_set_options(conf->ssl.ctx, SSL_OP_NO_TICKET);
+    }
+#endif
+
+    ngx_conf_merge_ptr_value(conf->session_ticket_keys,
+                         prev->session_ticket_keys, NULL);
+
+    if (ngx_ssl_session_ticket_keys(cf, &conf->ssl, conf->session_ticket_keys)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+
+    if (conf->stapling) {
+
+        if (ngx_ssl_stapling(cf, &conf->ssl, &conf->stapling_file,
+                             &conf->stapling_responder, conf->stapling_verify)
+            != NGX_OK)
+        {
+            return NGX_CONF_ERROR;
+        }
+
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_http_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_http_ssl_srv_conf_t *sscf = conf;
+
+    char  *rv;
+
+    rv = ngx_conf_set_flag_slot(cf, cmd, conf);
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    sscf->file = cf->conf_file->file.name.data;
+    sscf->line = cf->conf_file->line;
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_http_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_http_ssl_srv_conf_t *sscf = conf;
+
+    size_t       len;
+    ngx_str_t   *value, name, size;
+    ngx_int_t    n;
+    ngx_uint_t   i, j;
+
+    value = cf->args->elts;
+
+    for (i = 1; i < cf->args->nelts; i++) {
+
+        if (ngx_strcmp(value[i].data, "off") == 0) {
+            sscf->builtin_session_cache = NGX_SSL_NO_SCACHE;
+            continue;
+        }
+
+        if (ngx_strcmp(value[i].data, "none") == 0) {
+            sscf->builtin_session_cache = NGX_SSL_NONE_SCACHE;
+            continue;
+        }
+
+        if (ngx_strcmp(value[i].data, "builtin") == 0) {
+            sscf->builtin_session_cache = NGX_SSL_DFLT_BUILTIN_SCACHE;
+            continue;
+        }
+
+        if (value[i].len > sizeof("builtin:") - 1
+            && ngx_strncmp(value[i].data, "builtin:", sizeof("builtin:") - 1)
+               == 0)
+        {
+            n = ngx_atoi(value[i].data + sizeof("builtin:") - 1,
+                         value[i].len - (sizeof("builtin:") - 1));
+
+            if (n == NGX_ERROR) {
+                goto invalid;
+            }
+
+            sscf->builtin_session_cache = n;
+
+            continue;
+        }
+
+        if (value[i].len > sizeof("shared:") - 1
+            && ngx_strncmp(value[i].data, "shared:", sizeof("shared:") - 1)
+               == 0)
+        {
+            len = 0;
+
+            for (j = sizeof("shared:") - 1; j < value[i].len; j++) {
+                if (value[i].data[j] == ':') {
+                    break;
+                }
+
+                len++;
+            }
+
+            if (len == 0) {
+                goto invalid;
+            }
+
+            name.len = len;
+            name.data = value[i].data + sizeof("shared:") - 1;
+
+            size.len = value[i].len - j - 1;
+            size.data = name.data + len + 1;
+
+            n = ngx_parse_size(&size);
+
+            if (n == NGX_ERROR) {
+                goto invalid;
+            }
+
+            if (n < (ngx_int_t) (8 * ngx_pagesize)) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                                   "session cache \"%V\" is too small",
+                                   &value[i]);
+
+                return NGX_CONF_ERROR;
+            }
+
+            sscf->shm_zone = ngx_shared_memory_add(cf, &name, n,
+                                                   &ngx_http_ssl_module);
+            if (sscf->shm_zone == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            sscf->shm_zone->init = ngx_ssl_session_cache_init;
+
+            continue;
+        }
+
+        goto invalid;
+    }
+
+    if (sscf->shm_zone && sscf->builtin_session_cache == NGX_CONF_UNSET) {
+        sscf->builtin_session_cache = NGX_SSL_NO_BUILTIN_SCACHE;
+    }
+
+    return NGX_CONF_OK;
+
+invalid:
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                       "invalid session cache \"%V\"", &value[i]);
+
+    return NGX_CONF_ERROR;
+}
+
+
+static ngx_int_t
+ngx_http_ssl_init(ngx_conf_t *cf)
+{
+    ngx_uint_t                   s;
+    ngx_http_ssl_srv_conf_t     *sscf;
+    ngx_http_core_loc_conf_t    *clcf;
+    ngx_http_core_srv_conf_t   **cscfp;
+    ngx_http_core_main_conf_t   *cmcf;
+
+    cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);
+    cscfp = cmcf->servers.elts;
+
+    for (s = 0; s < cmcf->servers.nelts; s++) {
+
+        sscf = cscfp[s]->ctx->srv_conf[ngx_http_ssl_module.ctx_index];
+
+        if (sscf->ssl.ctx == NULL || !sscf->stapling) {
+            continue;
+        }
+
+        clcf = cscfp[s]->ctx->loc_conf[ngx_http_core_module.ctx_index];
+
+        if (ngx_ssl_stapling_resolver(cf, &sscf->ssl, clcf->resolver,
+                                      clcf->resolver_timeout)
+            != NGX_OK)
+        {
+            return NGX_ERROR;
+        }
+    }
+
+    return NGX_OK;
+}
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/http/modules/ngx_http_ssl_module.c.rej workspace/src/http/modules/ngx_http_ssl_module.c.rej
--- sources/1.5.13/nginx-1.5.13/src/http/modules/ngx_http_ssl_module.c.rej	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/http/modules/ngx_http_ssl_module.c.rej	2014-03-28 21:15:31.000000000 -0700
@@ -0,0 +1,433 @@
+***************
+*** 74,99 ****
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+        ngx_http_ssl_enable,
+        NGX_HTTP_SRV_CONF_OFFSET,
+        offsetof(ngx_http_ssl_srv_conf_t, enable),
+        NULL },
+
+      { ngx_string("ssl_certificate"),
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+-       ngx_conf_set_str_slot,
+        NGX_HTTP_SRV_CONF_OFFSET,
+-       offsetof(ngx_http_ssl_srv_conf_t, certificate),
+        NULL },
+
+      { ngx_string("ssl_certificate_key"),
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+-       ngx_conf_set_str_slot,
+        NGX_HTTP_SRV_CONF_OFFSET,
+-       offsetof(ngx_http_ssl_srv_conf_t, certificate_key),
+        NULL },
+
+      { ngx_string("ssl_dhparam"),
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+        ngx_conf_set_str_slot,
+        NGX_HTTP_SRV_CONF_OFFSET,
+        offsetof(ngx_http_ssl_srv_conf_t, dhparam),
+        NULL },
+--- 74,99 ----
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+        ngx_http_ssl_enable,
+        NGX_HTTP_SRV_CONF_OFFSET,
+        offsetof(ngx_http_ssl_srv_conf_t, enable),
+        NULL },
+
+      { ngx_string("ssl_certificate"),
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
++       ngx_conf_set_str_array_slot,
+        NGX_HTTP_SRV_CONF_OFFSET,
++       offsetof(ngx_http_ssl_srv_conf_t, certificates),
+        NULL },
+
+      { ngx_string("ssl_certificate_key"),
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
++       ngx_conf_set_str_array_slot,
+        NGX_HTTP_SRV_CONF_OFFSET,
++       offsetof(ngx_http_ssl_srv_conf_t, certificate_keys),
+        NULL },
+
+      { ngx_string("ssl_dhparam"),
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+        ngx_conf_set_str_slot,
+        NGX_HTTP_SRV_CONF_OFFSET,
+        offsetof(ngx_http_ssl_srv_conf_t, dhparam),
+        NULL },
+***************
+*** 186,204 ****
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+        ngx_conf_set_flag_slot,
+        NGX_HTTP_SRV_CONF_OFFSET,
+        offsetof(ngx_http_ssl_srv_conf_t, stapling),
+        NULL },
+
+      { ngx_string("ssl_stapling_file"),
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+-       ngx_conf_set_str_slot,
+        NGX_HTTP_SRV_CONF_OFFSET,
+-       offsetof(ngx_http_ssl_srv_conf_t, stapling_file),
+        NULL },
+
+      { ngx_string("ssl_stapling_responder"),
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+        ngx_conf_set_str_slot,
+        NGX_HTTP_SRV_CONF_OFFSET,
+        offsetof(ngx_http_ssl_srv_conf_t, stapling_responder),
+        NULL },
+--- 186,204 ----
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_FLAG,
+        ngx_conf_set_flag_slot,
+        NGX_HTTP_SRV_CONF_OFFSET,
+        offsetof(ngx_http_ssl_srv_conf_t, stapling),
+        NULL },
+
+      { ngx_string("ssl_stapling_file"),
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
++       ngx_conf_set_str_array_slot,
+        NGX_HTTP_SRV_CONF_OFFSET,
++       offsetof(ngx_http_ssl_srv_conf_t, stapling_files),
+        NULL },
+
+      { ngx_string("ssl_stapling_responder"),
+        NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
+        ngx_conf_set_str_slot,
+        NGX_HTTP_SRV_CONF_OFFSET,
+        offsetof(ngx_http_ssl_srv_conf_t, stapling_responder),
+        NULL },
+***************
+*** 412,449 ****
+      if (sscf == NULL) {
+          return NULL;
+      }
+
+      /*
+       * set by ngx_pcalloc():
+       *
+       *     sscf->protocols = 0;
+-      *     sscf->certificate = { 0, NULL };
+-      *     sscf->certificate_key = { 0, NULL };
+       *     sscf->dhparam = { 0, NULL };
+       *     sscf->ecdh_curve = { 0, NULL };
+       *     sscf->client_certificate = { 0, NULL };
+       *     sscf->trusted_certificate = { 0, NULL };
+       *     sscf->crl = { 0, NULL };
+       *     sscf->ciphers = { 0, NULL };
+       *     sscf->shm_zone = NULL;
+-      *     sscf->stapling_file = { 0, NULL };
+       *     sscf->stapling_responder = { 0, NULL };
+       */
+
+      sscf->enable = NGX_CONF_UNSET;
+      sscf->prefer_server_ciphers = NGX_CONF_UNSET;
+      sscf->verify = NGX_CONF_UNSET_UINT;
+      sscf->verify_depth = NGX_CONF_UNSET_UINT;
+      sscf->builtin_session_cache = NGX_CONF_UNSET;
+      sscf->session_timeout = NGX_CONF_UNSET;
+      sscf->session_ticket_keys = NGX_CONF_UNSET_PTR;
+      sscf->stapling = NGX_CONF_UNSET;
+      sscf->stapling_verify = NGX_CONF_UNSET;
+
+      return sscf;
+  }
+
+
+  static char *
+  ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
+  {
+--- 412,449 ----
+      if (sscf == NULL) {
+          return NULL;
+      }
+
+      /*
+       * set by ngx_pcalloc():
+       *
+       *     sscf->protocols = 0;
+       *     sscf->dhparam = { 0, NULL };
+       *     sscf->ecdh_curve = { 0, NULL };
+       *     sscf->client_certificate = { 0, NULL };
+       *     sscf->trusted_certificate = { 0, NULL };
+       *     sscf->crl = { 0, NULL };
+       *     sscf->ciphers = { 0, NULL };
+       *     sscf->shm_zone = NULL;
+       *     sscf->stapling_responder = { 0, NULL };
+       */
+
+      sscf->enable = NGX_CONF_UNSET;
+      sscf->prefer_server_ciphers = NGX_CONF_UNSET;
+      sscf->verify = NGX_CONF_UNSET_UINT;
+      sscf->verify_depth = NGX_CONF_UNSET_UINT;
+      sscf->builtin_session_cache = NGX_CONF_UNSET;
+      sscf->session_timeout = NGX_CONF_UNSET;
++     sscf->certificates = NGX_CONF_UNSET_PTR;
++     sscf->certificate_keys = NGX_CONF_UNSET_PTR;
+      sscf->session_ticket_keys = NGX_CONF_UNSET_PTR;
+      sscf->stapling = NGX_CONF_UNSET;
+      sscf->stapling_verify = NGX_CONF_UNSET;
++     sscf->stapling_files = NGX_CONF_UNSET_PTR;
+
+      return sscf;
+  }
+
+
+  static char *
+  ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
+  {
+***************
+*** 471,540 ****
+
+      ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,
+                           (NGX_CONF_BITMASK_SET|NGX_SSL_SSLv3|NGX_SSL_TLSv1
+                            |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));
+
+      ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);
+      ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);
+
+-     ngx_conf_merge_str_value(conf->certificate, prev->certificate, "");
+-     ngx_conf_merge_str_value(conf->certificate_key, prev->certificate_key, "");
+
+      ngx_conf_merge_str_value(conf->dhparam, prev->dhparam, "");
+
+      ngx_conf_merge_str_value(conf->client_certificate, prev->client_certificate,
+                           "");
+      ngx_conf_merge_str_value(conf->trusted_certificate,
+                           prev->trusted_certificate, "");
+      ngx_conf_merge_str_value(conf->crl, prev->crl, "");
+
+      ngx_conf_merge_str_value(conf->ecdh_curve, prev->ecdh_curve,
+                           NGX_DEFAULT_ECDH_CURVE);
+
+      ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);
+
+      ngx_conf_merge_value(conf->stapling, prev->stapling, 0);
+      ngx_conf_merge_value(conf->stapling_verify, prev->stapling_verify, 0);
+-     ngx_conf_merge_str_value(conf->stapling_file, prev->stapling_file, "");
+      ngx_conf_merge_str_value(conf->stapling_responder,
+                           prev->stapling_responder, "");
+
+      conf->ssl.log = cf->log;
+
+-     if (conf->enable) {
+-
+-         if (conf->certificate.len == 0) {
+              ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                            "no \"ssl_certificate\" is defined for "
+                            "the \"ssl\" directive in %s:%ui",
+                            conf->file, conf->line);
+              return NGX_CONF_ERROR;
+          }
+-
+-         if (conf->certificate_key.len == 0) {
+-             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+-                           "no \"ssl_certificate_key\" is defined for "
+-                           "the \"ssl\" directive in %s:%ui",
+-                           conf->file, conf->line);
+-             return NGX_CONF_ERROR;
+-         }
+-
+-     } else {
+-
+-         if (conf->certificate.len == 0) {
+-             return NGX_CONF_OK;
+-         }
+-
+-         if (conf->certificate_key.len == 0) {
+-             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+-                           "no \"ssl_certificate_key\" is defined "
+-                           "for certificate \"%V\"", &conf->certificate);
+-             return NGX_CONF_ERROR;
+-         }
+      }
+
+      if (ngx_ssl_create(&conf->ssl, conf->protocols, conf) != NGX_OK) {
+          return NGX_CONF_ERROR;
+      }
+
+  #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME
+
+--- 471,523 ----
+
+      ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,
+                           (NGX_CONF_BITMASK_SET|NGX_SSL_SSLv3|NGX_SSL_TLSv1
+                            |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));
+
+      ngx_conf_merge_uint_value(conf->verify, prev->verify, 0);
+      ngx_conf_merge_uint_value(conf->verify_depth, prev->verify_depth, 1);
+
++     ngx_conf_merge_ptr_value(conf->certificates, prev->certificates,
++                          NGX_CONF_UNSET_PTR);
++     ngx_conf_merge_ptr_value(conf->certificate_keys, prev->certificate_keys,
++                          NGX_CONF_UNSET_PTR);
+
+      ngx_conf_merge_str_value(conf->dhparam, prev->dhparam, "");
+
+      ngx_conf_merge_str_value(conf->client_certificate, prev->client_certificate,
+                           "");
+      ngx_conf_merge_str_value(conf->trusted_certificate,
+                           prev->trusted_certificate, "");
+      ngx_conf_merge_str_value(conf->crl, prev->crl, "");
+
+      ngx_conf_merge_str_value(conf->ecdh_curve, prev->ecdh_curve,
+                           NGX_DEFAULT_ECDH_CURVE);
+
+      ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);
+
+      ngx_conf_merge_value(conf->stapling, prev->stapling, 0);
+      ngx_conf_merge_value(conf->stapling_verify, prev->stapling_verify, 0);
++     ngx_conf_merge_ptr_value(conf->stapling_files, prev->stapling_files,
++                          NGX_CONF_UNSET_PTR);
+      ngx_conf_merge_str_value(conf->stapling_responder,
+                           prev->stapling_responder, "");
+
+      conf->ssl.log = cf->log;
+
++     if ((conf->certificates == NGX_CONF_UNSET_PTR)
++             || (conf->certificates->nelts == 0)) {
++         if (conf->enable) {
+              ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                            "no \"ssl_certificate\" is defined for "
+                            "the \"ssl\" directive in %s:%ui",
+                            conf->file, conf->line);
+              return NGX_CONF_ERROR;
+          }
++         return NGX_CONF_OK;
+      }
+
+      if (ngx_ssl_create(&conf->ssl, conf->protocols, conf) != NGX_OK) {
+          return NGX_CONF_ERROR;
+      }
+
+  #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME
+
+***************
+*** 558,580 ****
+      cln = ngx_pool_cleanup_add(cf->pool, 0);
+      if (cln == NULL) {
+          return NGX_CONF_ERROR;
+      }
+
+      cln->handler = ngx_ssl_cleanup_ctx;
+      cln->data = &conf->ssl;
+
+-     if (ngx_ssl_certificate(cf, &conf->ssl, &conf->certificate,
+-                             &conf->certificate_key)
+-         != NGX_OK)
+-     {
+-         return NGX_CONF_ERROR;
+-     }
+-
+      if (SSL_CTX_set_cipher_list(conf->ssl.ctx,
+                                  (const char *) conf->ciphers.data)
+          == 0)
+      {
+          ngx_ssl_error(NGX_LOG_EMERG, cf->log, 0,
+                        "SSL_CTX_set_cipher_list(\"%V\") failed",
+                        &conf->ciphers);
+          return NGX_CONF_ERROR;
+--- 541,556 ----
+      cln = ngx_pool_cleanup_add(cf->pool, 0);
+      if (cln == NULL) {
+          return NGX_CONF_ERROR;
+      }
+
+      cln->handler = ngx_ssl_cleanup_ctx;
+      cln->data = &conf->ssl;
+
+      if (SSL_CTX_set_cipher_list(conf->ssl.ctx,
+                                  (const char *) conf->ciphers.data)
+          == 0)
+      {
+          ngx_ssl_error(NGX_LOG_EMERG, cf->log, 0,
+                        "SSL_CTX_set_cipher_list(\"%V\") failed",
+                        &conf->ciphers);
+          return NGX_CONF_ERROR;
+***************
+*** 600,615 ****
+      if (ngx_ssl_trusted_certificate(cf, &conf->ssl,
+                                      &conf->trusted_certificate,
+                                      conf->verify_depth)
+          != NGX_OK)
+      {
+          return NGX_CONF_ERROR;
+      }
+
+      if (ngx_ssl_crl(cf, &conf->ssl, &conf->crl) != NGX_OK) {
+          return NGX_CONF_ERROR;
+      }
+
+      if (conf->prefer_server_ciphers) {
+          SSL_CTX_set_options(conf->ssl.ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
+      }
+
+--- 576,600 ----
+      if (ngx_ssl_trusted_certificate(cf, &conf->ssl,
+                                      &conf->trusted_certificate,
+                                      conf->verify_depth)
+          != NGX_OK)
+      {
+          return NGX_CONF_ERROR;
+      }
+
++     if (ngx_ssl_certificates(cf, &conf->ssl, conf->certificates,
++                              conf->certificate_keys, conf->stapling,
++                              conf->stapling_files, &conf->stapling_responder,
++                              conf->stapling_verify)
++         != NGX_OK)
++     {
++         return NGX_CONF_ERROR;
++     }
++
+      if (ngx_ssl_crl(cf, &conf->ssl, &conf->crl) != NGX_OK) {
+          return NGX_CONF_ERROR;
+      }
+
+      if (conf->prefer_server_ciphers) {
+          SSL_CTX_set_options(conf->ssl.ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
+      }
+
+***************
+*** 643,669 ****
+                           prev->session_ticket_keys, NULL);
+
+      if (ngx_ssl_session_ticket_keys(cf, &conf->ssl, conf->session_ticket_keys)
+          != NGX_OK)
+      {
+          return NGX_CONF_ERROR;
+      }
+
+-     if (conf->stapling) {
+-
+-         if (ngx_ssl_stapling(cf, &conf->ssl, &conf->stapling_file,
+-                              &conf->stapling_responder, conf->stapling_verify)
+-             != NGX_OK)
+-         {
+-             return NGX_CONF_ERROR;
+-         }
+-
+-     }
+-
+      return NGX_CONF_OK;
+  }
+
+
+  static char *
+  ngx_http_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+  {
+      ngx_http_ssl_srv_conf_t *sscf = conf;
+--- 628,643 ----
+                           prev->session_ticket_keys, NULL);
+
+      if (ngx_ssl_session_ticket_keys(cf, &conf->ssl, conf->session_ticket_keys)
+          != NGX_OK)
+      {
+          return NGX_CONF_ERROR;
+      }
+
+      return NGX_CONF_OK;
+  }
+
+
+  static char *
+  ngx_http_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+  {
+      ngx_http_ssl_srv_conf_t *sscf = conf;
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/http/modules/ngx_http_ssl_module.h workspace/src/http/modules/ngx_http_ssl_module.h
--- sources/1.5.13/nginx-1.5.13/src/http/modules/ngx_http_ssl_module.h	2014-03-28 21:15:34.000000000 -0700
+++ workspace/src/http/modules/ngx_http_ssl_module.h	2014-03-28 21:15:31.000000000 -0700
@@ -32,8 +32,8 @@

     time_t                          session_timeout;

-    ngx_str_t                       certificate;
-    ngx_str_t                       certificate_key;
+    ngx_array_t                    *certificates;
+    ngx_array_t                    *certificate_keys;
     ngx_str_t                       dhparam;
     ngx_str_t                       ecdh_curve;
     ngx_str_t                       client_certificate;
@@ -49,7 +49,7 @@

     ngx_flag_t                      stapling;
     ngx_flag_t                      stapling_verify;
-    ngx_str_t                       stapling_file;
+    ngx_array_t                    *stapling_files;
     ngx_str_t                       stapling_responder;

     u_char                         *file;
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/http/modules/ngx_http_ssl_module.h.orig workspace/src/http/modules/ngx_http_ssl_module.h.orig
--- sources/1.5.13/nginx-1.5.13/src/http/modules/ngx_http_ssl_module.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/http/modules/ngx_http_ssl_module.h.orig	2014-03-28 21:14:16.000000000 -0700
@@ -0,0 +1,63 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#ifndef _NGX_HTTP_SSL_H_INCLUDED_
+#define _NGX_HTTP_SSL_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_http.h>
+
+
+typedef struct {
+    ngx_flag_t                      enable;
+
+    ngx_ssl_t                       ssl;
+
+    ngx_flag_t                      prefer_server_ciphers;
+
+    ngx_uint_t                      protocols;
+
+    ngx_uint_t                      verify;
+    ngx_uint_t                      verify_depth;
+
+    size_t                          buffer_size;
+
+    ssize_t                         builtin_session_cache;
+
+    time_t                          session_timeout;
+
+    ngx_array_t                    *certificates;
+    ngx_array_t                    *certificate_keys;
+    ngx_str_t                       dhparam;
+    ngx_str_t                       ecdh_curve;
+    ngx_str_t                       client_certificate;
+    ngx_str_t                       trusted_certificate;
+    ngx_str_t                       crl;
+
+    ngx_str_t                       ciphers;
+
+    ngx_shm_zone_t                 *shm_zone;
+
+    ngx_flag_t                      session_tickets;
+    ngx_array_t                    *session_ticket_keys;
+
+    ngx_flag_t                      stapling;
+    ngx_flag_t                      stapling_verify;
+    ngx_array_t                    *stapling_files;
+    ngx_str_t                       stapling_responder;
+
+    u_char                         *file;
+    ngx_uint_t                      line;
+} ngx_http_ssl_srv_conf_t;
+
+
+extern ngx_module_t  ngx_http_ssl_module;
+
+
+#endif /* _NGX_HTTP_SSL_H_INCLUDED_ */
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/http/modules/ngx_http_ssl_module.h.rej workspace/src/http/modules/ngx_http_ssl_module.h.rej
--- sources/1.5.13/nginx-1.5.13/src/http/modules/ngx_http_ssl_module.h.rej	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/http/modules/ngx_http_ssl_module.h.rej	2014-03-28 21:15:31.000000000 -0700
@@ -0,0 +1,69 @@
+***************
+*** 25,57 ****
+
+      ngx_uint_t                      verify;
+      ngx_uint_t                      verify_depth;
+
+      ssize_t                         builtin_session_cache;
+
+      time_t                          session_timeout;
+
+-     ngx_str_t                       certificate;
+-     ngx_str_t                       certificate_key;
+      ngx_str_t                       dhparam;
+      ngx_str_t                       ecdh_curve;
+      ngx_str_t                       client_certificate;
+      ngx_str_t                       trusted_certificate;
+      ngx_str_t                       crl;
+
+      ngx_str_t                       ciphers;
+
+      ngx_shm_zone_t                 *shm_zone;
+
+      ngx_array_t                    *session_ticket_keys;
+
+      ngx_flag_t                      stapling;
+      ngx_flag_t                      stapling_verify;
+-     ngx_str_t                       stapling_file;
+      ngx_str_t                       stapling_responder;
+
+      u_char                         *file;
+      ngx_uint_t                      line;
+  } ngx_http_ssl_srv_conf_t;
+
+
+  extern ngx_module_t  ngx_http_ssl_module;
+--- 25,57 ----
+
+      ngx_uint_t                      verify;
+      ngx_uint_t                      verify_depth;
+
+      ssize_t                         builtin_session_cache;
+
+      time_t                          session_timeout;
+
++     ngx_array_t                    *certificates;
++     ngx_array_t                    *certificate_keys;
+      ngx_str_t                       dhparam;
+      ngx_str_t                       ecdh_curve;
+      ngx_str_t                       client_certificate;
+      ngx_str_t                       trusted_certificate;
+      ngx_str_t                       crl;
+
+      ngx_str_t                       ciphers;
+
+      ngx_shm_zone_t                 *shm_zone;
+
+      ngx_array_t                    *session_ticket_keys;
+
+      ngx_flag_t                      stapling;
+      ngx_flag_t                      stapling_verify;
++     ngx_array_t                    *stapling_files;
+      ngx_str_t                       stapling_responder;
+
+      u_char                         *file;
+      ngx_uint_t                      line;
+  } ngx_http_ssl_srv_conf_t;
+
+
+  extern ngx_module_t  ngx_http_ssl_module;
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/http/ngx_http_header_filter_module.c workspace/src/http/ngx_http_header_filter_module.c
--- sources/1.5.13/nginx-1.5.13/src/http/ngx_http_header_filter_module.c	2014-03-28 21:15:34.000000000 -0700
+++ workspace/src/http/ngx_http_header_filter_module.c	2014-03-28 21:14:16.000000000 -0700
@@ -46,8 +46,8 @@
 };


-static char ngx_http_server_string[] = "Server: nginx" CRLF;
-static char ngx_http_server_full_string[] = "Server: " NGINX_VER CRLF;
+static char ngx_http_server_string[] = "Server: K9/" CRLF;
+static char ngx_http_server_full_string[] = "Server: Keen/K9/" NGINX_VER CRLF;


 static ngx_str_t ngx_http_status_lines[] = {
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/http/ngx_http_header_filter_module.c.rej workspace/src/http/ngx_http_header_filter_module.c.rej
--- sources/1.5.13/nginx-1.5.13/src/http/ngx_http_header_filter_module.c.rej	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/http/ngx_http_header_filter_module.c.rej	2014-03-28 21:15:31.000000000 -0700
@@ -0,0 +1,19 @@
+***************
+*** 46,53 ****
+  };
+
+
+- static char ngx_http_server_string[] = "Server: nginx" CRLF;
+- static char ngx_http_server_full_string[] = "Server: " NGINX_VER CRLF;
+
+
+  static ngx_str_t ngx_http_status_lines[] = {
+--- 46,53 ----
+  };
+
+
++ static char ngx_http_server_string[] = "Server: K9/" CRLF;
++ static char ngx_http_server_full_string[] = "Server: Keen/K9/" NGINX_VER CRLF;
+
+
+  static ngx_str_t ngx_http_status_lines[] = {
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/mail/ngx_mail_ssl_module.c workspace/src/mail/ngx_mail_ssl_module.c
--- sources/1.5.13/nginx-1.5.13/src/mail/ngx_mail_ssl_module.c	2014-03-28 21:15:34.000000000 -0700
+++ workspace/src/mail/ngx_mail_ssl_module.c	2014-03-28 21:15:21.000000000 -0700
@@ -62,16 +62,16 @@

     { ngx_string("ssl_certificate"),
       NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
-      ngx_conf_set_str_slot,
+      ngx_conf_set_str_array_slot,
       NGX_MAIL_SRV_CONF_OFFSET,
-      offsetof(ngx_mail_ssl_conf_t, certificate),
+      offsetof(ngx_mail_ssl_conf_t, certificates),
       NULL },

     { ngx_string("ssl_certificate_key"),
       NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
-      ngx_conf_set_str_slot,
+      ngx_conf_set_str_array_slot,
       NGX_MAIL_SRV_CONF_OFFSET,
-      offsetof(ngx_mail_ssl_conf_t, certificate_key),
+      offsetof(ngx_mail_ssl_conf_t, certificate_keys),
       NULL },

     { ngx_string("ssl_dhparam"),
@@ -185,8 +185,6 @@
      * set by ngx_pcalloc():
      *
      *     scf->protocols = 0;
-     *     scf->certificate = { 0, NULL };
-     *     scf->certificate_key = { 0, NULL };
      *     scf->dhparam = { 0, NULL };
      *     scf->ecdh_curve = { 0, NULL };
      *     scf->ciphers = { 0, NULL };
@@ -198,6 +196,8 @@
     scf->prefer_server_ciphers = NGX_CONF_UNSET;
     scf->builtin_session_cache = NGX_CONF_UNSET;
     scf->session_timeout = NGX_CONF_UNSET;
+    scf->certificates = NGX_CONF_UNSET_PTR;
+    scf->certificate_keys = NGX_CONF_UNSET_PTR;
     scf->session_tickets = NGX_CONF_UNSET;
     scf->session_ticket_keys = NGX_CONF_UNSET_PTR;

@@ -228,8 +228,10 @@
                          (NGX_CONF_BITMASK_SET|NGX_SSL_SSLv3|NGX_SSL_TLSv1
                           |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));

-    ngx_conf_merge_str_value(conf->certificate, prev->certificate, "");
-    ngx_conf_merge_str_value(conf->certificate_key, prev->certificate_key, "");
+    ngx_conf_merge_ptr_value(conf->certificates, prev->certificates,
+                         NGX_CONF_UNSET_PTR);
+    ngx_conf_merge_ptr_value(conf->certificate_keys, prev->certificate_keys,
+                         NGX_CONF_UNSET_PTR);

     ngx_conf_merge_str_value(conf->dhparam, prev->dhparam, "");

@@ -256,39 +258,18 @@
         conf->line = prev->line;
     }

+    if ((conf->certificates == NGX_CONF_UNSET_PTR)
+            || (conf->certificates->nelts == 0)) {
     if (*mode) {
-
-        if (conf->certificate.len == 0) {
             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
                           "no \"ssl_certificate\" is defined for "
                           "the \"%s\" directive in %s:%ui",
                           mode, conf->file, conf->line);
             return NGX_CONF_ERROR;
         }
-
-        if (conf->certificate_key.len == 0) {
-            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
-                          "no \"ssl_certificate_key\" is defined for "
-                          "the \"%s\" directive in %s:%ui",
-                          mode, conf->file, conf->line);
-            return NGX_CONF_ERROR;
-        }
-
-    } else {
-
-        if (conf->certificate.len == 0) {
             return NGX_CONF_OK;
         }

-        if (conf->certificate_key.len == 0) {
-            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
-                          "no \"ssl_certificate_key\" is defined "
-                          "for certificate \"%V\"",
-                          &conf->certificate);
-            return NGX_CONF_ERROR;
-        }
-    }
-
     if (ngx_ssl_create(&conf->ssl, conf->protocols, NULL) != NGX_OK) {
         return NGX_CONF_ERROR;
     }
@@ -301,8 +282,8 @@
     cln->handler = ngx_ssl_cleanup_ctx;
     cln->data = &conf->ssl;

-    if (ngx_ssl_certificate(cf, &conf->ssl, &conf->certificate,
-                            &conf->certificate_key)
+    if (ngx_ssl_certificates(cf, &conf->ssl, conf->certificates,
+                             conf->certificate_keys, 0, NULL, NULL, 0)
         != NGX_OK)
     {
         return NGX_CONF_ERROR;
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/mail/ngx_mail_ssl_module.c.orig workspace/src/mail/ngx_mail_ssl_module.c.orig
--- sources/1.5.13/nginx-1.5.13/src/mail/ngx_mail_ssl_module.c.orig	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/mail/ngx_mail_ssl_module.c.orig	2014-03-28 20:55:34.000000000 -0700
@@ -0,0 +1,533 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_mail.h>
+
+
+#define NGX_DEFAULT_CIPHERS     "HIGH:!aNULL:!MD5"
+#define NGX_DEFAULT_ECDH_CURVE  "prime256v1"
+
+
+static void *ngx_mail_ssl_create_conf(ngx_conf_t *cf);
+static char *ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child);
+
+static char *ngx_mail_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_mail_ssl_starttls(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+static char *ngx_mail_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd,
+    void *conf);
+
+
+static ngx_conf_enum_t  ngx_mail_starttls_state[] = {
+    { ngx_string("off"), NGX_MAIL_STARTTLS_OFF },
+    { ngx_string("on"), NGX_MAIL_STARTTLS_ON },
+    { ngx_string("only"), NGX_MAIL_STARTTLS_ONLY },
+    { ngx_null_string, 0 }
+};
+
+
+
+static ngx_conf_bitmask_t  ngx_mail_ssl_protocols[] = {
+    { ngx_string("SSLv2"), NGX_SSL_SSLv2 },
+    { ngx_string("SSLv3"), NGX_SSL_SSLv3 },
+    { ngx_string("TLSv1"), NGX_SSL_TLSv1 },
+    { ngx_string("TLSv1.1"), NGX_SSL_TLSv1_1 },
+    { ngx_string("TLSv1.2"), NGX_SSL_TLSv1_2 },
+    { ngx_null_string, 0 }
+};
+
+
+static ngx_command_t  ngx_mail_ssl_commands[] = {
+
+    { ngx_string("ssl"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,
+      ngx_mail_ssl_enable,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, enable),
+      NULL },
+
+    { ngx_string("starttls"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_mail_ssl_starttls,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, starttls),
+      ngx_mail_starttls_state },
+
+    { ngx_string("ssl_certificate"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, certificate),
+      NULL },
+
+    { ngx_string("ssl_certificate_key"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, certificate_key),
+      NULL },
+
+    { ngx_string("ssl_dhparam"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, dhparam),
+      NULL },
+
+    { ngx_string("ssl_ecdh_curve"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, ecdh_curve),
+      NULL },
+
+    { ngx_string("ssl_protocols"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_1MORE,
+      ngx_conf_set_bitmask_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, protocols),
+      &ngx_mail_ssl_protocols },
+
+    { ngx_string("ssl_ciphers"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, ciphers),
+      NULL },
+
+    { ngx_string("ssl_prefer_server_ciphers"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, prefer_server_ciphers),
+      NULL },
+
+    { ngx_string("ssl_session_cache"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE12,
+      ngx_mail_ssl_session_cache,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("ssl_session_tickets"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, session_tickets),
+      NULL },
+
+    { ngx_string("ssl_session_ticket_key"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_array_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, session_ticket_keys),
+      NULL },
+
+    { ngx_string("ssl_session_timeout"),
+      NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_sec_slot,
+      NGX_MAIL_SRV_CONF_OFFSET,
+      offsetof(ngx_mail_ssl_conf_t, session_timeout),
+      NULL },
+
+      ngx_null_command
+};
+
+
+static ngx_mail_module_t  ngx_mail_ssl_module_ctx = {
+    NULL,                                  /* protocol */
+
+    NULL,                                  /* create main configuration */
+    NULL,                                  /* init main configuration */
+
+    ngx_mail_ssl_create_conf,              /* create server configuration */
+    ngx_mail_ssl_merge_conf                /* merge server configuration */
+};
+
+
+ngx_module_t  ngx_mail_ssl_module = {
+    NGX_MODULE_V1,
+    &ngx_mail_ssl_module_ctx,              /* module context */
+    ngx_mail_ssl_commands,                 /* module directives */
+    NGX_MAIL_MODULE,                       /* module type */
+    NULL,                                  /* init master */
+    NULL,                                  /* init module */
+    NULL,                                  /* init process */
+    NULL,                                  /* init thread */
+    NULL,                                  /* exit thread */
+    NULL,                                  /* exit process */
+    NULL,                                  /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static ngx_str_t ngx_mail_ssl_sess_id_ctx = ngx_string("MAIL");
+
+
+static void *
+ngx_mail_ssl_create_conf(ngx_conf_t *cf)
+{
+    ngx_mail_ssl_conf_t  *scf;
+
+    scf = ngx_pcalloc(cf->pool, sizeof(ngx_mail_ssl_conf_t));
+    if (scf == NULL) {
+        return NULL;
+    }
+
+    /*
+     * set by ngx_pcalloc():
+     *
+     *     scf->protocols = 0;
+     *     scf->certificate = { 0, NULL };
+     *     scf->certificate_key = { 0, NULL };
+     *     scf->dhparam = { 0, NULL };
+     *     scf->ecdh_curve = { 0, NULL };
+     *     scf->ciphers = { 0, NULL };
+     *     scf->shm_zone = NULL;
+     */
+
+    scf->enable = NGX_CONF_UNSET;
+    scf->starttls = NGX_CONF_UNSET_UINT;
+    scf->prefer_server_ciphers = NGX_CONF_UNSET;
+    scf->builtin_session_cache = NGX_CONF_UNSET;
+    scf->session_timeout = NGX_CONF_UNSET;
+    scf->session_tickets = NGX_CONF_UNSET;
+    scf->session_ticket_keys = NGX_CONF_UNSET_PTR;
+
+    return scf;
+}
+
+
+static char *
+ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)
+{
+    ngx_mail_ssl_conf_t *prev = parent;
+    ngx_mail_ssl_conf_t *conf = child;
+
+    char                *mode;
+    ngx_pool_cleanup_t  *cln;
+
+    ngx_conf_merge_value(conf->enable, prev->enable, 0);
+    ngx_conf_merge_uint_value(conf->starttls, prev->starttls,
+                         NGX_MAIL_STARTTLS_OFF);
+
+    ngx_conf_merge_value(conf->session_timeout,
+                         prev->session_timeout, 300);
+
+    ngx_conf_merge_value(conf->prefer_server_ciphers,
+                         prev->prefer_server_ciphers, 0);
+
+    ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,
+                         (NGX_CONF_BITMASK_SET|NGX_SSL_SSLv3|NGX_SSL_TLSv1
+                          |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));
+
+    ngx_conf_merge_str_value(conf->certificate, prev->certificate, "");
+    ngx_conf_merge_str_value(conf->certificate_key, prev->certificate_key, "");
+
+    ngx_conf_merge_str_value(conf->dhparam, prev->dhparam, "");
+
+    ngx_conf_merge_str_value(conf->ecdh_curve, prev->ecdh_curve,
+                         NGX_DEFAULT_ECDH_CURVE);
+
+    ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);
+
+
+    conf->ssl.log = cf->log;
+
+    if (conf->enable) {
+       mode = "ssl";
+
+    } else if (conf->starttls != NGX_MAIL_STARTTLS_OFF) {
+       mode = "starttls";
+
+    } else {
+       mode = "";
+    }
+
+    if (conf->file == NULL) {
+        conf->file = prev->file;
+        conf->line = prev->line;
+    }
+
+    if (*mode) {
+
+        if (conf->certificate.len == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                          "no \"ssl_certificate\" is defined for "
+                          "the \"%s\" directive in %s:%ui",
+                          mode, conf->file, conf->line);
+            return NGX_CONF_ERROR;
+        }
+
+        if (conf->certificate_key.len == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                          "no \"ssl_certificate_key\" is defined for "
+                          "the \"%s\" directive in %s:%ui",
+                          mode, conf->file, conf->line);
+            return NGX_CONF_ERROR;
+        }
+
+    } else {
+
+        if (conf->certificate.len == 0) {
+            return NGX_CONF_OK;
+        }
+
+        if (conf->certificate_key.len == 0) {
+            ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                          "no \"ssl_certificate_key\" is defined "
+                          "for certificate \"%V\"",
+                          &conf->certificate);
+            return NGX_CONF_ERROR;
+        }
+    }
+
+    if (ngx_ssl_create(&conf->ssl, conf->protocols, NULL) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    cln = ngx_pool_cleanup_add(cf->pool, 0);
+    if (cln == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    cln->handler = ngx_ssl_cleanup_ctx;
+    cln->data = &conf->ssl;
+
+    if (ngx_ssl_certificate(cf, &conf->ssl, &conf->certificate,
+                            &conf->certificate_key)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+
+    if (SSL_CTX_set_cipher_list(conf->ssl.ctx,
+                                (const char *) conf->ciphers.data)
+        == 0)
+    {
+        ngx_ssl_error(NGX_LOG_EMERG, cf->log, 0,
+                      "SSL_CTX_set_cipher_list(\"%V\") failed",
+                      &conf->ciphers);
+        return NGX_CONF_ERROR;
+    }
+
+    if (conf->prefer_server_ciphers) {
+        SSL_CTX_set_options(conf->ssl.ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
+    }
+
+    SSL_CTX_set_tmp_rsa_callback(conf->ssl.ctx, ngx_ssl_rsa512_key_callback);
+
+    if (ngx_ssl_dhparam(cf, &conf->ssl, &conf->dhparam) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    if (ngx_ssl_ecdh_curve(cf, &conf->ssl, &conf->ecdh_curve) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_conf_merge_value(conf->builtin_session_cache,
+                         prev->builtin_session_cache, NGX_SSL_NONE_SCACHE);
+
+    if (conf->shm_zone == NULL) {
+        conf->shm_zone = prev->shm_zone;
+    }
+
+    if (ngx_ssl_session_cache(&conf->ssl, &ngx_mail_ssl_sess_id_ctx,
+                              conf->builtin_session_cache,
+                              conf->shm_zone, conf->session_timeout)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+
+    ngx_conf_merge_value(conf->session_tickets,
+                         prev->session_tickets, 1);
+
+#ifdef SSL_OP_NO_TICKET
+    if (!conf->session_tickets) {
+        SSL_CTX_set_options(conf->ssl.ctx, SSL_OP_NO_TICKET);
+    }
+#endif
+
+    ngx_conf_merge_ptr_value(conf->session_ticket_keys,
+                         prev->session_ticket_keys, NULL);
+
+    if (ngx_ssl_session_ticket_keys(cf, &conf->ssl, conf->session_ticket_keys)
+        != NGX_OK)
+    {
+        return NGX_CONF_ERROR;
+    }
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_mail_ssl_enable(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_mail_ssl_conf_t  *scf = conf;
+
+    char  *rv;
+
+    rv = ngx_conf_set_flag_slot(cf, cmd, conf);
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    if (scf->enable && (ngx_int_t) scf->starttls > NGX_MAIL_STARTTLS_OFF) {
+        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
+                           "\"starttls\" directive conflicts with \"ssl on\"");
+        return NGX_CONF_ERROR;
+    }
+
+    scf->file = cf->conf_file->file.name.data;
+    scf->line = cf->conf_file->line;
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_mail_ssl_starttls(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_mail_ssl_conf_t  *scf = conf;
+
+    char  *rv;
+
+    rv = ngx_conf_set_enum_slot(cf, cmd, conf);
+
+    if (rv != NGX_CONF_OK) {
+        return rv;
+    }
+
+    if (scf->enable == 1 && (ngx_int_t) scf->starttls > NGX_MAIL_STARTTLS_OFF) {
+        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,
+                           "\"ssl\" directive conflicts with \"starttls\"");
+        return NGX_CONF_ERROR;
+    }
+
+    scf->file = cf->conf_file->file.name.data;
+    scf->line = cf->conf_file->line;
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_mail_ssl_session_cache(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_mail_ssl_conf_t  *scf = conf;
+
+    size_t       len;
+    ngx_str_t   *value, name, size;
+    ngx_int_t    n;
+    ngx_uint_t   i, j;
+
+    value = cf->args->elts;
+
+    for (i = 1; i < cf->args->nelts; i++) {
+
+        if (ngx_strcmp(value[i].data, "off") == 0) {
+            scf->builtin_session_cache = NGX_SSL_NO_SCACHE;
+            continue;
+        }
+
+        if (ngx_strcmp(value[i].data, "none") == 0) {
+            scf->builtin_session_cache = NGX_SSL_NONE_SCACHE;
+            continue;
+        }
+
+        if (ngx_strcmp(value[i].data, "builtin") == 0) {
+            scf->builtin_session_cache = NGX_SSL_DFLT_BUILTIN_SCACHE;
+            continue;
+        }
+
+        if (value[i].len > sizeof("builtin:") - 1
+            && ngx_strncmp(value[i].data, "builtin:", sizeof("builtin:") - 1)
+               == 0)
+        {
+            n = ngx_atoi(value[i].data + sizeof("builtin:") - 1,
+                         value[i].len - (sizeof("builtin:") - 1));
+
+            if (n == NGX_ERROR) {
+                goto invalid;
+            }
+
+            scf->builtin_session_cache = n;
+
+            continue;
+        }
+
+        if (value[i].len > sizeof("shared:") - 1
+            && ngx_strncmp(value[i].data, "shared:", sizeof("shared:") - 1)
+               == 0)
+        {
+            len = 0;
+
+            for (j = sizeof("shared:") - 1; j < value[i].len; j++) {
+                if (value[i].data[j] == ':') {
+                    break;
+                }
+
+                len++;
+            }
+
+            if (len == 0) {
+                goto invalid;
+            }
+
+            name.len = len;
+            name.data = value[i].data + sizeof("shared:") - 1;
+
+            size.len = value[i].len - j - 1;
+            size.data = name.data + len + 1;
+
+            n = ngx_parse_size(&size);
+
+            if (n == NGX_ERROR) {
+                goto invalid;
+            }
+
+            if (n < (ngx_int_t) (8 * ngx_pagesize)) {
+                ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                                   "session cache \"%V\" is too small",
+                                   &value[i]);
+
+                return NGX_CONF_ERROR;
+            }
+
+            scf->shm_zone = ngx_shared_memory_add(cf, &name, n,
+                                                   &ngx_mail_ssl_module);
+            if (scf->shm_zone == NULL) {
+                return NGX_CONF_ERROR;
+            }
+
+            scf->shm_zone->init = ngx_ssl_session_cache_init;
+
+            continue;
+        }
+
+        goto invalid;
+    }
+
+    if (scf->shm_zone && scf->builtin_session_cache == NGX_CONF_UNSET) {
+        scf->builtin_session_cache = NGX_SSL_NO_BUILTIN_SCACHE;
+    }
+
+    return NGX_CONF_OK;
+
+invalid:
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+                       "invalid session cache \"%V\"", &value[i]);
+
+    return NGX_CONF_ERROR;
+}
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/mail/ngx_mail_ssl_module.c.rej workspace/src/mail/ngx_mail_ssl_module.c.rej
--- sources/1.5.13/nginx-1.5.13/src/mail/ngx_mail_ssl_module.c.rej	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/mail/ngx_mail_ssl_module.c.rej	2014-03-28 21:15:31.000000000 -0700
@@ -0,0 +1,265 @@
+***************
+*** 57,82 ****
+        NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+        ngx_mail_ssl_starttls,
+        NGX_MAIL_SRV_CONF_OFFSET,
+        offsetof(ngx_mail_ssl_conf_t, starttls),
+        ngx_mail_starttls_state },
+
+      { ngx_string("ssl_certificate"),
+        NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+-       ngx_conf_set_str_slot,
+        NGX_MAIL_SRV_CONF_OFFSET,
+-       offsetof(ngx_mail_ssl_conf_t, certificate),
+        NULL },
+
+      { ngx_string("ssl_certificate_key"),
+        NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+-       ngx_conf_set_str_slot,
+        NGX_MAIL_SRV_CONF_OFFSET,
+-       offsetof(ngx_mail_ssl_conf_t, certificate_key),
+        NULL },
+
+      { ngx_string("ssl_dhparam"),
+        NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+        ngx_conf_set_str_slot,
+        NGX_MAIL_SRV_CONF_OFFSET,
+        offsetof(ngx_mail_ssl_conf_t, dhparam),
+        NULL },
+--- 57,82 ----
+        NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+        ngx_mail_ssl_starttls,
+        NGX_MAIL_SRV_CONF_OFFSET,
+        offsetof(ngx_mail_ssl_conf_t, starttls),
+        ngx_mail_starttls_state },
+
+      { ngx_string("ssl_certificate"),
+        NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
++       ngx_conf_set_str_array_slot,
+        NGX_MAIL_SRV_CONF_OFFSET,
++       offsetof(ngx_mail_ssl_conf_t, certificates),
+        NULL },
+
+      { ngx_string("ssl_certificate_key"),
+        NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
++       ngx_conf_set_str_array_slot,
+        NGX_MAIL_SRV_CONF_OFFSET,
++       offsetof(ngx_mail_ssl_conf_t, certificate_keys),
+        NULL },
+
+      { ngx_string("ssl_dhparam"),
+        NGX_MAIL_MAIN_CONF|NGX_MAIL_SRV_CONF|NGX_CONF_TAKE1,
+        ngx_conf_set_str_slot,
+        NGX_MAIL_SRV_CONF_OFFSET,
+        offsetof(ngx_mail_ssl_conf_t, dhparam),
+        NULL },
+***************
+*** 173,201 ****
+      if (scf == NULL) {
+          return NULL;
+      }
+
+      /*
+       * set by ngx_pcalloc():
+       *
+       *     scf->protocols = 0;
+-      *     scf->certificate = { 0, NULL };
+-      *     scf->certificate_key = { 0, NULL };
+       *     scf->dhparam = { 0, NULL };
+       *     scf->ecdh_curve = { 0, NULL };
+       *     scf->ciphers = { 0, NULL };
+       *     scf->shm_zone = NULL;
+       */
+
+      scf->enable = NGX_CONF_UNSET;
+      scf->starttls = NGX_CONF_UNSET_UINT;
+      scf->prefer_server_ciphers = NGX_CONF_UNSET;
+      scf->builtin_session_cache = NGX_CONF_UNSET;
+      scf->session_timeout = NGX_CONF_UNSET;
+      scf->session_ticket_keys = NGX_CONF_UNSET_PTR;
+
+      return scf;
+  }
+
+
+  static char *
+  ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)
+--- 173,201 ----
+      if (scf == NULL) {
+          return NULL;
+      }
+
+      /*
+       * set by ngx_pcalloc():
+       *
+       *     scf->protocols = 0;
+       *     scf->dhparam = { 0, NULL };
+       *     scf->ecdh_curve = { 0, NULL };
+       *     scf->ciphers = { 0, NULL };
+       *     scf->shm_zone = NULL;
+       */
+
+      scf->enable = NGX_CONF_UNSET;
+      scf->starttls = NGX_CONF_UNSET_UINT;
+      scf->prefer_server_ciphers = NGX_CONF_UNSET;
+      scf->builtin_session_cache = NGX_CONF_UNSET;
+      scf->session_timeout = NGX_CONF_UNSET;
++     scf->certificates = NGX_CONF_UNSET_PTR;
++     scf->certificate_keys = NGX_CONF_UNSET_PTR;
+      scf->session_ticket_keys = NGX_CONF_UNSET_PTR;
+
+      return scf;
+  }
+
+
+  static char *
+  ngx_mail_ssl_merge_conf(ngx_conf_t *cf, void *parent, void *child)
+***************
+*** 215,232 ****
+
+      ngx_conf_merge_value(conf->prefer_server_ciphers,
+                           prev->prefer_server_ciphers, 0);
+
+      ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,
+                           (NGX_CONF_BITMASK_SET|NGX_SSL_SSLv3|NGX_SSL_TLSv1
+                            |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));
+
+-     ngx_conf_merge_str_value(conf->certificate, prev->certificate, "");
+-     ngx_conf_merge_str_value(conf->certificate_key, prev->certificate_key, "");
+
+      ngx_conf_merge_str_value(conf->dhparam, prev->dhparam, "");
+
+      ngx_conf_merge_str_value(conf->ecdh_curve, prev->ecdh_curve,
+                           NGX_DEFAULT_ECDH_CURVE);
+
+      ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);
+
+--- 215,234 ----
+
+      ngx_conf_merge_value(conf->prefer_server_ciphers,
+                           prev->prefer_server_ciphers, 0);
+
+      ngx_conf_merge_bitmask_value(conf->protocols, prev->protocols,
+                           (NGX_CONF_BITMASK_SET|NGX_SSL_SSLv3|NGX_SSL_TLSv1
+                            |NGX_SSL_TLSv1_1|NGX_SSL_TLSv1_2));
+
++     ngx_conf_merge_ptr_value(conf->certificates, prev->certificates,
++                          NGX_CONF_UNSET_PTR);
++     ngx_conf_merge_ptr_value(conf->certificate_keys, prev->certificate_keys,
++                          NGX_CONF_UNSET_PTR);
+
+      ngx_conf_merge_str_value(conf->dhparam, prev->dhparam, "");
+
+      ngx_conf_merge_str_value(conf->ecdh_curve, prev->ecdh_curve,
+                           NGX_DEFAULT_ECDH_CURVE);
+
+      ngx_conf_merge_str_value(conf->ciphers, prev->ciphers, NGX_DEFAULT_CIPHERS);
+
+***************
+*** 243,305 ****
+         mode = "";
+      }
+
+      if (conf->file == NULL) {
+          conf->file = prev->file;
+          conf->line = prev->line;
+      }
+
+-     if (*mode) {
+-
+-         if (conf->certificate.len == 0) {
+              ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                            "no \"ssl_certificate\" is defined for "
+                            "the \"%s\" directive in %s:%ui",
+                            mode, conf->file, conf->line);
+              return NGX_CONF_ERROR;
+          }
+-
+-         if (conf->certificate_key.len == 0) {
+-             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+-                           "no \"ssl_certificate_key\" is defined for "
+-                           "the \"%s\" directive in %s:%ui",
+-                           mode, conf->file, conf->line);
+-             return NGX_CONF_ERROR;
+-         }
+-
+-     } else {
+-
+-         if (conf->certificate.len == 0) {
+-             return NGX_CONF_OK;
+-         }
+-
+-         if (conf->certificate_key.len == 0) {
+-             ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+-                           "no \"ssl_certificate_key\" is defined "
+-                           "for certificate \"%V\"",
+-                           &conf->certificate);
+-             return NGX_CONF_ERROR;
+-         }
+      }
+
+      if (ngx_ssl_create(&conf->ssl, conf->protocols, NULL) != NGX_OK) {
+          return NGX_CONF_ERROR;
+      }
+
+      cln = ngx_pool_cleanup_add(cf->pool, 0);
+      if (cln == NULL) {
+          return NGX_CONF_ERROR;
+      }
+
+      cln->handler = ngx_ssl_cleanup_ctx;
+      cln->data = &conf->ssl;
+
+-     if (ngx_ssl_certificate(cf, &conf->ssl, &conf->certificate,
+-                             &conf->certificate_key)
+          != NGX_OK)
+      {
+          return NGX_CONF_ERROR;
+      }
+
+      if (SSL_CTX_set_cipher_list(conf->ssl.ctx,
+                                  (const char *) conf->ciphers.data)
+          == 0)
+--- 245,286 ----
+         mode = "";
+      }
+
+      if (conf->file == NULL) {
+          conf->file = prev->file;
+          conf->line = prev->line;
+      }
+
++     if ((conf->certificates == NGX_CONF_UNSET_PTR)
++             || (conf->certificates->nelts == 0)) {
++         if (*mode) {
+              ngx_log_error(NGX_LOG_EMERG, cf->log, 0,
+                            "no \"ssl_certificate\" is defined for "
+                            "the \"%s\" directive in %s:%ui",
+                            mode, conf->file, conf->line);
+              return NGX_CONF_ERROR;
+          }
++         return NGX_CONF_OK;
+      }
+
+      if (ngx_ssl_create(&conf->ssl, conf->protocols, NULL) != NGX_OK) {
+          return NGX_CONF_ERROR;
+      }
+
+      cln = ngx_pool_cleanup_add(cf->pool, 0);
+      if (cln == NULL) {
+          return NGX_CONF_ERROR;
+      }
+
+      cln->handler = ngx_ssl_cleanup_ctx;
+      cln->data = &conf->ssl;
+
++     if (ngx_ssl_certificates(cf, &conf->ssl, conf->certificates,
++                              conf->certificate_keys, 0, NULL, NULL, 0)
+          != NGX_OK)
+      {
+          return NGX_CONF_ERROR;
+      }
+
+      if (SSL_CTX_set_cipher_list(conf->ssl.ctx,
+                                  (const char *) conf->ciphers.data)
+          == 0)
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/mail/ngx_mail_ssl_module.h workspace/src/mail/ngx_mail_ssl_module.h
--- sources/1.5.13/nginx-1.5.13/src/mail/ngx_mail_ssl_module.h	2014-03-28 21:15:34.000000000 -0700
+++ workspace/src/mail/ngx_mail_ssl_module.h	2014-03-28 21:14:16.000000000 -0700
@@ -32,8 +32,8 @@

     time_t           session_timeout;

-    ngx_str_t        certificate;
-    ngx_str_t        certificate_key;
+    ngx_array_t     *certificates;
+    ngx_array_t     *certificate_keys;
     ngx_str_t        dhparam;
     ngx_str_t        ecdh_curve;

diff -Naurdw sources/1.5.13/nginx-1.5.13/src/mail/ngx_mail_ssl_module.h.orig workspace/src/mail/ngx_mail_ssl_module.h.orig
--- sources/1.5.13/nginx-1.5.13/src/mail/ngx_mail_ssl_module.h.orig	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/mail/ngx_mail_ssl_module.h.orig	2014-03-28 20:55:34.000000000 -0700
@@ -0,0 +1,55 @@
+
+/*
+ * Copyright (C) Igor Sysoev
+ * Copyright (C) Nginx, Inc.
+ */
+
+
+#ifndef _NGX_MAIL_SSL_H_INCLUDED_
+#define _NGX_MAIL_SSL_H_INCLUDED_
+
+
+#include <ngx_config.h>
+#include <ngx_core.h>
+#include <ngx_mail.h>
+
+
+#define NGX_MAIL_STARTTLS_OFF   0
+#define NGX_MAIL_STARTTLS_ON    1
+#define NGX_MAIL_STARTTLS_ONLY  2
+
+
+typedef struct {
+    ngx_flag_t       enable;
+    ngx_flag_t       prefer_server_ciphers;
+
+    ngx_ssl_t        ssl;
+
+    ngx_uint_t       starttls;
+    ngx_uint_t       protocols;
+
+    ssize_t          builtin_session_cache;
+
+    time_t           session_timeout;
+
+    ngx_str_t        certificate;
+    ngx_str_t        certificate_key;
+    ngx_str_t        dhparam;
+    ngx_str_t        ecdh_curve;
+
+    ngx_str_t        ciphers;
+
+    ngx_shm_zone_t  *shm_zone;
+
+    ngx_flag_t       session_tickets;
+    ngx_array_t     *session_ticket_keys;
+
+    u_char          *file;
+    ngx_uint_t       line;
+} ngx_mail_ssl_conf_t;
+
+
+extern ngx_module_t  ngx_mail_ssl_module;
+
+
+#endif /* _NGX_MAIL_SSL_H_INCLUDED_ */
diff -Naurdw sources/1.5.13/nginx-1.5.13/src/mail/ngx_mail_ssl_module.h.rej workspace/src/mail/ngx_mail_ssl_module.h.rej
--- sources/1.5.13/nginx-1.5.13/src/mail/ngx_mail_ssl_module.h.rej	1969-12-31 16:00:00.000000000 -0800
+++ workspace/src/mail/ngx_mail_ssl_module.h.rej	2014-03-28 21:15:31.000000000 -0700
@@ -0,0 +1,39 @@
+***************
+*** 27,44 ****
+
+      ngx_uint_t       starttls;
+      ngx_uint_t       protocols;
+
+      ssize_t          builtin_session_cache;
+
+      time_t           session_timeout;
+
+-     ngx_str_t        certificate;
+-     ngx_str_t        certificate_key;
+      ngx_str_t        dhparam;
+      ngx_str_t        ecdh_curve;
+
+      ngx_str_t        ciphers;
+
+      ngx_shm_zone_t  *shm_zone;
+
+      ngx_array_t     *session_ticket_keys;
+--- 27,44 ----
+
+      ngx_uint_t       starttls;
+      ngx_uint_t       protocols;
+
+      ssize_t          builtin_session_cache;
+
+      time_t           session_timeout;
+
++     ngx_array_t     *certificates;
++     ngx_array_t     *certificate_keys;
+      ngx_str_t        dhparam;
+      ngx_str_t        ecdh_curve;
+
+      ngx_str_t        ciphers;
+
+      ngx_shm_zone_t  *shm_zone;
+
+      ngx_array_t     *session_ticket_keys;
